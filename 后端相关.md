###高并发的业务架构

* 前端:异步请求+资源静态化+cdn
* 后端:请求队列+轮询分发+负载均衡+共享缓存
- 数据层:redis缓存+数据分表+写队列
- 存储:raid阵列+热备
- 网络:dns轮询+DDOS攻击防护

###基本上各种系统的架构选型就是在
- 可用性
- 数据一致性
- 实时性

这几个主要因素之间做权衡,次要问题是扩展性和成本.



##异步
异步的概念和同步相对。

与同步相对应，异步指的是让CPU暂时搁置当前请求的响应,处理下一个请求,当通过轮询或其他方式得到回调通知后,开始运行。多线程将异步操作放入另一线程中运行，通过轮询或回调方法得到完成通知,但是完成端口，由操作系统接管异步操作的调度，通过硬件中断，在完成时触发回调方法，此方式不需要占用额外线程。

###异步通信
在通信中，“异步通信”是一种很常用的通信方式。异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备（如果接收端主机的电源都没有加上，那么发送端发送字符就没有意义，因为接收端根本无法接收）。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。

异步通信也可以是以帧作为发送的单位。接收端必须随时做好接收帧的准备。这时，帧的首部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始。这也称为帧定界。帧定界还包含确定帧的结束位置。这有两种方法。一种是在帧的尾部设有某种特殊的比特组合来标志帧的结束。或者在帧首部中设有帧长度的字段。需要注意的是，在异步发送帧时，并不是说发送端对帧中的每一个字符都必须加上开始位和停止位后再发送出去，而是说，发送端可以在任意时间发送一个帧，而帧与帧之间的时间间隔也可以是任意的。在一帧中的所有比特是连续发送的。发送端不需要在发送一帧之前和接收端进行协调（不需要先进行比特同步）。

###下面关于异步的是基于C#的情况下，其他情况也基本满足
C#中异步和多线程的区别是什么呢？异步和多线程两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性。甚至有些时候我们就认为异步和多线程是等同的概念。但是，异步和多线程还是有一些区别的。而这些区别造成了使用异步和多线程的时机的区别。
- 异步操作的本质

所有的程序最终都会由计算机硬件来执行，所以为了更好的理解异步操作的本质，我们有必要了解一下它的硬件基础。 熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直 接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开 始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS 这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。

- 线程的本质

线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。

- 异步操作的优缺点

因为异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些出入，而且难以调试。

- 多线程的优缺点

多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。

- 适用范围

在了解了线程与异步操作各自的优缺点之后，我们可以来探讨一下线程和异步的合理用途。我认为：当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。

而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。但是往往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了。

###多线程磁盘读写效率
多线程磁盘读写效率（由于磁盘寻道随机性增加而导致I/O效率呈线性下降）。

###共享内存
顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

###后端杂题

- 分布式key/value存储要如何保证映射可靠，答：通过中心代理来负责映射。、
- 如果不同的例程都要向某个key更新更大的value值，如何在不用信号量，同步锁这些的情况下保证最终value是最大的(同步，set get循环巧妙)。
- 后面问了个海量数据中找第k大数(1.其实可以直接采用桶划分，即使是64位也最多三次遍历就可以了。2.也可以采用位滤除，但磁盘操作太多 3.k堆滤除，但k如果太大会频繁交换内存 4.分配到多机，多机同时外存排序，并有另外一台机子作多路归并）
- TCP的黏包现象。一个是nagle算法，一个是应用层数据的包无边界问题，这是无法解决的，因为TCP管不到应用层的事，它只负责按字节流传输。

##决定后端性能的几个关键点
在异步框架中，CPU本身是不会被IO阻塞的，而我们所关注的点就来到了：<br>
CPU消耗的主要点
- 字符串操作（尝试流）
- 内存操作（内存池）
- 数据结构设计（红黑树换HASHMAP）

并发的处理

- 锁的临界区减少（仅在必要时加小粒度锁）
- 队列化（无锁）
- 计算、存储、网络的权衡
- 合理的将网络、计算的开销减小，增大存储的开销（缓存）
- 更合理的调度（docker、云化）

性能的极限在于“平衡”：

- 计算、存储、网络，三者要做到平衡
- 大部分计算、网络的瓶颈都可以用增大存储来解决，但要有度
- 

大部分的性能 state-of-art （一台普通 4 核服务器）：

- 这台服务器的最大报文数在~50w/s （和服务器年份有关）
- 通过 C10M （ dpdk 、 netmap ）等技术可以达到 1kw+/s 的最大报文数，然而目前并没有太多卵用
- thrift 、 grpc 这类框架，一个业务逻辑较轻的服务 TPS 大概能到上万（后台服务标准）
- 分词、分类（ SVM 等），文本处理等 CPU 密集型的业务， TPS 大多只能到百级
- 特殊的：只要内存足够，长连接服务上 C10M 很轻松

###Golang的垃圾回收机制GC停止的原因
golang垃圾回收时暂停程序防止收集时产生新的垃圾

###java线程与golang协程区别|golang并发与java并发的区别
NIO（非阻塞IO）是一种IO编程模型，Golang中的IO底层实现方式和java NIO模型一致，通俗点说就是都采用了EPOLL。 你在使用golang读文件的时候，goroutine 会默默的挂起，只是你不知道，当读完毕了，goroutine 再次恢复，但你不用担心，goroutine 的挂起和恢复没有java线程那样可怕，你可以认为goroutine 的挂起和恢复就是保存和恢复几个变量的值，其实也是这样的。

剩下的就是goroutine 和 java线程的区别了，goroutine是用户态的线程切换，java采用的是系统线程切换，用汇编语言描述是一个(java)调用int 80软中断,一个没有。 意味着goroutine更轻量级，可以同时相应成千上万的线程切换，java你创造上千个线程就有些吃力了。

因为java线程不能创造过多的线程，如果同时处理上万上千的请求时候，就要考虑在几十个线程来处理上万上千的请求，这就出现了很多请求和线程不可能一一对应，所以通常做法是每个线程分别处理单个请求各个阶段。好比流水线，请求是要加工的商品，每个线程处理一道工序，这样做的好处是每人都做自己熟悉的，对于程序来说每个线程执行的代码永远都是自己很短的一块，这样根据局部优化原理，更具备CPU，内存亲和力，利于JIT。说这样多，就是说如果线程和请求不能一一对应，流水线式的并发编程很麻烦，阅读性也很差，通常是线程A里面一段逻辑代码，线程B又有另一处处理的逻辑代码。

由于goroutine 的轻便，你可以将请求和goroutine 一一对应起来，不用考虑将请求在线程之间换来换去，只关心你的业务逻辑，这就是goroutine 的好处。

总结：

golang的goroutine让你比java更容易编写并发程序，但性能不会有差别（目前来说，golang性能还不能和java比，看过代码就知道了，GC弱到爆），代码不会减少，该写的逻辑还得写。ps，其实golang的(sched)go程切换代码虽然原理和java的fork-join框架一样，但是fork-join比golang的sched代码牛逼不少，开始膜拜Doug Lea吧，golang还有很长的路要走。

###Golang中的协程与进程
线程是操作系统调度的, 抢占式的；协程是应用自己调度的.

###QPS与TPS
QPS：Queries Per Second意思是"每秒查询率"，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。

TPS：TransactionsPerSecond的缩写，也就是"事务数/秒"。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器 做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使 用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。

###泛型
我们在编写程序时，经常遇到两个模块的功能非常相似，只是一个是处理int数据，另一个是处理string数据，或者其他自定义的数据类型，但我们没有办法，只能分别写多个方法处理每个数据类型，因为方法的参数类型不同。有没有一种办法，在方法中传入通用的数据类型，这样不就可以合并代码了吗？泛型的出现就是专门解决这个问题的。

通过使用泛型类型参数T，您可以编写其他客户端代码能够使用的单个类，而不致引入运行时强制转换或装箱操作的成本或风险 使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能 泛型最常见的用途是创建集合类。

使用泛型可以最大限度的重用代码，保护类型的安全以及提高性能。

###Future，Promise与Delay并发编程的设计模式
其它语言中Future和Promise的概念大量存在，比如Node.js、Scala、Java、C#、C++ 11、Scheme、Swift等，可以方便的实现异步执行和回调。但是在Go语言的世界里，我们是通过goroutine/channel实现这种类似的功能。

Future，Promise或Delay是用于并发编程的一种设计模式。它们表示一个对象，这个对象用来作为一次计算结果的代理，而该结果开始的时候是未知的，因为计算还没有完成。Promise与Future的区别在于，Future是Promise的一个只读的视图，也就是说Future没有设置任务结果的方法，只能获取任务执行结果或者为Future添加回调函数。

##编程语言
###编译型语言
很多传统的程序设计语言，例如Fortran、Ada、Pascal、C、C++和Java，都是编译型语言。这类语言需要预先将我们写好的源代码(source code)转换成目标代码(object code)，这个过程被称作“编译”。

运行程序时，直接读取目标代码(object code)。由于编译后的目标代码(object code)非常接近计算机底层，因此执行效率很高，这是编译型语言的优点。

但是，由于编译型语言多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象，往往实现一个简单的功能需要大量复杂的代码。例如，在C++里，就很难进行“将一个目录里所有的文件复制到另一个目录中”之类的简单操作。
###解释型语言
解释型语言也被称作“脚本语言”。执行这类程序时，解释器(interpreter)需要读取我们编写的源代码(source code)，并将其转换成目标代码(object code)，再由计算机运行。因为每次执行程序都多了编译的过程，因此效率有所下降。

使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象；缺点是它们的效率通常不如编译型语言。不过权衡之下，通常使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽略它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。

##Shell脚本
因为Shell似乎是各UNIX系统之间通用的功能，并且经过了POSIX的标准化。因此，Shell脚本只要“用心写”一次，即可应用到很多系统上。因此，之所以要使用Shell脚本是基于：

- 简单性：Shell是一个高级语言；通过它，你可以简洁地表达复杂的操作。
- 可移植性：使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。
- 开发容易：可以在短时间内完成一个功能强大又妤用的脚本。

但是考虑到Shell脚本的命令限制和效率问题，下列情况一般不使用Shell：

- 资源密集型的任务，尤其在需要考虑效率时（比如，排序，hash等等）。
- 需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算（这种情- 况一般使用C++或FORTRAN 来处理）。
- 有跨平台（操作系统）移植需求（一般使用C 或Java）。
- 复杂的应用，在必须使用结构化编程的时候（需要变量的类型检查，函数原型，等等）。
- 对于影响系统全局性的关键任务应用。
- 对于安全有很高要求的任务，比如你需要一个健壮的系统来防止入侵、破解、恶意破坏等等。
- 项目由连串的依赖的各个部分组成。
- 需要大规模的文件操作。
- 需要多维数组的支持。
- 需要数据结构的支持，比如链表或数等数据结构。
- 需要产生或操作图形化界面GUI。
- 需要直接操作系统硬件。
- 需要I/O或socket接口。
- 需要使用库或者遗留下来的老代码的接口。
- 私人的、闭源的应用（shell脚本把代码就放在文本文件中，全世界都能看到）。
##几个面试题
###考到的算法题
冒泡排序|二叉树（中序）遍历|判断是否是平衡二叉树
###什么是死锁？产生的原因是什么？必要条件是什么？如何预防和解除？
如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

四个必要条件：

- 互斥条件。资源每次只能被一个进程访问。
- 占有和等待条件。已经得到某个资源的进程还可以再请求新资源。
- 不可抢占条件。已经分配给一个进程的资源不能被强制地抢占。
- 环路等待条件。每个进程都在等待着下一个进程所占有的资源。
- 
死锁的预防：

- 互斥。一切都使用假脱机技术。
- 占有和等待。在开始就请求全部资源。
- 不可抢占。抢占资源。
- 环路等待。对资源按序编号。
###c/c++引用和指针的区别？
- 引用访问一个变量是直接访问，而指针是间接访问。
- 引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。 + 不存在空引用，引用必须初始化。
- 引用在开始的时候就绑定到了一个内存空间(开始必须赋初值)，所以他只能是这个内存空间的名字，而不能改成其他的，当然可以改变这个内存空间的值。
###c/c++ new delete与malloc free的联系与区别？
- malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。
- maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。
- new 内置了sizeof、类型转换和类型安全检查功能。
- 在用delete 释放对象数组时，留意不要丢了符号‘[]’。
###c/c++ struct和class的联系和区别？
- 访问权限不同。struct 的默认访问权限是public，class 的默认访问权限是private。如果一个类中只有get/set函数，而没有其他处理数据的函数，使用struct就可以了。
- struct默认是public继承，class默认是private继承。
###"线程安全"的含义
- 程序中的每一条语句都是原子操作，则是线程安全的。
- 实例变量是在堆中分配的,并不被属于该实例的所有线程共享，只有一个线程独享，是线程安全的。
- 局部变量在堆栈中分配,因为每个线程都有它自己的堆栈空间,所以是线程安全的.
- 静态类不用被实例化,就可直接使用,也不是线程安全的。
- 单线程方式是线程安全的。
###java解释一下JVM GC的原理
GC garbage coolection，使用一个线程实现，监控内存，如果该块内存没有被对象引用，则会自动释放该内存块。常见的情况下，a = null;后，a原本引用的内存就会被自动释放。程序员也可以通过System.gc()建议JVM去释放内存。
###请简述C++中overload(重载)和override(覆盖)的区别？
- Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。（1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual 关键字可有可无。
- Override(覆盖)：是指派生类函数覆盖基类函数，特征是：（1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键字。
###请简述C++中的4种类型转换方式？
- static_cast 静态的_cast
- dynamic_cast 动态的_cast
- reinterpret_cast 重新解释的_cast
- const_cast 常量的_cast
###Java中变量的初始化
- 局部变量必须初始化，如果没有初始化而使用，会编译错误。数组会自动初始化；
- 类中的变量可以在调用构造函数的时候自动初始化，且有默认值；
- Java对于变量初始化赋值很严格，float f = 0.0(0.0为double类型)，这在C++中是会有警告，而在Java中是编译不过的。
###Java private和protected是否可以是class的访问修饰符？
- 不能。class只支持public和friendly(不写，默认的)访问修饰符，其余的都不支持；
- 一个.java文件中最多只能有一个public类，作为该文件对外的接口，且该类要与文件名相同(一个文件中可以有多个类)；
- 如果想定义成private那样的类，可以将其构造函数定义成private的访问权限，也可达到目的。
###Java final、finally、finalize的区别？
- final用来定义常量，使其初始化之后不能修改。定义函数，使其在继承类中不能被覆盖，也能实现内嵌调用，从而提高效率。定义类，该类则不能被继承，例如String；
- finally是try/catch块之后执行且总是被执行，会在return之前被调用；
- finalize()是Object中的一个方法，释放内存时会被调用，可以覆盖该函数来实现内存的释放。
###Java访问修饰符？
<pre>
          当前类     当前包    继承类    其他包

public       √         √         √        √

protected    √         √         √        ×

friendly     √         √         ×        ×

private     √          ×         ×        ×
</pre>
###java下面语句有什么问题？
<pre>
if (x) {
    x = 0;
} Java中的if条件表达式只支持boolean类型，这不同于C++中还可以支持整型。
</pre>
###java可以用于switch条件表达式的类型是什么？
- switch支持整型表达式，默认支持int；
- byte、char、short可以自动向下转换，不会造成数据丢失，所以也可以使用；
- long、float、double转换成int时会丢失数据，不能使用。
- Java 7之后，switch开始支持字符串String。
###Java throw和throws的区别？
- throws定义函数，声明这个方法会抛出这种类型的异常，使其他地方调用它时知道要捕获这个异常。使用try/catch来捕获；
- throw是具体向外抛异常的动作，所以它一定会抛出一个异常实例。
###Java支持多继承么？
Java默认只支持单继承extends，C++中的多继承对于继承的概念不是很严谨，因为继承多个对象无法确定该对象到底是属于哪个类型。而Java又提供了接口，可以被实现implements，一个类可以实现多个接口。这也是实现多继承的一种方式，而且也符合继承的概念，一个类只能有一个父类，这样不会造成混乱，实现多个接口，又能增加其他类中才有的功能。
###Java是否可以手动释放内存？
Java提供了一个方法，System.gc()，建议Java虚拟机去释放内存，当JVM决定去释放内存是，会调用该对象的finalize()方法。Java中申请内存由程序员实现，内存会申请到堆中，释放内存由GC实现。
###Java Thread的五个状态？
- 创建状态
- 就绪状态
- 运行状态
- 阻塞状态
- 死亡状态
###Java是否会出现内存泄漏？
GC会自动回收垃圾，GC采用有向图的方法，一般情况下，如果一个对象没有被引用，则该对象所占的内存将会被释放。例如，o2=o1后，o2原本引用的内存将会被释放；
<pre>
Vector v = new Vector(10);
for (int i=1;i<100; i++)
{
    Object o=new Object();
    v.add(o);
    o=null;        
} 但是当一个对象没有被引用，但是在有向图中又是可达的，而且又没有用处，那么此时就发生了内存泄漏。o=null后，由于之前指向的内存可以从v可达，那么该部分内存将不可被释放，知道v=null或v的内存释放为止。
</pre>
###Thread中run()和start()的区别？
- start()会立刻返回。调用start()方法，会创建一个线程，处于就绪状态，调用run()方法运行线程体，运行结束后，该线程结束；
- run()就是一个方法，不会创建新线程。
###synchronized和java.util.concurrent.Locks.Lock的区别？
synchronized可以作用域函数，代码块，静态函数中。在函数中使用，以当前实例为锁，表示当前实例this在不同的线程中要互斥访问。在代码块中使用，要为synchronized增加参数，要以对象为锁，互斥访问，如果以this同步，和之前的以函数同步含义相同。也可以指定对象来同步。如果同步的是静态函数，函数调用的时候可能还没有实例，不能使用this，可以使用Foo.class作为锁。
<pre>
Public synchronized void method(){
    //......
}
public void method()
{
    synchronized (this)
    {
        //......
    }
}
public void method(SomeObject so) {
    synchronized(so)
    {
        //......
    }
} + 所有对象都自动含有单一的锁。 JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务（线程）第一次给对象加锁的时候，计数变为1。每当这个相同的任务（线程）在此对象上获得锁时，计数会递增。 只有首先获得锁的任务（线程）才能继续获取该对象上的多个锁。 + Lock有比Synchronized更精确的线程域城予以和更好的性能。Synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。
</pre>