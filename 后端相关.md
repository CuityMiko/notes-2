###高并发的业务架构

* 前端:异步请求+资源静态化+cdn
* 后端:请求队列+轮询分发+负载均衡+共享缓存
* 数据层:redis缓存+数据分表+写队列
* 存储:raid阵列+热备
* 网络:dns轮询+DDOS攻击防护
###基本上各种系统的架构选型就是在
- 可用性
- 数据一致性
- 实时性

这几个主要因素之间做权衡,次要问题是扩展性和成本。
##异步
异步的概念和同步相对。

与同步相对应，异步指的是让CPU暂时搁置当前请求的响应,处理下一个请求,当通过轮询或其他方式得到回调通知后开始运行。多线程将异步操作放入另一线程中运行，通过轮询或回调方法得到完成通知,但是完成端口，由操作系统接管异步操作的调度，通过硬件中断，在完成时触发回调方法，此方式不需要占用额外线程。
###异步通信
在通信中，"异步通信"是一种很常用的通信方式。异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备（如果接收端主机的电源都没有加上，那么发送端发送字符就没有意义，因为接收端根本无法接收）。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。

异步通信也可以是以帧作为发送的单位。接收端必须随时做好接收帧的准备。这时，帧的首部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始。这也称为帧定界。帧定界还包含确定帧的结束位置。这有两种方法。一种是在帧的尾部设有某种特殊的比特组合来标志帧的结束。或者在帧首部中设有帧长度的字段。需要注意的是，在异步发送帧时，并不是说发送端对帧中的每一个字符都必须加上开始位和停止位后再发送出去，而是说，发送端可以在任意时间发送一个帧，而帧与帧之间的时间间隔也可以是任意的。在一帧中的所有比特是连续发送的。发送端不需要在发送一帧之前和接收端进行协调（不需要先进行比特同步）。
###下面关于异步的是基于C#的情况下，其他(编程语言)也基本满足
C#中异步和多线程的区别是什么呢？异步和多线程两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性。甚至有些时候我们就认为异步和多线程是等同的概念。但是，异步和多线程还是有一些区别的。而这些区别造成了使用异步和多线程的时机的区别。

- 异步操作的本质

所有的程序最终都会由计算机硬件来执行，所以为了更好的理解异步操作的本质，我们有必要了解一下它的硬件基础。 熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直 接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开 始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS 这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。

- 线程的本质

线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。

- 异步操作的优缺点

因为异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些出入，而且难以调试。

- 多线程的优缺点

多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。

- 适用范围

在了解了线程与异步操作各自的优缺点之后，我们可以来探讨一下线程和异步的合理用途。我认为：当需要执行I/O操作时，使用异步操作比使用线程+同步 I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。

而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。但是往往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了。
###多线程磁盘读写效率
多线程磁盘读写效率（由于磁盘寻道随机性增加而导致I/O效率呈线性下降）。
###共享内存
顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。
###后端几个小面试题

- 分布式key/value存储要如何保证映射可靠，答：通过中心代理来负责映射。
- 如果不同的例程都要向某个key更新更大的value值，如何在不用信号量，同步锁这些的情况下保证最终value是最大的(同步，set get循环巧妙)。
- 后面问了个海量数据中找第k大数(1.其实可以直接采用桶划分，即使是64位也最多三次遍历就可以了。2.也可以采用位滤除，但磁盘操作太多。3.k堆滤除，但k如果太大会频繁交换内存。 4.分配到多机，多机同时外存排序，并有另外一台机子作多路归并）
- TCP的黏包现象。一个是nagle算法，一个是应用层数据的包无边界问题，这是无法解决的，因为TCP管不到应用层的事，它只负责按字节流传输。
##决定后端性能的几个关键点
在异步框架中，CPU本身是不会被IO阻塞的，而我们所关注的点就来到了：<br>
CPU消耗的主要点

- 字符串操作（尝试流）
- 内存操作（内存池）
- 数据结构设计（红黑树换HASHMAP）

并发的处理

- 锁的临界区减少（仅在必要时加小粒度锁）
- 队列化（无锁）
- 计算、存储、网络的权衡
- 合理的将网络、计算的开销减小，增大存储的开销（缓存）
- 更合理的调度（docker、云化）

性能的极限在于"平衡"：

- 计算、存储、网络，三者要做到平衡
- 大部分计算、网络的瓶颈都可以用增大存储来解决，但要有度 

大部分的性能 state-of-art（一台普通4核服务器）：

- 这台服务器的最大报文数在~50w/s （和服务器年份有关）
- 通过C10M（dpdk 、netmap）等技术可以达到1kw+/s的最大报文数，然而目前并没有太多卵用
- thrift 、grpc这类框架，一个业务逻辑较轻的服务TPS大概能到上万（后台服务标准）
- 分词、分类（ SVM 等），文本处理等 CPU 密集型的业务，TPS大多只能到百级
- 特殊的：只要内存足够，长连接服务上C10M很轻松
###Golang的垃圾回收机制GC停止的原因
golang垃圾回收时暂停程序防止收集时产生新的垃圾
###java线程与golang协程区别|golang并发与java并发的区别
NIO（非阻塞IO）是一种IO编程模型，Golang中的IO底层实现方式和java NIO模型一致，通俗点说就是都采用了EPOLL。 你在使用golang读文件的时候，goroutine 会默默的挂起，只是你不知道，当读完毕了，goroutine 再次恢复，但你不用担心，goroutine 的挂起和恢复没有java线程那样可怕，你可以认为goroutine 的挂起和恢复就是保存和恢复几个变量的值，其实也是这样的。

剩下的就是goroutine 和 java线程的区别了，goroutine是用户态的线程切换，java采用的是系统线程切换，用汇编语言描述是一个(java)调用int 80软中断,一个没有。 意味着goroutine更轻量级，可以同时相应成千上万的线程切换，java你创造上千个线程就有些吃力了。

因为java线程不能创造过多的线程，如果同时处理上万上千的请求时候，就要考虑在几十个线程来处理上万上千的请求，这就出现了很多请求和线程不可能一一对应，所以通常做法是每个线程分别处理单个请求各个阶段。好比流水线，请求是要加工的商品，每个线程处理一道工序，这样做的好处是每人都做自己熟悉的，对于程序来说每个线程执行的代码永远都是自己很短的一块，这样根据局部优化原理，更具备CPU，内存亲和力，利于JIT。说这样多，就是说如果线程和请求不能一一对应，流水线式的并发编程很麻烦，阅读性也很差，通常是线程A里面一段逻辑代码，线程B又有另一处处理的逻辑代码。

由于goroutine 的轻便，你可以将请求和goroutine 一一对应起来，不用考虑将请求在线程之间换来换去，只关心你的业务逻辑，这就是goroutine 的好处。

总结：

golang的goroutine让你比java更容易编写并发程序，但性能不会有差别（目前来说，golang性能还不能和java比，看过代码就知道了，GC弱到爆），代码不会减少，该写的逻辑还得写。ps，其实golang的(sched)go程切换代码虽然原理和java的fork-join框架一样，但是fork-join比golang的sched代码牛逼不少，开始膜拜Doug Lea吧，golang还有很长的路要走。
###Golang中的协程与进程
线程是操作系统调度的, 抢占式的；协程是应用自己调度的.
###QPS与TPS
QPS：Queries Per Second意思是"每秒查询率"，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。

TPS：TransactionsPerSecond的缩写，也就是"事务数/秒"。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器 做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使 用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。
###泛型
我们在编写程序时，经常遇到两个模块的功能非常相似，只是一个是处理int数据，另一个是处理string数据，或者其他自定义的数据类型，但我们没有办法，只能分别写多个方法处理每个数据类型，因为方法的参数类型不同。有没有一种办法，在方法中传入通用的数据类型，这样不就可以合并代码了吗？泛型的出现就是专门解决这个问题的。

通过使用泛型类型参数T，您可以编写其他客户端代码能够使用的单个类，而不致引入运行时强制转换或装箱操作的成本或风险 使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能 泛型最常见的用途是创建集合类。

使用泛型可以最大限度的重用代码，保护类型的安全以及提高性能。
###Future，Promise与Delay并发编程的设计模式
其它语言中Future和Promise的概念大量存在，比如Node.js、Scala、Java、C#、C++ 11、Scheme、Swift等，可以方便的实现异步执行和回调。但是在Go语言的世界里，我们是通过goroutine/channel实现这种类似的功能。

Future，Promise或Delay是用于并发编程的一种设计模式。它们表示一个对象，这个对象用来作为一次计算结果的代理，而该结果开始的时候是未知的，因为计算还没有完成。Promise与Future的区别在于，Future是Promise的一个只读的视图，也就是说Future没有设置任务结果的方法，只能获取任务执行结果或者为Future添加回调函数。
##编程语言
###编译型语言
很多传统的程序设计语言，例如Fortran、Ada、Pascal、C、C++和Java，都是编译型语言。这类语言需要预先将我们写好的源代码(source code)转换成目标代码(object code)，这个过程被称作"编译"。

运行程序时，直接读取目标代码(object code)。由于编译后的目标代码(object code)非常接近计算机底层，因此执行效率很高，这是编译型语言的优点。

但是，由于编译型语言多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象，往往实现一个简单的功能需要大量复杂的代码。例如，在C++里，就很难进行“将一个目录里所有的文件复制到另一个目录中”之类的简单操作。
###解释型语言
解释型语言也被称作"脚本语言"。执行这类程序时，解释器(interpreter)需要读取我们编写的源代码(source code)，并将其转换成目标代码(object code)，再由计算机运行。因为每次执行程序都多了编译的过程，因此效率有所下降。

使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象；缺点是它们的效率通常不如编译型语言。不过权衡之下，通常使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽略它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。
##Shell脚本
因为Shell似乎是各UNIX系统之间通用的功能，并且经过了POSIX的标准化。因此，Shell脚本只要"用心写"一次，即可应用到很多系统上。因此，之所以要使用Shell脚本是基于：

- 简单性：Shell是一个高级语言；通过它，你可以简洁地表达复杂的操作。
- 可移植性：使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。
- 开发容易：可以在短时间内完成一个功能强大又妤用的脚本。

但是考虑到Shell脚本的命令限制和效率问题，下列情况一般不使用Shell：

- 资源密集型的任务，尤其在需要考虑效率时（比如，排序，hash等等）。
- 需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算（这种情- 况一般使用C++或FORTRAN 来处理）。
- 有跨平台（操作系统）移植需求（一般使用C 或Java）。
- 复杂的应用，在必须使用结构化编程的时候（需要变量的类型检查，函数原型，等等）。
- 对于影响系统全局性的关键任务应用。
- 对于安全有很高要求的任务，比如你需要一个健壮的系统来防止入侵、破解、恶意破坏等等。
- 项目由连串的依赖的各个部分组成。
- 需要大规模的文件操作。
- 需要多维数组的支持。
- 需要数据结构的支持，比如链表或数等数据结构。
- 需要产生或操作图形化界面GUI。
- 需要直接操作系统硬件。
- 需要I/O或socket接口。
- 需要使用库或者遗留下来的老代码的接口。
- 私人的、闭源的应用（shell脚本把代码就放在文本文件中，全世界都能看到）。
##几个面试题
###考到的算法题
冒泡排序|二叉树（中序）遍历|判断是否是平衡二叉树
###什么是死锁？产生的原因是什么？必要条件是什么？如何预防和解除？
如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

四个必要条件：

- 互斥条件。资源每次只能被一个进程访问。
- 占有和等待条件。已经得到某个资源的进程还可以再请求新资源。
- 不可抢占条件。已经分配给一个进程的资源不能被强制地抢占。
- 环路等待条件。每个进程都在等待着下一个进程所占有的资源。
####死锁的预防：
- 互斥。一切都使用假脱机技术。
- 占有和等待。在开始就请求全部资源。
- 不可抢占。抢占资源。
- 环路等待。对资源按序编号。
###c/c++引用和指针的区别？
- 引用访问一个变量是直接访问，而指针是间接访问。
- 引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。 + 不存在空引用，引用必须初始化。
- 引用在开始的时候就绑定到了一个内存空间(开始必须赋初值)，所以他只能是这个内存空间的名字，而不能改成其他的，当然可以改变这个内存空间的值。
###c/c++ new delete与malloc free的联系与区别？
- malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。
- maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。
- new 内置了sizeof、类型转换和类型安全检查功能。
- 在用delete 释放对象数组时，留意不要丢了符号‘[]’。
###c/c++ struct和class的联系和区别？
- 访问权限不同。struct 的默认访问权限是public，class 的默认访问权限是private。如果一个类中只有get/set函数，而没有其他处理数据的函数，使用struct就可以了。
- struct默认是public继承，class默认是private继承。
###"线程安全"的含义
- 程序中的每一条语句都是原子操作，则是线程安全的。
- 实例变量是在堆中分配的,并不被属于该实例的所有线程共享，只有一个线程独享，是线程安全的。
- 局部变量在堆栈中分配,因为每个线程都有它自己的堆栈空间,所以是线程安全的.
- 静态类不用被实例化,就可直接使用,也不是线程安全的。
- 单线程方式是线程安全的。
###java解释一下JVM GC的原理
GC garbage coolection，使用一个线程实现，监控内存，如果该块内存没有被对象引用，则会自动释放该内存块。常见的情况下，a = null;后，a原本引用的内存就会被自动释放。程序员也可以通过System.gc()建议JVM去释放内存。
###请简述C++中overload(重载)和override(覆盖)的区别？
- Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。（1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual 关键字可有可无。
- Override(覆盖)：是指派生类函数覆盖基类函数，特征是：（1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键字。
###请简述C++中的4种类型转换方式？
- static_cast 静态的_cast
- dynamic_cast 动态的_cast
- reinterpret_cast 重新解释的_cast
- const_cast 常量的_cast
###Java中变量的初始化
- 局部变量必须初始化，如果没有初始化而使用，会编译错误。数组会自动初始化；
- 类中的变量可以在调用构造函数的时候自动初始化，且有默认值；
- Java对于变量初始化赋值很严格，float f = 0.0(0.0为double类型)，这在C++中是会有警告，而在Java中是编译不过的。
###Java private和protected是否可以是class的访问修饰符？
- 不能。class只支持public和friendly(不写，默认的)访问修饰符，其余的都不支持；
- 一个.java文件中最多只能有一个public类，作为该文件对外的接口，且该类要与文件名相同(一个文件中可以有多个类)；
- 如果想定义成private那样的类，可以将其构造函数定义成private的访问权限，也可达到目的。
###Java final、finally、finalize的区别？
- final用来定义常量，使其初始化之后不能修改。定义函数，使其在继承类中不能被覆盖，也能实现内嵌调用，从而提高效率。定义类，该类则不能被继承，例如String；
- finally是try/catch块之后执行且总是被执行，会在return之前被调用；
- finalize()是Object中的一个方法，释放内存时会被调用，可以覆盖该函数来实现内存的释放。
###Java访问修饰符？
<pre>
         当前类     当前包    继承类    其他包

public       √         √         √        √

protected    √         √         √        ×

friendly     √         √         ×        ×

private      √         ×         ×        ×
</pre>
###java下面语句有什么问题？
<pre>
if (x) {
    x = 0;
}  //Java中的if条件表达式只支持boolean类型，这不同于C++中还可以支持整型。
</pre>
###java可以用于switch条件表达式的类型是什么？
- switch支持整型表达式，默认支持int；
- byte、char、short可以自动向下转换，不会造成数据丢失，所以也可以使用；
- long、float、double转换成int时会丢失数据，不能使用。
- Java 7之后，switch开始支持字符串String。
###Java throw和throws的区别？
- throws定义函数，声明这个方法会抛出这种类型的异常，使其他地方调用它时知道要捕获这个异常。使用try/catch来捕获；
- throw是具体向外抛异常的动作，所以它一定会抛出一个异常实例。
###Java支持多继承么？
Java默认只支持单继承extends，C++中的多继承对于继承的概念不是很严谨，因为继承多个对象无法确定该对象到底是属于哪个类型。而Java又提供了接口，可以被实现implements，一个类可以实现多个接口。这也是实现多继承的一种方式，而且也符合继承的概念，一个类只能有一个父类，这样不会造成混乱，实现多个接口，又能增加其他类中才有的功能。
###Java是否可以手动释放内存？
Java提供了一个方法，System.gc()，建议Java虚拟机去释放内存，当JVM决定去释放内存是，会调用该对象的finalize()方法。Java中申请内存由程序员实现，内存会申请到堆中，释放内存由GC实现。
###Java Thread的五个状态？
- 创建状态
- 就绪状态
- 运行状态
- 阻塞状态
- 死亡状态
###Java是否会出现内存泄漏？
GC会自动回收垃圾，GC采用有向图的方法，一般情况下，如果一个对象没有被引用，则该对象所占的内存将会被释放。例如，o2=o1后，o2原本引用的内存将会被释放；
<pre>
Vector v = new Vector(10);
for (int i=1;i<100; i++)
{
    Object o=new Object();
    v.add(o);
    o=null;        
} 但是当一个对象没有被引用，但是在有向图中又是可达的，而且又没有用处，那么此时就发生了内存泄漏。o=null后，由于之前指向的内存可以从v可达，那么该部分内存将不可被释放，知道v=null或v的内存释放为止。
</pre>
###Thread中run()和start()的区别？
- start()会立刻返回。调用start()方法，会创建一个线程，处于就绪状态，调用run()方法运行线程体，运行结束后，该线程结束；
- run()就是一个方法，不会创建新线程。
###synchronized和java.util.concurrent.Locks.Lock的区别？
synchronized可以作用域函数，代码块，静态函数中。在函数中使用，以当前实例为锁，表示当前实例this在不同的线程中要互斥访问。在代码块中使用，要为synchronized增加参数，要以对象为锁，互斥访问，如果以this同步，和之前的以函数同步含义相同。也可以指定对象来同步。如果同步的是静态函数，函数调用的时候可能还没有实例，不能使用this，可以使用Foo.class作为锁。
<pre>
Public synchronized void method(){
    //.....
}
public void method()
{
    synchronized (this)
    {
        //......
    }
}
public void method(SomeObject so) {
    synchronized(so)
    {
        //......
    }
} + 所有对象都自动含有单一的锁。 JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务（线程）第一次给对象加锁的时候，计数变为1。每当这个相同的任务（线程）在此对象上获得锁时，计数会递增。 只有首先获得锁的任务（线程）才能继续获取该对象上的多个锁。 + Lock有比Synchronized更精确的线程域城予以和更好的性能。Synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。
</pre>
###wait()、notify()、notifyAll()的作用？
- 这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。
- 如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。
- 如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
- 如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。

Java面试中也会常常去问对于Java包源码的理解。下面按照根据Java包来介绍。 java.lang包，Java的基础包，编译时会自动导入，主要包含Java基类Object，包装类Boolean、Character、Byte、Short、Integer、Long、Float、Double，Enum，String、StringBuffer、StringBuilder，Thread，Process，Math，Throwable，Error，Exception。
###java.lang.Object
<pre>
方法                                                            说明

public final native Class<?> getClass();                        返回一个对象的运行时类

public native int hashCode();                                   返回该对象的哈希码值，将对象在内存中的地址转成int并返回

public boolean equals(Object obj) {						        指示某个其他对象是否与此对象“相等”。默认使用==来判断引用对象的地址。
    return (this == obj);
}   
                                           
protected native Object clone() throws CloneNotSupportedException;创建并返回此对象的一个副本。该对象要实现Cloneable接口，否则会抛出CloneNotSupportedException异常

public String toString() {										  返回该对象的字符串表示，用hashCode()辅助实现
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}

public final native void notify();                                唤醒在此对象监视器上等待的单个线程

public final native void notifyAll();                            唤醒在此对象监视器上等待的所有线程

public final native void wait(long timeout) throws InterruptedException;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量

public final void wait(long timeout, int nanos) throws InterruptedException导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量

public final void wait() throws InterruptedException {        导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法
    wait(0);
}

protected void finalize() throws Throwable { }                  当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法
</pre>
###java.lang.Math
<pre>
Math是一个final类，不能被继承，提供了一套静态方法，实现数字计算的常见功能。

方法                                                             说明
public static double ceil(double a) {                            向上取整
    return StrictMath.ceil(a); // default impl. delegates to StrictMath
}

public static double floor(double a) {                            向下取整
    return StrictMath.floor(a); // default impl. delegates to StrictMath

}

public static int round(float a) {                               
加0.5后向下取整
    if (a != 0x1.fffffep-2f) // greatest float value less than 0.5
        return (int)floor(a + 0.5f);
    else
        return 0;
}

ceil和floor返回的都是double，round返回的是int和long
</pre>
###更多关于java的面试题请点击http://blog.cyeam.com/java/2014/01/02/javacollection/
##C基础
<pre>
#include<stdio.h>
#include<string.h>
#include <errno.h>
#include <stdlib.h>
/*int main,和void main是有不同的，int main是
指main函数需要返回一个int值,而void main则不需要返回值（即空值）
*/
#define width 10       //定义常量方法之一 
const int height = 20; //定义常量方法之二 
/*
auto 只能用在函数内，即 auto 只能修饰局部变量
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量
static 修饰局部变量可以在函数调用之间保持局部变量的值
extern 是用来在另一个文件中声明一个全局变量或函数
*/ 
/*
&&	称为逻辑与运算符。如果两个操作数都非零，则条件为真。
||	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。
*/
/*
&	如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。	(A & B) 将得到 12，即为 0000 1100
|	如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。	(A | B) 将得到 61，即为 0011 1101
^	如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中;	(A ^ B) 将得到 49，即为 0011 0001	
p	q	p & q	p | q	p ^ q
0	0	  0		  0		  0 
0	1	  0		  1		  1
1	1 	  1	  	  1		  0
1	0	  0		  1		  1
*/
/*
每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址
*/
/*
strchr(s1, ch);
返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
strstr(s1, s2);
返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
*/
/*
位域
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，
只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。
所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，
允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。
位域定义与结构定义相仿，其形式为：
    struct 位域结构名
        { 位域列表 };
其中位域列表的形式为：
    类型说明符 位域名: 位域长度 
例如：
struct bs{
    int a:8;
    int b:2;
    int c:6;
};
*/
/*
共用体
共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，
但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。
定义共用体
为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];
 
*/
/*typedef
C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：
typedef unsigned char BYTE;
在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：
BYTE  b1, b2;
*/
/*输入输出
gets() & puts() 函数
char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。
int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。 

scanf() 和 printf() 函数
int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。
int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。

format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。
还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册
*/
/*
C 语言为内存的分配和管理提供了几个函数。这些函数可以
在 <stdlib.h> 头文件中找到。
void *calloc(int num, int size);
该函数分配一个带有 function allocates an array of num 个元素的数组，每个元素的大小为 size 字节。
void free(void *address); 
该函数释放 address 所指向的h内存块。
void *malloc(int num); 
该函数分配一个 num 字节的数组，并把它们进行初始化。
void *realloc(void *address, int newsize); 
该函数重新分配内存，把内存扩展到 newsize。

*/
int max(int num1,int num2);  /*函数先必须声明*/
void func(void);  /*函数必须声明*/
static int count = 5; /*全局变量*/ 
//结构体 
struct Books {
		char title[50];
		char author[50];
		char subject[100];
		int book_id;
};
//共用体
union Data{
	int ui;
	float uf;
	char str[20];
}; 
void printBook(struct Books book);  //结构体作为函数 
void printBookPtr(struct Books *book);  //指向结构的指针的函数 
int main(){
	printf("Hello world\n") ;
	printf("%d\n",width);
	printf("%d\n",height);
	while (count--){
		func();
	}
	int q1 = 4;
	int q2 = 5;
	int q3 = 0;
	if (q1 && q2){
		printf("JASON is TRUE\n");
	}
	if(q1 && q3){
		printf("Jason fault\n");
	}else{
		printf("KK\n");
	}
	int d1 = 0;
	int d2 = 1;
	printf("%d\n",d2^d1);
	printf("max函数的结果(最大值)是：%d\n",max(d1,d2)); 
	printf("sum函数的结果是：%d\n",sum(d1,d2));
	//杂项运算符  sizeof & 三元
	int size11 = 99;  //返回总是4 ？ 
	short b;
	double c;
	int* ptr;
	printf("%d\n",sizeof(size11));
	printf("*ptr 是 %d\n",*ptr);
	//数组 
	int n[5]; /*n是一个包含5个整数的数组*/
	int i,j;
	/*初始化数组元素*/
	for(i=0;i<5;i++){
		n[i] = i +10;
	}
	/*输出所有数组元素*/ 
	for(j=0;j<5;j++){
		printf("Element[%d]=%d\n",j,n[j]);
	}
	//指针 指针是一个变量，其值为另一个变量的地址.指针变量声明的一般形式:type *var_name;
	int var2 = 45;
	int *ptr2;
	int *ptr3=NULL; //空指针|在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值 
	ptr2 = &var2;
	printf("var2变量的地址：%x\n",&var2); 
	printf("ptr2指向的变量地址：%x\n",ptr2);
	printf("ptr2指向的变量值：%d\n",*ptr2);
	printf("ptr3的值是%x\n",ptr3); 
	//字符串 需要引入string.h文件  
	char greeting[7]={'g','o','o','g','l','e','\n'}; 
	printf("Greeting message:%s\n",greeting);
	char str1[12] = "Hello";
	char str2[10] = "Jason";
	char str3[10];
	strcpy(str3,str1);  //str1复制给str3 
	printf("str3字符串的内容:%s\n",str3);
	strcat(str1,str2);//连接字符串str2到字符串str1的末尾
	printf("连接后的结果是:%s\n",str1);
	printf("str1的长度是：%d\n",strlen(str1));		
	struct Books Book1; /*声明Book1,类型为Books*/
	strcpy(Book1.title,"C Programing");
	strcpy(Book1.author,"Nuha Ali");
	strcpy(Book1.subject,"Telecom Billing Tutorial");
	Book1.book_id = 4545;
	printf("Book1 title:%s\n",Book1.title);
	printf("Book1 author:%s\n",Book1.author);
	printf("Book1 subject:%s\n",Book1.subject);
	printf("Book1 book_id:%d\n",Book1.book_id);
	//结构体函数	
	printBook(Book1);
	printBookPtr(&Book1);
	//公用体
	union Data data;
	data.ui = 10;
	data.uf = 220.5;
	strcpy(data.str,"C Jason");
	printf("共用体data.ui:%d\n",data.ui);
	printf("Memory size occupied by data:%d\n",sizeof(data)); 
	//文件操作
	/* 创建新文件，追加内容 
	FILE *fp;
	fp=fopen("test.txt","w+"); 
	fprintf(fp,"This is testing for fprintf....\n");
	fputs("This is testing for fputs...\n",fp);
	fclose(fp); */
	FILE *fp;
	char buff[255];
	fp = fopen("test.txt","r");
	fscanf(fp,"%s",buff);
	printf("test.txt的内容是1:%s\n",buff);  //This
	char buff2[255];
	fgets(buff2,255,(FILE*)fp);//is testing for fprintf...
	printf("test.txt的内容是2:%s\n",buff2);
	char buff3[255];
	fgets(buff3,255,(FILE*)fp);//This is testing for fputs...
	printf("test.txt的内容是3:%s\n",buff3);
	fclose(fp);
	/*
	首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格
	。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，
	调用 fgets() 完整地读取第二行。
	*/ 
	//预处理器 
	printf("Date:%s\n",__DATE__); //输出系统日期  月日年 
	printf("Time:%s\n",__TIME__); //输出系统时间  时分秒 
	printf("Line:%d\n",__LINE__); //当前行数
	printf("File:%s\n",__FILE__); //当前文件路径及名称 
	//强制类型转换
	int sumlei = 17,countlei = 5;
	double meanlei;
	meanlei = (double) sumlei /countlei;
	printf("Value of meanlei :%f\n",meanlei); 
	//错误处理 需要引入errno.h
	FILE *pf;
	int errnum;
	extern int errno;
	pf=fopen("unexist.txt","rb");
	if(pf == NULL) {
		fprintf(stderr,"错误号：%d\n",errno);
		perror("通过perror输出错误");
		fprintf(stderr,"打开文件错误：%s\n",strerror(errnum));
	}else{
		fclose(pf);
	}
	//内存管理
	/*当动态分配内存时，您有完全控制权，可以传递任何大小的值。
	而那些预先定义了大小的数组，一旦定义则无法改变大小。
	当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，
	建议您在不需要内存时，都应该调用函数 free() 来释放内存。
或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。
	*/
	char namemalloc[100];
	char *description;
	strcpy(namemalloc,"zara ali");
	/*动态分配内存*/
	description=malloc(200 * sizeof(char));
	if(description == NULL){
		fprintf(stderr,"ERROR - unable to allocate required memnry\n");
	}else{
		strcpy(description,"zara ali a DPS student in class 10th");
	}
	printf("name = %s\n",namemalloc);
	printf("description = %s\n",description);
	/*使用free()函数释放内存*/
	free(description);
	
	return 0;
}
void func(void){
	static int i = 5;/*局部静态变量*/
	i++;
	printf("i is %d and count is %d\n",i,count);
}
int max(int num1,int num2) {
	int result;
	if (num1 >num2){
		result = num1;
	}else{
		result = num2;
	}

	return result;
}
int sum(int a ,int b) {
	return a+b;
}
void printBook(struct Books book) {
	printf("Book title :%s\n",book.title);
	printf("Book author :%s\n",book.author);
	printf("Book subject :%s\n",book.subject);
	printf("Book book_id :%d\n",book.book_id);
}
//为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符 
void printBookPtr(struct Books *book){
	printf("Book title :%s\n",book->title);
	printf("Book author :%s\n",book->author);
	printf("Book subject :%s\n",book->subject);
	printf("Book book_id :%d\n",book->book_id);
}
</pre>
###海量数据排序
归并虽然在内部排序表现不佳，但是外部排序确实是对的。请查找外部排序，归并排序等关键字。
###Python中的 __name__=="__main__"
作为Python新手，常常会遇到 if __name__ == "__main__" 这个问题，下面我就来解释下它的作用。

比如你编写一个test.py文件，一个python文件就可以看作是一个python的模块，这个python模块（.py文件）有两种使用方式：直接运行使用和作为模块被其他模块调用。

解释下__name__：每一个模块都有一个内置属性__name__。而__name__的值取决与python模块（.py文件）的使用方式。如果是直接运行使用，那么这个模块的__name__值就是“__main__”；如果是作为模块被其他模块调用，那么这个模块（.py文件）的__name__值就是该模块（.py文件）的文件名，且不带路径和文件扩展名。
<pre>
//如果该文件直接运行，那么在后台中它会打印：“*****Direct execute*****”
//如果是被其他模块所调用，那么在后台中它会打印：*****Module called*****
//#test.py文件
#!/usr/bin/python
from math import pi
def square(length):
area = length ** 2
print "The area of square is %0.2f" %area

def cube(length):
volume = length ** 3
print "The volume of cube is %0.2f" %volume
def circle(radius):
area = pi * radius ** 2
print "The area of circle is %0.2f" %area
def sphere(radius):
volume = 4 * pi * radius ** 2
print "The volume of sphere is %0.2f" %volume

if __name__ == "__main__":
try:
print "*****Direct execute*****"
num = float(raw_input("Enter a num:"))
square(num)
cube(num)
circle(num)
sphere(num)
except ValueError, e:
print " Input a invaild num !"

if __name__ == "test":
try:
print "*****Module called*****"
num = float(raw_input("Enter a num:"))
square(num)
cube(num)
circle(num)
sphere(num)
except ValueError, e:
print " Input a invaild num !"
</pre>
我们使用两种方法运行test.py文件：
第一种，直接运行test.py文件:直接在linux终端中运行　
<pre>
[Feng@A005 ~]$ ./test.py
*****Direct execute*****
Enter a num:5
The area of square is 25.00
The volume of cube is 125.00
The area of circle is 78.54
The volume of sphere is 314.16
</pre>
可以看出，在linux终端中，它打印出了“*****Direct execute*****”，证明直接运行该模块（.py文件），该模块的__name__值就是“__main__”。

第二种，被其他模块调用。进入python环境中，import test文件模块。
<pre>
[Feng@A005 ~]$ python
Python 2.6.6 (r266:84292, Jul 10 2013, 22:48:45)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import test
*****Module called*****
Enter a num:5
The area of square is 25.00
The volume of cube is 125.00
The area of circle is 78.54
The volume of sphere is 314.16
</pre>
可以看出，在linux终端中，它打印除了"*****Module called*****"，证明是被其他模块调用了该模块（.py文件），该模块的__name__值就是该模块的文件名，且不带路径和文件扩展名。
###Centos下搭建FTP上传下载服务器
1、首先判断你服务器上是否安装了vsftpd
<pre>
rpm -q vsftpd
</pre>
2、安装完成之后就要重启vsftpd服务
<pre>
service vsftpd restart
</pre>
3、到vsftpd的主配置文件里面
<pre>
vi /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
</pre>
把这个改为NO 默认是YES （改为NO 就是禁止匿名用户登录，不需要注释）
不可以让ftp用户跳出自己的家目录，否则太危险了。需要做限制
<pre>
chroot_local_user=YES
</pre>
默认是注释掉的，把#号去掉  然后重启vsftpd
4、创建ftp用户
<pre>
useradd -s /sbin/nologin -d /var/www/XXXX(指定文件名） admin（自定义用户名）
（admin这个用户智能连接ftp无法登录系统，默认家目录在/var/www/XXXX  文件夹下面）
</pre>
5、给admin这个用户设置密码
<pre>
passwd admin
</pre>
6、然后给家目录文件修改权限，否则你无法你无法上传文件
<pre>
chmod o+w /var/www/XXXX
</pre>
7、然后修改selinux
（查看selinux状态：/usr/sbin/sestatus -v 或 getenforce）
修改文件/etc/selinux/config  文件
将SELINUX=enforcing改为SELINUX=disabled
重启机器即可
8、重启vsftpd服务，并且下次自动启动
<pre>
service vsftpd restart
</pre>
9、关闭防火墙
<pre>
service iptables stop
</pre>
###服务器维护中常用dos命令
1.ping命令

用法：ping+空格+域名

作用：ping命令可以用来检查网络是否通畅、域名解析是正否正确以及是否丢包等等，而在
服务器维护中ping命令是第一个必须掌握的DOS命令。

2.telnet命令

用法：telnet+空格+域名+端口号 （默认情况IIS的端口号是80,Apache的端口号是8080）

作用：测试服务器端口是否连通。

3.tracert命令(路由跟踪)

用法：tracert+空格+域名

作用：网络是一个节点连接一个节点，而每个节点都有路由，通过tracert命令可以知道自己家到服务器所在机房有多少节点，以及知道每个节点是否通畅。（一般情况节点越少，服务器打开越快）
###Linux系统查看和修改IP的方法
1.显示当前启动的网络接口命令:
<pre>
ifconfig
</pre>
2.查看当前所有网络接口命令:
<pre>
ifconfig -a
</pre>
3.查看指定网络接口命令:
<pre>
ifconfig eth0
</pre>
在LINUX下修改IP分为二种情况
- 1.调试时修改IP,仅在当前生效,重启后恢复为原有IP
<pre>
ifconfig eth0 192.168.63.27 netmask 255.255.255.0 route add default gw 192.168.63.1 up
</pre>
- 2.永久生效(即重启后也能生效)

方法1:配置网卡的配置文件 
<pre>
修改/etc/sysconfig/network-scripts/ifcfg-eth0
然后重启服务service network restart生效,或者/etc/init.d/network restart生效
</pre>
方法2:
<pre>
将ifconfig eth0 192.168.63.27 netmask 255.255.255.0 route add default gw 192.168.63.1 保存在/etc/init.d/rc.local文件中
</pre>
数据库注意事项
- mysql_free_result($result);关闭结果集
- mysql_close($link);关闭与数据库的连接
###ab工具检测apache服务器性能
<pre>
cmd切入到ab.exe目录下，ab -n 5000 -c 247 http://localhost/test.php     //模拟5000次访问量，247同时在线（并发）
-t测试进行总时间，单位是秒，默认50000s，-p post时的数据文件，-w以HTML表的格式输出结果
</pre>
###并行技术
共享内存：所有CPU共内存，所有CPU由一个操作系统控制的，例如Windows和Linux/UNIX，目前流行的多核、多CPU机器都是属于这种；

消息驱动：其实就是分布式内存，CPU由不同的操作系统控制，不同的CPU之间通过网络通信。例如网格Grid是通过因特网通信、集群Cluster是通过局域网通信、MPP是通过专有的高速网络通信。

通过上面的对比，聪明的读者估计很快就想到了这两种系统并行程序实现方式的差异：

- 共享内存：通过操作系统的多进程多线程来完成并行任务，通过进程间通信来完成协作；
- 消息驱动：通过多台机器来完成并行任务，通过消息来完成协作。(MPP物理上看是一台机器，逻辑上是多台机器)。

当然，由于消息驱动系统中每个处理单元都是一台独立的机器，对这台独立的机器本身当然也可以通过共享内存来实现并行处理。

嗯，非常不错，经过我们的层层分析和筛选，原来各种各样的看起来很吓人的并行系统，最终被我们归纳总结出两种并行实现技术：多进程多线程、多机协作。
###http500错误
Internal Server Error 解决办法：

如果你想解决PHP程序中的文件权限设置错误，并且不造成网站发生500内部服务器错误。那么需要依循以下规则：

1. 保证：文件夹权限要设置为755或者更低,文件权限要设置为644或者更低。
2. 如果文件权限是644但是PHP程序功能还是不好用，提示文件权限不够，那么可以联系客服，让他们将安全模块禁用。
###常见状态码
<pre>
static $_status = array(
    // Success 2xx
    200 => 'OK',
    // Redirection 3xx
    301 => 'Moved Permanently',  //永久移除
    302 => 'Moved Temporarily ',  // 1.1 暂时移除
    // Client Error 4xx
    400 => 'Bad Request',  //请求无效
    403 => 'Forbidden',    //禁止访问
    404 => 'Not Found',     //没有找到
    // Server Error 5xx
    500 => 'Internal Server Error',   //网络文件权限错误
    503 => 'Service Unavailable',  //服务不可用,可能是一个网站的程序占资源太多或者发生太多的错误
);
</pre>
###数据链路层的基本知识
数据链路层的作用：1、IP数据模块发送和接收IP数据报；2、为ARP模块发送ARP请求和接收ARP协议；3、为RARP发送RARP请求
和接受RARP应答。

数据链路层使用的信道主要有一下两种类型：

- 点对点信道：这种信道的通信方式是一对一的通信方式----------ppp协议
- 广播信道：这种信道使用一对多的广播通信方式，对于这种方式需要遵循专用的共享信道协议来协调主机数据的发送；
- 链路：即使从一个结点到相邻结点的一段物理线路。而中间没有任何其他的交换结点。又称 为：物理链路
- 数据链路：因为当需要在一条线路上传递数据时，除了必须使用一条物理设备时，还需要一些必要的通信协议来控制数据的传输，若把实现这些协议的硬件和软件的加到链路上，就叫做数据链路；最常用的是-----网络适配器。一般适配器都包含了数据链路层和物理层这两层的功能----又称为逻辑链路。
###TCP粘包和拆包问题
####问题产生
一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和封包问题。

下面可以看一张图，是客户端向服务端发送包：

1. 第一种情况，Data1和Data2都分开发送到了Server端，没有产生粘包和拆包的情况。
2. 第二种情况，Data1和Data2数据粘在了一起，打成了一个大的包发送到Server端，这个情况就是粘包。
3. 第三种情况，Data2被分离成Data2_1和Data2_2，并且Data2_1在Data1之前到达了服务端，这种情况就产生了拆包。

由于网络的复杂性，可能数据会被分离成N多个复杂的拆包/粘包的情况，所以在做TCP服务器的时候就需要首先解决拆包/粘包的问题。

TCP粘包和拆包产生的原因

1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小
2. 进行MSS大小的TCP分段。MSS是最大报文段长度的缩写。MSS是TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是TCP报文段的最大长度，而是：MSS=TCP报文段长度-TCP首部长度
3. 以太网的payload大于MTU进行IP分片。MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。如果IP层有一个数据包要传，而且数据的长度比链路层的MTU大，那么IP层就会进行分片，把数据包分成托干片，让每一片都不超过MTU。注意，IP分片可以发生在原始发送端主机上，也可以发生在中间路由器上。

TCP粘包和拆包的解决策略

1. 消息定长。例如100字节。
2. 在包尾部增加回车或者空格符等特殊字符进行分割，典型的如FTP协议
3. 将消息分为消息头和消息尾。
4. 其它复杂的协议，如RTMP协议等。

###网络IO模型
网络IO模型介绍

常见的IO模型有以下5种：

1. 阻塞式IO （blocking IO）
2. 无阻塞式IO （nonblocking IO）
3. IO多路复用 （IO multiplexing）
4. 信号驱动 （signal driven IO）
5. 异步IO （asynchronous IO）

阻塞式IO （blocking IO）

在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来.
    
所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。

几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一个简单地“一问一答”的服务器。

我们注意到，大部分的socket接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。
    
实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。

一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。通常，使用pthread_create ()创建新线程，fork()创建新进程。
    
我们假设对上述的服务器 / 客户机模型，提出更高的要求，即让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型。

在上述的线程 / 时间图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。
    
很多初学者可能不明白为何一个socket可以accept多次。实际上socket的设计者可能特意为多客户机的情况留下了伏笔，让accept()能够返回一个新的socket。下面是 accept 接口的原型：

int accept(int s, struct sockaddr *addr, socklen_t *addrlen);输入参数s是从socket()，bind()和listen()中沿用下来的socket句柄值。执行完bind()和listen()后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用accept()接口正是从 socket s 的请求队列抽取第一个连接信息，创建一个与s同类的新的socket返回句柄。新的socket句柄即是后续read()和recv()的输入参数。如果请求队列当前没有请求，则accept() 将进入阻塞状态直到有请求进入队列。
    
上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。
   
很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。

对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。

无阻塞式IO（nonblocking IO）

当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。
    
所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。

可以看到服务器线程可以通过循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。

IO多路复用（IO multiplexing）

IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event driven IO)。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
    
这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句：所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）
    
在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。

大部分Unix/Linux都支持select函数，该函数用于探测多个文件句柄的状态变化。下面给出select接口的原型：
<pre>
FD_ZERO(int fd, fd_set* fds)
FD_SET(int fd, fd_set* fds)
FD_ISSET(int fd, fd_set* fds)
FD_CLR(int fd, fd_set* fds)
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
struct timeval *timeout)
</pre>  
这里，fd_set 类型可以简单的理解为按 bit 位标记句柄的队列，例如要在某 fd_set 中标记一个值为16的句柄，则该fd_set的第16个bit位被标记为1。具体的置位、验证可使用 FD_SET、FD_ISSET等宏实现。在select()函数中，readfds、writefds和exceptfds同时作为输入参数和输出参数。如果输入的readfds标记了16号句柄，则select()将检测16号句柄是否可读。在select()返回后，可以通过检查readfds有否标记16号句柄，来判断该“可读”事件是否发生。另外，用户可以设置timeout时间。
 
但这个模型依旧有着很多问题。首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。

其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。如下例，庞大的执行体1的将直接导致响应事件2的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。

异步IO （asynchronous IO）

用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

用异步IO实现的服务器这里就不举例了，以后有时间另开文章来讲述。异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。
    
到目前为止，已经将四个IO模型都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。

先回答最简单的这个：blocking与non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。

在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：
<pre>
* A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;
* An asynchronous I/O operation does not cause the requesting process to be blocked;
</pre>
    
两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个系统调用。non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。而asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。
    
还有一种不常用的signal driven IO，即信号驱动IO。总的来说，UNP中总结的IO模型有5种之多：阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO。前四种都属于同步IO。阻塞IO不必说了。非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。

异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程。
  
经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。
###关于海量数据处理
常用的数据结构：

- 1.Bloom Filter

大致思想是这样，把一个数据通过N个哈希函数映射到一个长度为M的数组的一位上，将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明该数据的存在。但不能保证完全正确性，但是此方法无比高效。

【实例】给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？ 

- 2.哈希法
   
这个简单，无非是通过一些哈希函数把元素搞到一个指定的位置，简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。这个很一般啊感觉。无非就是分类查找么，完全不如1猛。

- 3.最大或最小堆
     
就是一个完全的最大或最小二叉树，用途，比如:1)100w个数中找最大的前100个数。 用一个100个元素大小的最小堆即可。感觉还是不错的。

- 4.Bit-map

所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。

实例:公司的一道考试题算法分析——大数据量整数排序。
   
题目大意：移动公司需要对已经发放的所有139段的号码进行统计排序，已经发放的139号码段的文件都存放在一个文本文件中（原题是放在两个文件中），一个号码一行，现在需要将文件里的所有号码进行排序，并写入到一个新的文件中；号码可能会有很多，最多可能有一亿个不同的号码（所有的139段号码），存入文本文件中大概要占1.2G的空间；jvm最大的内存在300以内，程序要考虑程序的可执行性及效率；只能使用Java标准库，不得使用第三方工具。
    
这是个典型的大数据量的排序算法问题，首先要考虑空间问题，一下把1.2G的数据读入内存是不太可能的，就算把1一亿条数据，转都转换成int类型存储也要占接近400M的空间。当时做个题目我并没有想太多的执行效率问题，主要就考虑了空间，而且习惯性的想到合并排序，基本思想是原文件分割成若干个小文件并排序，再将排序好的小文件合并得到最后结果，算法大概如下： 
  
1. 顺序读取存放号码文件的中所有号码，并取139之后的八位转换为int类型；每读取号码数满一百万个，（这个数据可配置）将已经读取的号码排序并存入新建的临时文件。   
2. 将所有生成的号码有序的临时文件合并存入结果文件。这个算法虽然解决了空间问题，但是运行效率极低，由于IO读写操作太多，加上步骤1中的排序的算法（快速排序）本来效率就不高（对于电话排序这种特殊情况来说），导致1亿条数据排序运行3个小时才有结果。 

另外一种是：使用是位向量（实际上就是一个bit数组），用电话作为index，心中大喜，找到了解决此问题的最完美方案啦：用位向量存储电话号码，一个号码占一个bit，一亿个电话号码也只需要大概12M的空间；算法大概如下：
<pre>
1.初始化bits[capacity]；
2.顺序所有读入电话号码，并转换为int类型，修改位向量值：bits[phoneNum]=1；
3.遍历bits数组，如果bits[index]=1，转换index为电话号码输出。 
Java中没有bit类型，一个boolean值占空间为1byte，这里写个用int模拟bit数组的类：
public class BitArray {   
    private int[] bits = null;   
    private int length;   
    //用于设置或者提取int类型的数据的某一位(bit)的值时使用  
    private final static int[] bitValue = {   
        0x80000000,//10000000 00000000 00000000 00000000         
        0x40000000,//01000000 00000000 00000000 00000000         
        0x20000000,//00100000 00000000 00000000 00000000         
        0x10000000,//00010000 00000000 00000000 00000000         
        0x08000000,//00001000 00000000 00000000 00000000         
        0x04000000,//00000100 00000000 00000000 00000000         
        0x02000000,//00000010 00000000 00000000 00000000         
        0x01000000,//00000001 00000000 00000000 00000000         
        0x00800000,//00000000 10000000 00000000 00000000         
        0x00400000,//00000000 01000000 00000000 00000000         
        0x00200000,//00000000 00100000 00000000 00000000         
        0x00100000,//00000000 00010000 00000000 00000000         
        0x00080000,//00000000 00001000 00000000 00000000         
        0x00040000,//00000000 00000100 00000000 00000000         
        0x00020000,//00000000 00000010 00000000 00000000         
        0x00010000,//00000000 00000001 00000000 00000000             
        0x00008000,//00000000 00000000 10000000 00000000         
        0x00004000,//00000000 00000000 01000000 00000000         
        0x00002000,//00000000 00000000 00100000 00000000         
        0x00001000,//00000000 00000000 00010000 00000000         
        0x00000800,//00000000 00000000 00001000 00000000         
        0x00000400,//00000000 00000000 00000100 00000000         
        0x00000200,//00000000 00000000 00000010 00000000         
        0x00000100,//00000000 00000000 00000001 00000000         
        0x00000080,//00000000 00000000 00000000 10000000         
        0x00000040,//00000000 00000000 00000000 01000000         
        0x00000020,//00000000 00000000 00000000 00100000         
        0x00000010,//00000000 00000000 00000000 00010000         
        0x00000008,//00000000 00000000 00000000 00001000         
        0x00000004,//00000000 00000000 00000000 00000100         
        0x00000002,//00000000 00000000 00000000 00000010         
        0x00000001 //00000000 00000000 00000000 00000001               
    };   
    public BitArray(int length) {   
        if(length < 0){   
            throw new IllegalArgumentException("length必须大于零！");   
        }   
        bits = new int[length / 32 + (length % 32 > 0 ? 1 : 0)];   
        this.length = length;   
    }   
    //取index位的值  
    public int getBit(int index){   
        if(index <0 || index > length){   
            throw new IllegalArgumentException("length必须大于零小于" + length);   
        }   
        int intData = bits[index/32];   
        return (intData & bitValue[index%32]) >>> (32 - index%32 -1);   
    }   
    //设置index位的值，只能为0或者1   
    public void setBit(int index,int value){   
        if(index <0 || index > length){   
            throw new IllegalArgumentException("length必须大于零小于" + length);   
        }          
        if(value!=1&&value!=0){   
            throw new IllegalArgumentException("value必须为0或者1");   
        }   
        int intData = bits[index/32];   
        if(value == 1){   
            bits[index/32] = intData | bitValue[index%32];   
        }else{   
            bits[index/32] = intData & ~bitValue[index%32];   
        }   
    }   
    public int getLength(){   
        return length;   
    }      
}        
</pre>
bit数组有了，剩下就是算法代码，核心代码如下： 
<pre>
bitArray = new BitArray(100000000);    
//顺序读取所有的手机号码  
while((phoneNum = bufferedReader.readLine())!=null){   
    phoneNum = phoneNum.trim().substring(3);//13573228432   
    //取139后8位转换为int类型  
    phoneNumAsInt = Integer.valueOf(phoneNum);   
    //设置对应bit值为1   
    bitArray.setBit(phoneNumAsInt, 1);   
}      
//遍历bit数组输出所有存在的号码  
for(int i = 0;i<sortUnit;i++){   
    if(bitArray.getBit(i)==1){   
        writer.write("139" + leftPad(String.valueOf(i + sortUnit*times), 8));   
        writer.newLine();                          
    }                  
}   
writer.flush();    
</pre>
经测试，修改后的算法排序时只需要20多M的内存，一亿条电话号码排序只要10分钟（时间主要花在IO上），看来效果还是很明显的。
 
这个算法很快，不过也有他的局限性： 
    
1. 只能用于整数的排序，或者可以准确映射到正整数（对象不同对应的正整数也不相同）的数据的排序。    
2. 不能处理重复的数据，重复的数据排序后只有一条（如果有这种需求可以在这个算法的基础上修改，给出现次数大于1的数据添加个计数器，然后存入Map中）   
3. 对于数据量极其大的数据处理可能还是比较占用空间，这种情况可配合多通道排序算法解决。
###多服务器共享 SESSION 的主要障碍及解决办法
PHP SESSION 的工作原理

在解决问题之前，先来了解一下 PHP SESSION 的工作原理。在客户端（如浏览器）登录网站时，被访问的 PHP 页面可以使用session_start() 打开 SESSION，这样就会产生客户端的唯一标识 SESSION ID（此 ID 可通过函数session_id() 获取/设置）SESSION ID 可以通过两种方式保留在客户端，使得请求不同的页面时，PHP程序可以获知客户端的 SESSION ID；

一种是将 SESSION ID 自动加入到 GET 的 URL 中，或者 POST的表单中，默认情况下，变量名为 PHPSESSID；

另一种是通过 COOKIE，将 SESSION ID 保存在 COOKIE中，默认情况下，这个 COOKIE 的名字为 PHPSESSID。这里我们主要以 COOKIE方式进行说明，因为应用比较广泛。

那么 SESSION 的数据保存在哪里呢？当然是在服务器端，但不是保存在内存中，而是保存在文件或数据库中。默认情况下，php.ini中设置的 SESSION 保存方式是 files（session.save_handler = files），即使用读写文件的方式保存SESSION 
数据，而SESSION 文件保存的目录由 session.save_path 指定，文件名以 sess_为前缀，后跟 SESSIONID，如：sess_c72665af28a8b14c0fe11afe3b59b51b。文 件中的数据即是序列化之后的 SESSION数据了。如果访问量大，可能产生的 SESSION 文件会比较多，这时可以设置分级目录进行 SESSION文件的保存，效率会提高很多，设置方法为：
session.save_path=”N;/save_path”，N为分级的级 数，save_path 为开始目录。写入 SESSION 数据的时候，PHP 会获取到客户端的SESSION_ID，然后根据这个 SESSION ID 到指定的 SESSION 文件保存目录中找到相应的 SESSION文件，不存在则创建之，最后将数据序列化之后写入文件。读取 SESSION数据是也是类似的操作流程，对读出来的数据需要进行解序列化，生成相应的 SESSION 变量。

通过了解 SESSION 的工作原理，我们可以发现，在默认情况下，各个服务器会各自分别对同一个客户端产生 SESSIONID，如对于同一个用户浏览器,A服务器产生的SESSION ID是30de1e9de3192ba6ce2992d27a1b6a0a，而B服务器生成的则是c72665af28a8b14c0fe11afe3b59b51b。另外，PHP 的 SESSION数据都是分别保存在本服务器的文件系统中。

确定了问题所在之后，就可以着手进行解决了。想要共享 SESSION 数据，那就必须实现两个目标：一个是各个服务器对同一个客户端产生的SESSION ID 必须相同，并且可通过同一个 COOKIE 进行传递，也就是说各个服务器必须可以读取同一个名为 PHPSESSID的 COOKIE；另一个是 SESSION 数据的存储方式/位置必须保证各个服务器都能够访问到。简单地说就是多服务器共享客户端的SESSION ID，同时还必须共享服务器端的 SESSION 数据。

第一个目标的实现其实很简单，只需要对 COOKIE 的域（domain）进行特殊地设置即可，默认情况下，COOKIE的域是当前服务器的域名/IP 地址，而域不同的话，各个服务器所设置的 COOKIE 是不能相互访问的，如 www.aaa.com的服务器是不能读写 www.bbb.com 服务器设置的 COOKIE的。这里我们所说的同一网站的服务器有其特殊性，那就是他们同属于同一个一级域，如：tieba.xiaoyuan.com 和www.xiaoyuan.com 都属于域.xiaoyuan.com，那么我们就可以设置 COOKIE 的域为.xiaoyuan.com，这样 tieba.xiaoyuan.com、www.xiaoyuan.com 等等都可以访问此COOKIE。PHP代码中的设置方法如下：
<pre>
<?php
ini_set('session.cookie_domain','.xiaoyuan.com');
</pre>
这样各个服务器共享同一客户端 SESSION ID 的目的就达到了。
第二个目标的实现可以使用文件共享方式，有2种方式可以解决,一是用数据库存session,还有就是试用memcache。这里用MEMCACHED来解决.
###分布式与集群的区别
分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。