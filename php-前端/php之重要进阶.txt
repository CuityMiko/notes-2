++++++php用Curl抓取远程图片/文件++++++++++
header('Contents-Type:text/html;charset=utf-8');  
$curl = curl_init();  
$a =  '<img src="http://p0.so.qhimg.com/sdr/200_200_/t013663df1bf55ce250.jpg"  /> ';  
if(!preg_match_all("/(href|src)=([\"|']?)([^\"'>]+\\.(gif|jpg|jpeg|bmp|png))\\2/i",$a,$result)) {  
    exit('没有匹配到图');  
}  
  // 设置你需要抓取的URL  
curl_setopt($curl, CURLOPT_URL, $result[3][0]);  
// 设置header  
curl_setopt($curl, CURLOPT_HEADER, 0);  
// 设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上。  
curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);  
//超时设置  
curl_setopt($curl, CURLOPT_TIMEOUT, 10);  
// 运行cURL，请求网页  
$filedata = curl_exec($curl);  
//如果curl没启用 就用原始的  
//$filedata = file_get_contents($result[3][0]);  
header('Content-Type: image/jpeg');  
//输出这个图片  
var_dump($filedata);
//本地保存  
file_put_contents('a.jpeg',$filedata); 


+++++++php高效过滤敏感词汇+++++++++
$badword = array(    
    '张三','张三丰','张三丰田'    
);    
$badword1 = array_combine($badword,array_fill(0,count($badword),'*'));    
$bb = '我今天开着张三丰田上班';    
$str = strtr($bb, $badword1);    
echo $str;  


++++++php查找字符串中的特定字符++++++++
$hei=array(    
'中国',    
'日本'    
);    
$blacklist="/".implode("|",$hei)."/i";    
$str="中国一是一个很好的国家";    
if(preg_match($blacklist, $str, $matches)){    
    print "found:". $matches[0];    
  } else {    
    print "not found.";    
  }    

  ++++++PHP计算URL的文件后缀名++++++
function getext($url){
    $data = parse_url($url);
    $path = $data['path'];
    $info = pathinfo($path);
    return $info['extension'];
}
echo getext('http://blog.phpha.com/archives/1670.html?id=1670');
//结果：'html'

+++++php输出从A到Z++++++
我本来以为下面这一种可以
for($i = 'A'; $i <= 'Z'; ++$i) {
    echo $i.'<br>';}
结果不是自己想要的，最后不得不考虑用他们的ascii码值，而这一种却可以。
如下：
for ($i = ord('A'); $i <= ord('Z'); ++$i)
{
    echo chr($i);
}

+++++php匹配中文+++++
$str = '中华人民共和国';
preg_match('/^[\x{4e00}-\x{9fa5}]+$/u',$str);

++++++php计算字符串表达式的值+++++
直接用eval()函数，并没有返回值或者保存变量。因为在退出eval后，该函数中的变量会保存其值，
但这种方法使用了两条语句，所有不可取。最好的方法是加上return,如下所示。
echo eval('return 1*2+3-4+67*4;');
结果为：269


++++++PHP生成一个可阅读随机字符串+++++++
function readable_random_string($length = 6){
    $conso=array("b","c","d","f","g","h","j","k","l",
    "m","n","p","r","s","t","v","w","x","y","z");    $vocal=array("a","e","i","o","u");
    $password="";
    srand ((double)microtime()*1000000);
    $max = $length/2;
    for($i=1; $i<=$max; $i++)
    {
    $password.=$conso[rand(0,19)];
    $password.=$vocal[rand(0,4)];
    }
    return $password;
}
var_dump(readable_random_string(7));
其中一个结果为：
string 'wopunu' (length=6)

++++PHP编码电子邮件地址++++++
使用此代码，可以将任何电子邮件地址编码为 html 字符实体，以防止被垃圾邮件程序收集。
function encode_email($email='info@domain.com', $linkText='Contact Us', $attrs ='class="emailencoder"' )
{
    $email = str_replace('@', '@', $email);
    $email = str_replace('.', '.', $email);
    $email = str_split($email, 5);  
    $linkText = str_replace('@', '@', $linkText);
    $linkText = str_replace('.', '.', $linkText);
    $linkText = str_split($linkText, 5);  
    $part1 = '<a href="ma';
    $part2 = 'ilto:';
    $part3 = '" '. $attrs .' >';
    $part4 = '</a>';  
    $encoded = '<script type="text/javascript">';
    $encoded .= "document.write('$part1');";
    $encoded .= "document.write('$part2');";
    foreach($email as $e)
    {
            $encoded .= "document.write('$e');";
    }
    $encoded .= "document.write('$part3');";
    foreach($linkText as $l)
    {
            $encoded .= "document.write('$l');";
    }
    $encoded .= "document.write('$part4');";
    $encoded .= '</script>';  
    return $encoded;
}
var_dump(encode_email('thff@dfgf.com','dbgdbd','grrg'));
结果为：
string '<script type="text/javascript">document.write('<a href="ma');document.write
('ilto:');document.write('thff@');document.write('dfgf.');document.write('com');
document.write('" grrg >');document.write('dbgdb');document.write('d');document.write('</a>');</script>' (length=2)

++++++php删除一个目录+++++++++++
删除一个目录，包括它的内容。
/*****
*@dir - Directory to destroy
*@virtual[optional]- whether a virtual directory
*/
function destroyDir($dir, $virtual = false)
{
    $ds = DIRECTORY_SEPARATOR;
    $dir = $virtual ? realpath($dir) : $dir;
    $dir = substr($dir, -1) == $ds ? substr($dir, 0, -1) : $dir;
    if (is_dir($dir) && $handle = opendir($dir))
    {
        while ($file = readdir($handle))
        {
            if ($file == '.' || $file == '..')
            {
             continue;
            }
            elseif (is_dir($dir.$ds.$file))
            {
                destroyDir($dir.$ds.$file);
            }
            else
            {
                unlink($dir.$ds.$file);
            }
        }
        closedir($handle);
        rmdir($dir);
        return true;
    }
    else
    {
        return false;
    }
}

++++++php解析XML+++++++++
$xml_string="<?xml version='1.0'?>
<users>
<user id='398'>
<name>Foo</name>
<email>foo@bar.com</name>
</user>
<user id='867'>
<name>Foobar</name>
<email>foobar@foo.com</name>
</user>
</users>"; 
//load the xml string using simplexml
$xml = simplexml_load_string($xml_string); 
//loop through the each node of user
foreach ($xml->user as $user)
{
    //access attribute
    echo $user['id'], ' ';
    //subnodes are accessed by -> operator
    echo $user->name, ' ';
    echo $user->email, '<br />';
}

++++++PHP创建日志缩略名++++++
创建用户友好的日志缩略名
function create_slug($string){
    $slug=preg_replace('/[^A-Za-z0-9-]+/', '-', $string);
    return $slug;
}

++++++++ PHP获取客户端真实 IP 地址++++++++++
该函数将获取用户的真实 IP 地址，即便他使用代理服务器。
function getRealIpAddr()
{
    if (!emptyempty($_SERVER['HTTP_CLIENT_IP']))
    {
        $ip=$_SERVER['HTTP_CLIENT_IP'];
    }
    elseif (!emptyempty($_SERVER['HTTP_X_FORWARDED_FOR']))
    //to check ip is pass from proxy
    {
        $ip=$_SERVER['HTTP_X_FORWARDED_FOR'];
    }
    else
    {
        $ip=$_SERVER['REMOTE_ADDR'];
    }
    return $ip;
}

+++++++PHP强制性文件下载++++++++
为用户提供强制性的文件下载功能
function force_download($file)
{
    if ((isset($file))&&(file_exists($file))) {
        header("Content-length: ".filesize($file));
        header('Content-Type: application/octet-stream');
        header('Content-Disposition: attachment; filename="' . $file . '"');
        readfile("$file");
    }
    else {
        echo "No file selected";
    }
}

+++++PHP创建标签云+++++++
function getCloud( $data = array(), $minFontSize = 12, $maxFontSize = 30 )
{
    $minimumCount = min( array_values( $data ) );
    $maximumCount = max( array_values( $data ) );
    $spread = $maximumCount - $minimumCount;
    $cloudHTML = '';
    $cloudTags = array(); 
    $spread == 0 && $spread = 1; 
    foreach( $data as $tag => $count )
    {
        $size = $minFontSize + ( $count - $minimumCount )
        * ( $maxFontSize - $minFontSize ) / $spread;
       $cloudTags[] = '<a style="font-size: ' . floor( $size ) . 'px'
        . '" href="#" title="\'' . $tag .
        '\' returned a count of ' . $count . '">'
        . htmlspecialchars( stripslashes( $tag ) ) . '</a>';
    } 
    return join( "\n", $cloudTags ) . "\n";
}
$arr = Array('Actionscript' => 35, 'Adobe' => 22, 'Array' => 44, 'Background' => 43,
'Blur' => 18, 'Canvas' => 33, 'Class' => 15, 'Color Palette' => 11, 'Crop' => 42,
'Delimiter' => 13, 'Depth' => 34, 'Design' => 8, 'Encode' => 12, 'Encryption' => 30,
'Extract' => 28, 'Filters' => 42);
echo getCloud($arr, 12, 36);

+++++PHP为URL地址预设 http字符串++++++++
有时需要接受一些表单中的网址输入，但用户很少添加 http:// 字段，此代码将为网址添加该字段。
if (!preg_match("/^(http|ftp):/", $_POST['url'])) {
   $_POST['url'] = 'http://'.$_POST['url'];
   } 

++++++++PHP将网址字符串转换成超级链接+++++++++
该函数将 URL 和 E-mail 地址字符串转换为可点击的超级链接。
function makeClickableLinks($text) {
	    $text = eregi_replace('(((f|ht){1}tp://)[-a-zA-Z0-9@:%_+.~#?&//=]+)',
	    '<a href="\1">\1</a>', $text);
	    $text = eregi_replace('([[:space:]()[{}])(www.[-a-zA-Z0-9@:%_+.~#?&//=]+)',
	    '\1<a href="http://\2">\2</a>', $text);
	    $text = eregi_replace('([_.0-9a-z-]+@([0-9a-z][0-9a-z-]+.)+[a-z]{2,3})',
	    '<a href="mailto:\1">\1</a>', $text); 
	    return $text;
} 

++++++PHP调整图像尺寸++++++
创建图像缩略图需要许多时间，此代码将有助于了解缩略图的逻辑。
function resize_image($filename, $tmpname, $xmax, $ymax)
	{
	    $ext = explode(".", $filename);
	    $ext = $ext[count($ext)-1];  
	    if($ext == "jpg" || $ext == "jpeg")
	        $im = imagecreatefromjpeg($tmpname);
	    elseif($ext == "png")
	        $im = imagecreatefrompng($tmpname);
	    elseif($ext == "gif")
	        $im = imagecreatefromgif($tmpname); 
	    $x = imagesx($im);
	    $y = imagesy($im);   
	    if($x <= $xmax && $y <= $ymax)
	        return $im;  
	    if($x >= $y) {
	        $newx = $xmax;
	        $newy = $newx * $y / $x;
	    }
	    else {
	        $newy = $ymax;
	        $newx = $x / $y * $newy;
	    }  
	  
	    $im2 = imagecreatetruecolor($newx, $newy);
	    imagecopyresized($im2, $im, 0, 0, 0, 0, floor($newx), floor($newy), $x, $y);
	    return $im2;
	} 





+++++++用php访问http与https的转换+++++++
http直接跳转为https，重定向一下就可以了。
<?php
	header("Location:https://www.nowamagic.com");
?>
当访问 http 时，跳 https：
<?php
//http转化为https   
if ($_SERVER["HTTPS"] <> "on")
{
	$xredir="https://".$_SERVER["SERVER_NAME"].$_SERVER["REQUEST_URI"];
	header("Location: ".$xredir);
}
?>  
当访问 https 时，跳 http：
<?php
//https转化为http   
if ($_SERVER["HTTPS"] == "on")  
{  
	$xredir="http://".$_SERVER["SERVER_NAME"]. $_SERVER["REQUEST_URI"];  
	header("Location: ".$xredir);  
}   
?>
在网页开头包含上面代码即可。

+++++php截取GB2312中文字符串++++++++
function mysubstr($str, $start, $len) {
    $tmpstr = "";
    $strlen = $start + $len;
    for($i = 0; $i < $strlen; $i++) {
        if(ord(substr($str, $i, 1)) > 0xa0) {
            $tmpstr .= substr($str, $i, 2);
            $i++;
        } else
            $tmpstr .= substr($str, $i, 1);
    }
    return $tmpstr;
}

+++++++PHP“相关文章推荐”功能的简易实现+++++++++++
$demo_title = "简明现代魔法";
$demo_arr_title = array("简单易懂的现代魔法","简单明了的现代魔法","简明扼要的古代魔法","不简单的现代魔法","很难懂的现代魔法");
$new_array = getSimilar($demo_title,$demo_arr_title);
//print_r($new_array);
echo "与[$demo_title]最相关的前三个文章是：<br/>";
for($j=0; $j<=2; $j++)
{ 
	echo ($j+1).":".$new_array[$j]."<br/>";
}
//$title当前标题，$arrayTitle为需要查找的数组
function getSimilar($title,$arr_title)
{
	$arr_len = count($arr_title);
	for($i=0; $i<=($arr_len-1); $i++)
	{
		//取得两个字符串相似的字节数
		$arr_similar[$i] = similar_text($arr_title[$i],$title);
	}
	arsort($arr_similar);	//按照相似的字节数由高到低排序
	reset($arr_similar);	//将指针移到数组的第一单元
	$index = 0;
	foreach($arr_similar as $old_index=>$similar)
	{
		$new_title_array[$index] = $arr_title[$old_index];
		$index++;
	}
	return $new_title_array;
}
运行结果是：
与[简明现代魔法]最相关的前三个文章是：
1:简单明了的现代魔法
2:简单易懂的现代魔法
3:简明扼要的古代魔法

+++++++php分拆数组元素的函数效率比较与分析++++++++
有这么一个需求，一个数组$data = array(12, 43, 87, 45)，要求写一个自定义函数，
将其数组元素的数字单个拆开，最后形成的数组如下：$data = array(1, 2, 4, 3, 8, 7, 4, 5)。
答案一：
function splitStrToArray_mine($array)
{
	$new_array = array();
	foreach($array as $value)
	{
		$value = (string)$value;
		$len = strlen($value);
		for($i = 0; $i < $len; $i ++){
			array_push($new_array, $value{$i});
		}
	}
	return $new_array;
}
或者是这一种
答案二：
function splitStrToArray($array)
{
	return str_split(implode("", $array));
}

++++php判断数组中存不存在大于或者小于或者等于某个值的一项+++++++
$arr=array(1,45,6,67,57,5,45,64,99,66,666);
foreach($arr as $k=>$v){
	if($v>=100){
		$dd='存在';
		break;
	}
}
$dd=empty($dd)?'无内容':$dd;
echo $dd;



+++++++++PHP发送邮件+++++++++
PHP发送邮件的小程序很简单，不过有些需要注意的地方。先上代码：
<?php    
    $to = "gonnsai@163.com";  
	$user = "Gonn";
	$date = date("Y年m月d日");
	
	$headers  = 'MIME-Version: 1.0' . "rn";
	$headers .= 'Content-type: text/html; charset=utf-8' . "rn";
	$headers .= "To: $to rn"; 
	$headers .= "Cc: 252211974@qq.com rn"; 
	$headers .= 'From: gonnsai@163.com' . "rn";
    $subject = "珠海生活圈";  
	$subject = "=?UTF-8?B?".base64_encode($subject)."?=";
 
    $content = '亲爱的'."$user".'：'.'<br />';  
	$content .= '<br />';  
	$content .= "感谢您注册珠海生活圈，精彩的生活从珠海生活圈开始！".'<br />';  
    $content .= "在珠海生活圈，您可以：".'<br />';  
	$content .= "查询珠海的商家情况，方便您生活与娱乐。".'<br />';  
	$content .= "了解最近珠海举行的活动，让您的生活更加丰富。".'<br />';  
	$content .= "浏览新闻热点，扩展知识面。".'<br />';  
	$content .= '<br />';  
	$content .= "珠海生活圈 -- 为建成珠海最大的商家数据库而不断努力着。 ".'<a href="http://www.zhuhailife.net" target="_blank">www.zhuhailife.net</a>'.'<br />'; 
	$content .= '<br />';  
	$content .= "珠海生活圈团队".'<br />'; 
	$content .= "$date".'<br />';  
    $result = mail($to, $subject, $content, $headers);  
	
	if($result)
	{
		echo '邮件发送成功！';
	}
	
?>  


+++++php通过json传值给前端，javascript接收++++++++
json.php内容是：
<?php
$arr=array(
'name'=>'Bob','nick'=>'Yes',
'contact'=>array(
	'email'=>'json@admin.com',
	'tel'=>'12323314567',
     )
);
$json_string=json_encode($arr);
echo "getProfile($json_string)";
?>
html内容是：
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
</head>
<script type="text/javascript">  
	function getProfile(str){
	var arr=str;
	document.getElementById('name').innerHTML=arr.name;
	document.getElementById('nick').innerHTML=arr.nick;
	document.getElementById('email').innerHTML=arr.contact.email;
	document.getElementById('tel').innerHTML=arr.contact.tel;
	
}
</script>
<body>
<h2>
测试json
</h2>
<div id="name"></div>
<div id="nick"></div>
<div id="email"></div>
<div id="tel"></div>
</body>
<script type="text/javascript" src="json.php"></script>   <!--我擦，这个引用js还只能放在这个位置，也是醉了-->
</html>


+++++++前端javascript通过json传值给php++++++++
JavaScript 向 PHP 传值
json_encode.html

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>json:From javascript To php</title>
<script src="json2.js" type="text/javascript"></script>
<script type="text/javascript">
function JSON_test(o)
{
    var user = {
        name:document.getElementById('txt_name').value,
        email:document.getElementById('txt_email').value,
        password:document.getElementById('txt_password').value
    }
    var json_string = JSON.stringify(user);
    document.getElementById('txt_json').value=json_string;
    alert("点击确定后将提交表单");
    o.submit();
}
</script>
</head>
<body>
    <form id="form1" name="form1" method="post" action="json_encode.php" onsubmit="JSON_test(this);return flase;">
        <label for="txt_name">姓名</label>
        <p><input type="text" name="txt_name" id="txt_name" /></p>
        <label for="txt_email">邮箱</label>
        <p><input type="text" name="txt_email" id="txt_email" /></p>
        <p><label for="txt_password">密码</label></p>
        <p><input type="text" name="txt_password" id="txt_password" /></p>
        <p><input type="text" name="txt_json" id="txt_json" />
            <label for="button"></label>
            <input type="submit" name="button" id="button" value="JSON" />
        </p>
    </form>
</body>
</html>
这里javascript扁平化需要一个插件：http://www.json.org/json2.js，通过JSON.stringify(str)将对象扁平化然后传送给php。
注：另有一个http://www.json.org/json.js，对应的是toJSONString方法。
var last=obj.toJSONString(); //针对json.js
var last=JSON.stringify(obj); //针对json2.js
json_encode.php
<?php
    header('Content-Type: text/html; charset=utf-8');
    $json_string = $_POST["txt_json"];
    //echo $json_string;
    if(ini_get("magic_quotes_gpc")=="1")
    {
        $json_string=stripslashes($json_string);
    }
    $user = json_decode($json_string);
    echo var_dump($user);
    echo '<br /><br /><br /><br />';
    echo $user->name.'<br />';
    echo $user->email.'<br />';
    echo $user->password.'<br />';
?>
这里就需要用到json_decode()这个函数，然后调用其中数据用 $obj->属性即可。


++++++php检验是不是win32平台++++++++++++
$is_win = DIRECTORY_SEPARATOR == '\\';
echo 一下，如果是win32平台就会输出1；


++++++PHP返回insert操作产生的id+++++++
<?php
$con = mysql_connect("localhost", "hello", "321");
if (!$con)
{
    die('Could not connect: ' . mysql_error());
}
$db_selected = mysql_select_db("test_db",$con);
$sql = "INSERT INTO person VALUES ('Carter','Thomas','Beijing')";
$result = mysql_query($sql,$con);
echo "ID of last inserted record is: " . mysql_insert_id();
mysql_close($con);
?>

++++++++简单的PHP伪缓存并定时抓取某页面内容++++++++++++
需求：要抓取某个页面的一部分内容，然后iframe到别的页面去。
iframe的时候，不需求每次都访问源页面，而是每天只读取源页面一次，
并生成文件，iframe的时候只访问该暂时文件，也就是伪缓存啦。这么做适合访问量不大的页面
，降低数据库访问压力。
<?php
function get_page_content()
{
	$url = "http://www.nowamagic.net/";
	$contents = file_get_contents($url);
	//如果出现中文乱码使用下面代码
	//$getcontent = iconv("gb2312″, "utf-8″,$contents);
	//echo $contents;
	//$pos = strstr($contents, '<div class="hot_news">');
	//print_r($pos);
	$array = explode('<div class="hot_news">', $contents);
	$htmlarray = explode('<div class="car_tab border4">', $array[0]); // HTML部分
	$cssarray = explode('<div class="hometop">', $htmlarray[0]);
	$css_rem_inner = explode('<!--[if !IE]>导航<![endif]-->', $cssarray[0]);
	$css_min = explode('<script type="text/javascript" src="http://www.nowamagic.net/ad_comm_t.js">', $css_rem_inner[0]);
	$str_css = $css_min[0];
	$head = '<base target="_blank"></base></head> ';
	$str_1 = '<div class="car_tab border4">';
	$str_html = $htmlarray[1]; 
	$content = $str_css.$head.$str_1.$str_html;
	return $content;
}
$cache_file = "tmp.html";
$cache_time = 60*60*24;
/**
ob_start();
echo $content;
file_put_contents($cacheFile,ob_get_contents());
ob_end_flush();
**/
echo date("Y-m-d H:i:s", time());
echo '<br />';
echo date("Y-m-d H:i:s", floor(@filemtime($cache_file)));
if(time() - $cache_time > floor(@filemtime($cache_file)) )
{
	$content = get_page_content();
	file_put_contents($cacheFile, $content);
	header('Location: http://www.nowamagic.net/tmp.html');
}
else
{
	header('Location: http://www.nowamagic.net/tmp.html');
}
?>


++++++++gmdate()函数统一时间问题++++++++++++
echo gmdate('Y-m-d H:i:s', time() + 3600 * 8);
这样不管在Linux+Apache下还是Windows下都得到了正确的结果，当然这样写还有一个好处，
当网站是面向全世界的时候，那么网站用户只要设置所在的时区，程序自动根据用户设置的时区
进行时间计算，数据库中信息发布时间只存当前的time()所生成的时间，那么在中国+8时区看到的
发布时间是：2007-03-14 12:15:27，那么在欧洲+2时区用户看到这个信息的发布时间是：
2007-03-14 06:15:27，这样信息的时间就全部对应正确了。


+++++++PHP用strstr()函数阻止垃圾评论+++++++
strstr()函数简单演示
<?php
2
echo strstr("Hello NowaMagic!", "NowaMagic");
3
?>
程序运行结果：
NowaMagic!
则阻止垃圾评论的代码为：
<?php
$content = $_POST['content'];
$garbage = strstr($content, "<a");
if($garbage == false)
{
    //评论正常插入数据库
}
else
{
    echo "<script>alert('你的评论不能带有链接'); history.go(-1);</script>";
}
?>


++++++商品秒杀计时的PHP实现+++++++
注：秒杀时间从早上点到晚上10点。
<?php
//php的时间是以秒算。js的时间以毫秒算
date_default_timezone_set('PRC');  
//date_default_timezone_set("Asia/Hong_Kong");//地区
//配置每天的活动时间段
$starttimestr = "08:00:00";
$endtimestr = "22:00:00";
$starttime = strtotime($starttimestr);
$endtime = strtotime($endtimestr);
$nowtime = time();
if ($nowtime<$starttime){
die("活动还没开始,活动时间是：{$starttimestr}至{$endtimestr}");
}
$lefttime = $endtime-$nowtime; //实际剩下的时间（秒）
?>
<script language="JavaScript">
<!-- //
var runtimes = 0;
function GetRTime(){
var nMS = <?=$lefttime?>*1000-runtimes*1000;
var nH=Math.floor(nMS/(1000*60*60))%24;
var nM=Math.floor(nMS/(1000*60)) % 60;
var nS=Math.floor(nMS/1000) % 60;
document.getElementById("RemainH").innerHTML=nH;
document.getElementById("RemainM").innerHTML=nM;
document.getElementById("RemainS").innerHTML=nS;
if(nMS>5*59*1000&&nMS<=5*60*1000)
{
alert("还有最后五分钟！");
}
runtimes++;
setTimeout("GetRTime()",1000);
}
window.onload=GetRTime;
// -->
</script>
<h4><strong id="RemainH">XX</strong>:<strong id="RemainM">XX</strong>:<strong id="RemainS">XX</h4>

+++++php生成随机时间日期的两种方法++++++++
可以自定义时间段。
1---》
function rand_time($a,$b)
{
$a=strtotime($a);
$b=strtotime($b);
return date( "Y-m-d H:m:s", mt_rand($a,$b));
}
$date1="2014-07-26 09:03:01";
$date2="2014-10-26 18:21:32";
$num = 15;
$i=0;
while ($i < $num){
 $date = rand_time($date1,$date2);
 $datea[]= $date;
 $i++;
}
sort($datea);
foreach ($datea as $values)
{
echo $values."<br>";
}
2---》
/**
 *   生成某个范围内的随机时间
 * @param <type> $begintime  起始时间 格式为 Y-m-d H:i:s
 * @param <type> $endtime    结束时间 格式为 Y-m-d H:i:s  
 */
function randomDate($begintime, $endtime="") {
    $begin = strtotime($begintime);
    $end = $endtime == "" ? mktime() : strtotime($endtime);
    $timestamp = rand($begin, $end);
    return date("Y-m-d H:i:s", $timestamp);
}
for($i = 0; $i <= 20; $i++){
echo randomDate("2014-06-27 09:03:01","2014-06-27 18:21:32");echo "<br />";
}





+++++++PHP截取中英混合的字符串++++++++++
function get_word($string, $length, $dot = '..',$charset='gbk') {
    if(strlen($string) <= $length) {
        return $string;
    }
    $string = str_replace(array('　',' ', '&', '"', '<', '>'), array('','','&', '"', '<', '>'), $string);
    $strcut = '';
    if(strtolower($charset) == 'utf-8') {
        $n = $tn = $noc = 0;
        while($n < strlen($string)) {
            $t = ord($string[$n]);
            if($t == 9 || $t == 10 || (32 <= $t && $t <= 126)) {
                $tn = 1; $n++; $noc++;
            } elseif(194 <= $t && $t <= 223) {
                $tn = 2; $n += 2; $noc += 2;
            } elseif(224 <= $t && $t < 239) {
                $tn = 3; $n += 3; $noc += 2;
            } elseif(240 <= $t && $t <= 247) {
                $tn = 4; $n += 4; $noc += 2;
            } elseif(248 <= $t && $t <= 251) {
                $tn = 5; $n += 5; $noc += 2;
            } elseif($t == 252 || $t == 253) {
                $tn = 6; $n += 6; $noc += 2;
            } else {
                $n++;
            }
            if($noc >= $length) {
                break;
           }
        }
        if($noc > $length) {
            $n -= $tn;
        }
        $strcut = substr($string, 0, $n);
    } else {
        for($i = 0; $i < $length; $i++) {
            $strcut .= ord($string[$i]) > 127 ? $string[$i].$string[++$i] : $string[$i];
        }
    }
    return $strcut.$dot;
}
$str = "欢迎 visit 简明 nowamagic";
$str_result = get_word($str, 12);
echo $str_result;


++++++4个数字得出24的方法+++++++
传说中的24点的游戏：
<?php
set_time_limit(0);
$values = array(5, 5, 5, 1);
$result = 24;
$list = array();
echo "<pre>";
makeValue($values);
print_r($list);
function makeValue($values, $set=array())
{
    $words = array("+", "-", "*", "/");
    if(sizeof($values)==1)
    {
        $set[] = array_shift($values);
        return makeSpecial($set);
    }
    foreach($values as $key=>$value)
    {
        $tmpValues = $values;
        unset($tmpValues[$key]);
        foreach($words as $word)
        {
            makeValue($tmpValues, array_merge($set, array($value, $word)));
        }
    }
}
function makeSpecial($set)
{
    $size = sizeof($set);
    if($size<=3 || !in_array("/", $set) && !in_array("*", $set))
    {
        return makeResult($set);
    }
    for($len=3; $len<$size-1; $len+=2)
    {
        for($start=0; $start<$size-1; $start+=2)
      {         
            if(!($set[$start-1]=="*" || $set[$start-1]=="/" || $set[$start+$len]=="*" || $set[$start+$len]=="/"))
                continue;
            $subSet = array_slice($set, $start, $len);
            if(!in_array("+", $subSet) && !in_array("-", $subSet))
                continue;
            $tmpSet = $set;
            array_splice($tmpSet, $start, $len-1);
            $tmpSet[$start] = "(".implode("", $subSet).")";
            makeSpecial($tmpSet);
        }
    }
}
function makeResult($set)
{
    global $result, $list;
    $str = implode("", $set);
    @eval("$num=$str;");
    if($num==$result && !in_array($str, $list))
    $list[] = $str;
}
?>

+++++++++PHP将微博短地址还原为实际网址+++++++++
$url = "http://163.fm/1QLJ8U";
echo unshorten($url);
function unshorten($url)
{
    $url = trim($url);
    $headers = get_headers($url);
    $location = $url;
    $short = false;
    foreach($headers as $head)
    {
        if($head=="HTTP/1.1 302 Found")
            $short = true;
        if($short && startwith($head,"Location: "))
        {
            $location = substr($head,10);
        }
    }
    return $location;
}
function startwith($Haystack, $Needle)
{
    return strpos($Haystack, $Needle) === 0;
}
自己测试一下。


++++++++++一主三从服务器课堂笔记总结++++++++++
2014年03月05日 ⁄ PHP, 数据库, 编程开发 ⁄ 共 3074字	⁄ 字号 小 中 大 ⁄ 暂无评论
data_user_0
data_user_1
data_user_2
data_user_3
.....
data_user_9
data_user_10
d_product_bj
d_product_tj
d_produtc_ts
md5($id)
得到32位字符串
取得32位字符串最后2位
2位字符串转换为10进制数值
唯一一个id经过我们的计算可以得到唯一的数值
数值对我们分表的张数取模
数据库主从配置
开启远程连接
grant all privileges on *.* to 'migrate'@'%' identified by 'migrate';
防火墙
(1) 确定自己想给这两个 MySQL 服务器分配什么样的 ID 值并把它们记录到 MySL 服务器在启动 时会去读取的某个选项文件里。主从服务器的 ID 值应该是 1 到 232?1 之间的一个正整数并且必须彼此 不同。在启动主、从服务器的时候,你必须用 server_id 启动选项给出其 ID 值。在此基础上,一定 要启用主服务器上的二进制日志功能——如果以前没有启用过它。要想在主、从服务器上启用二进制 日志,最省心的办法是在相应的选项组里加上如下所示的代码:
[mysqld] server-id=master_server_id log-bin=binlog_name
[mysqld] server-id=slave_server_id
重新启动两个服务器,让改动生效。
(2) 在主服务器上,创建一个账户供从服务器连接主服务器并请求修改信息:
CREATE USER 'slave_user'@'slave_host' IDENTIFIED BY 'slave_pass'; GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'slave_host';
请记住 slave_user 和 slave_pass 值,因为稍后还需要使用它们来告诉从服务器如何连接主服 务器。如果这个账户的用途只用于复制,就用不着再向它授予任何其他的权限了。不过,为了对复制 机制进行测试,你通常要在从服务器上用 mysql 程序以“手动方式”去连接主服务器,所以你往往还 应该再给这个账户多授予几项权限以方便自己能够多做一些事情。(比如说,如果这个账户仅有 REPLICATION SLAVE 权限的话,你甚至无法在从服务器上使用 SHOW DATABASES 语句去查看主服务 器上的数据库名称。)
(3) 连接到主服务器并通过执行 SHOW MASTER STATUS 语句确定当前的复制坐标:
mysql> FLUSH TABLES; SHOW MASTER STATUS;
请记住 File 和 Position 值,因为稍后还需要使用它们来告诉从服务器从哪个位置开始去读取 主服务器的二进制日志里的事件。
重要注意事项 在主服务器上,在从确定其复制坐标到制作出将被传输到从服务器的初始复制的这 段时间里,一定要保证主服务器上的数据库里的数据没有发生任何修改。
(4) 在从服务器上为将被复制的数据库建立一份完备的副本。把主服务器上的数据库复制到从服 务器以完成主、从服务器之间最初的同步。一种办法是先在主服务器主机上制作一份备份,再把这个 备份加载到从服务器上去;另一种办法是通过网络把各数据库从主服务器全部复制到从服务器。对数据库备份技术和复制技术的讨论见本章的其他小节。 如果你还没有在主服务器上创建过任何数据库或数据表,可以省略这一步,因为它现在还没有任何需要复制的东西。
(5) 连接到从服务器并使用 CHANGE MASTER 语句来配置它,这包括把用来连接主服务器的参数和
初始复制坐标告诉从服务器:
CHANGE MASTER TO
MASTER_HOST = 'master_host', MASTER_USER = 'slave_user', MASTER_PASSWORD = 'slave_pass', MASTER_LOG_FILE = 'log_file_name', MASTER_LOG_POS = log_file_pos;
'master_host'是主服务器的主机名。'slave_user'和'slave_pass'值是刚才在主服务器创建 的那个账户的用户名和口令,从服务器将使用这个账户来连接主服务器并请求主服务器修改信息。 'log_file_name'和'log_file_pos'是刚才用 SHOW MASTER STATUS 语句查出来的值。
在 Unix 系统上,使用 localhost 作为主机名将使用一个套接字文件去连接主服务器,但复制机 制不支持经套接字文件建立的连接。因此,如果主服务器和从服务器将运行在同一台主机上,就必须 把这个主机名写成 127.0.0.1 而不是 localhost,这样才能确保从服务器将使用 TCP/IP 连接。
如果主服务器所监听的网络端口不是默认端口,可以在 CHANGE 语句里包括一个 MASTER_PORT 选 项以明确地给出一个端口号。
(6) 让从服务器开始复制。
START SLAVE;
从服务器将连接主服务器并开始复制。你可以在从服务器上使用 SHOW SALVE STATUS 语句来查 看它的工作状态。
从服务器把 CHANGE MASTER 语句所给出的参数保存在其数据目录中的一个名为 master.info 的 文件里以记录初始复制状态,并随着镜象工作的进展而刷新那个文件。等以后需要改变复制参数的时 候,只要连接到从服务器并通过 CHANGE MASTER 语句给出新的设置,从服务器就会根据新的设置自 动刷新 master.info 文件。
保存在 master.info 文件里的信息包括用来连接主服务器的用户名和口令。这些信息应该是保 密的,所以应该把这个文件设置为只允许从服务器上的 MySQL 管理员的登录账户才能访问。
可以把 mysql 数据库排除在复制机制外,这需要做两件事情。
(1) 在把数据库的初始数据从主服务器传输到从服务器的时候,不要把 mysql 数据库也包括在 内。另一个办法是在传输之前先备份从服务器的 mysql 数据库,等传输工作完成后再恢复它。
(2) 在从服务器的选项文件里加上以下代码,让它不要执行来自主服务器的对 mysql 数据库的任 何修改:
[mysqld]
replicate-ignore-db=mysql
如果想让从服务器忽略多个数据库,需要多次使用 replication_ignore_db 选项——每个数据
库一次。
还有一个办法是在主服务器端(注意,不是从服务器端)使用--binlog-ignore-db 选项排除数
据库。这个办法的优点是可以减少从主服务器传输到从服务器的信息量,缺点是主服务器上的二进制
日志文件将不包含那些被排除在外的数据库的任何信息,而这些信息对主服务器在发生崩溃后的数据
恢复工作往往至关重要。因此,在从服务器端把数据库排除在外的做法更值得选择。
重要命令
SHOW SLAVE STATUS语句。在从服务器上查看其复制机制是否在工作以及当前的复制坐标。
复制坐标可以用来判断主服务器上的哪几个二进制日志文件已经不再会被用到了。
PURGE MASTER语句。在主服务器上对二进制日志文件进行失效处理。在每一个从服务器上都
通过SHOW SLAVE STATUS语句确定了哪些日志文件不会再用之后,你可以在主服务器上用这
条语句把那些二进制日志文件删除掉。
STOP SLAVE和START SLAVE语句。用来挂起和重新开始从服务器上的复制活动。比如说,当
你制作备份时,可以用这些语句让从服务器暂时停止复制活动。
可以通过在 SLAVE STOP 或 SLAVE START 语句的末尾加上 IO_THREAD
或 SQL_THREAD 关键字的办法分别挂起或者重新开始这两个线程中的任何一个。

+++++++++验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间：+++++++++
<?php 
$str = 'a1234'; 
if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) { 
echo "验证成功";} else { 
echo "验证失敗";}?>


+++++++++php获取页面中的所有链接地址：（以www.93jiang,com为例）+++++++++
$str=file_get_contents('http://www.93jiang.com');
  preg_match_all('/<a .*?href="(.*?)".*?>/is',$str,$arrat);
  foreach($arrat[0] as $key=>$value){
  echo $key.'-------'.htmlspecialchars($value).'<br>';
  }

+++++++++php取出网页中所有图片链接+++++++++
   preg_match_all("/<img([^>]*)\s*src=('|\")([^'\"]+)('|\")/",$str,$aarr);
   var_dump($aarr[0]);

+++++++++php取出网页中所有邮箱++++++
preg_match_all("/([a-z0-9\-_\.]+@[a-z0-9]+\.[a-z0-9\-_\.]+)/",$str,$mail);
   var_dump($mail);

+++++++顺序查找算法（数组里查找某个元素）++++++++
function seq_sch($array,$n,$k)//在某个位置之前查找某元素(不包括指定位置)
{
$array[$n]=$k;
for($i=0;$i<$n;$i++)
{
if($array[$i]==$k)
break;
}
if($i<$n)
return $i;
else
return -1;
}
$array=array(‘a’,'b’,'c’);
echo seq_sch($array,2,’b');
?>


+++++++++二分查找-递归+++++++++
function bin_search($arr,$low,$high,$value) {
    if($low>$high)
        return false;
    else {
        $mid=floor(($low+$high)/2);
        if($value==$arr[$mid])
            return $mid;
        elseif($value<$arr[$mid])
            return bin_search($arr,$low,$mid-1,$value);
        else
            return bin_search($arr,$mid+1,$high,$value);
    }
}

+++++++++二分查找-非递归+++++++++
function bin_search($arr,$low,$high,$value) {
    while($low<=$high) {
        $mid=floor(($low+$high)/2);
        if($value==$arr[$mid])
            return $mid;
        elseif($value<$arr[$mid])
            $high=$mid-1;
        else
            $low=$mid+1;
    }
    return false;
}

+++++++++归并排序+++++++++
function Merge(&$arr, $left, $mid, $right) {
  $i = $left;
  $j = $mid + 1;
  $k = 0;
  $temp = array();
  while ($i <= $mid && $j <= $right)
  {
    if ($arr[$i] <= $arr[$j])
      $temp[$k++] = $arr[$i++];
    else
      $temp[$k++] = $arr[$j++];
  }
  while ($i <= $mid)
    $temp[$k++] = $arr[$i++];
  while ($j <= $right)
    $temp[$k++] = $arr[$j++];
  for ($i = $left, $j = 0; $i <= $right; $i++, $j++)
    $arr[$i] = $temp[$j];
}
 
function MergeSort(&$arr, $left, $right)
{
  if ($left < $right)
  {
    $mid = floor(($left + $right) / 2);
    MergeSort($arr, $left, $mid);
    MergeSort($arr, $mid + 1, $right);
    Merge($arr, $left, $mid, $right);
  }
}

++++++++++PHP实现等差数列求和(不使用乘法,循环,递归) ++++++++++
<html>
     <body>
         <?php
            function sum_n($a1, $d, $an) {    //$a1为首项,$d为公差,$an为最大项
                $sum = 0;
                $i = $a1;
                a:
                $sum += $i;
                $i += $d;
                if($i <= $an) goto a;
                return $sum;
            }
            
            echo sum_n(1, 1, 10);
         ?>
     </body>
 </html>


++++++++++php冒泡排序++++++++++
原理：
依次比较相邻的两个数，将小数放在前面，大数放在后面。即首先比较第1个和第2个数，
将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
直至比较最后两个数，将小数放前，大数放后。重复以上过程，仍从第一对数开始比较
（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，
大数放后，一直比较到最大数前的一对相邻数，将小数放前，大数放后，第二趟结束，
在倒数第二个数中得到一个新的最大数。如此下去，直至最终完成排序。
在许多程序设计中，我们需要将一个数列进行排序，以方便统计，常见的排序方法有冒泡排序，
二叉树排序，选择排序等等。而冒泡排序一直由于其简洁的思想方法和比较高的效率而倍受青睐。
由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。
function bubble_sort($array)  
{  
    $count = count($array);  
    if($count <= 0)  
    {  
        return false;  
    }  
    for($i=0; $i<$count; $i++)  
    {  
        for($k=$count-1; $k>$i; $k--)  
        {  
            if($array[$k] < $array[$k-1])  
            {  
                $tmp = $array[$k];  
                $array[$k] = $array[$k-1];  
                $array[$k-1] = $tmp;  
            }  
        }  
    }  
    return $array;  
}  
冒泡原理：两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。

++++++php快排算法++++++
function quick_sort($arr){
	$length=count($arr);
	if($length<=1){
		return $arr;
	}
	$base_num=$arr[0];
        //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内，初始化两个数组
	$left_array=array();   //这是小于标准的
	$right_array=array();  //这是大于标准的
	for($i=1;$i<$length;$i++){
		if($base_num>$arr[$i]){
				$left_array[]=$arr[$i];//放入左边数组
			}
			else{
       			     $right_array[]=$arr[$i];  //放入右边数组
				}
	}
  //再分别对左边和右边的数组进行相同的排序处理方式
  //递归调用这个函数,并记录结果
  $left_array=quick_sort($left_array);
  $right_array=quick_sort($right_array);
  //合并左边标尺右边
  return array_merge($left_array,array($base_num),$right_array);
}

++++++插入排序算法++++++
function insert_sort($arr){
 for($i=1,$len=count($arr);$i<$len;$i++){
      $tmp=$arr[$i];
      for($j=$i-1;$j>=0;$j--){
           if($tmp<$arr[$j])  {
                $arr[$j+1]=$arr[$j];
                 $arr[$j]=$tmp;
           }
         else{
              break;
              }
      }
  }
return $arr;
}


++++++二叉树排序算法++++++
    <?php
     //二叉树的广度优先遍历
     //使用一个队列实现
  
       class Node {
         public $data = null;
         public $left = null;
         public $right = null;
      }
  
      //@param $btree 二叉树根节点
      function breadth_first_traverse($btree) {
          $traverse_data = array();
          $queue = array();
         array_unshift($queue, $btree); #根节点入队          
          while (!empty($queue)) { #持续输出节点，直到队列为空
              $cnode = array_pop($queue); #队尾元素出队
              $traverse_data[] = $cnode->data;
  
              #左节点先入队，然后右节点入队
              if ($cnode->left != null) array_unshift($queue, $cnode->left);
             if ($cnode->right != null) array_unshift($queue, $cnode->right);
          }
  
          return $traverse_data;
      } 
      #深度优先遍历,使用一个栈实现
      function depth_first_traverse($btree) {
         $traverse_data = array();
         $stack = array();
         array_push($stack, $btree); 
           while (!empty($stack)) {
             $cnode = array_pop($stack);
             $traverse_data[] = $cnode->data; 
             if ($cnode->right != null) array_push($stack, $cnode->right);
             if ($cnode->left != null) array_push($stack, $cnode->left);
         }
 
         return $traverse_data;
      }  
      $root = new Node();
      $node1 = new Node();
      $node2 = new Node();
      $node3 = new Node();
      $node4 = new Node();
      $node5 = new Node();
      $node6 = new Node();
      $root->data = 1;
      $node1->data = 2;
      $node2->data = 3;
      $node3->data = 4;
      $node4->data = 5;
      $node5->data = 6;
     $node6->data = 7;
  
     $root->left = $node1;
     $root->right = $node2;
     $node1->left = $node3;
     $node1->right = $node4;
     $node2->left = $node5;
     $node2->right = $node6; 

     $traverse = breadth_first_traverse($root);
      print_r($traverse);
      echo "<br>";
     $traverse = depth_first_traverse($root);
    print_r($traverse);
  ?>
 

+++++PHP获得入站的搜索引擎与关键字++++++++
有时候，当我们从搜索引擎进入某个网站，他会有一行小字，“欢迎来自Google/百度，通过检索
“XXX”关键字来到本站”之类的东西。那么这个功能是怎么实现的呢？其实不难，大概思路就是，
获得入站URL，再正则我们需要的数据就行了
<?php
$url=isset($_SERVER['HTTP_REFERER'])?$_SERVER['HTTP_REFERER']:'';//获取入站url。
$search_1 = "google.com"; //q=
$search_2 = "baidu.com"; //wd=
$google = preg_match("/\b{$search_1}\b/",$url);//记录匹配情况，用于入站判断。
$baidu = preg_match("/\b{$search_2}\b/",$url);
$s_s_keyword="";
if ($google)
{
    //来自google
    $s_s_keyword=get_keyword($url,'q=');//关键词前的字符为“q=”。
    $s_s_keyword=urldecode($s_s_keyword);
    //$s_s_keyword=iconv("GBK","UTF-8",$s_s_keyword);//引擎为gbk
}
else if($baidu)
{
    //来自百度
    $s_s_keyword=get_keyword($url,'wd=');//关键词前的字符为“wd=”。
    $s_s_keyword=urldecode($s_s_keyword);
    $s_s_keyword=iconv("GBK","UTF-8",$s_s_keyword);//引擎为gbk
}
echo '$s_s_keyword';
/*
获取来自搜索引擎入站时的关键词。
*/
// 函数作用：从url中提取关键词。参数说明：url及关键词前的字符。
function get_keyword($url,$kw_start)
{
    $start=stripos($url,$kw_start);
    $url=substr($url,$start+strlen($kw_start));
    $start=stripos($url,'&');
    if ($start>0)
    {
        $start=stripos($url,'&');
        $s_s_keyword=substr($url,0,$start);
    }
    else
    {
        $s_s_keyword=substr($url,0);
    }
    return $s_s_keyword;
}
?>


+++++PHP对大文件的处理思路++++++++
需求：现有一个1G左右的日志文件，大约有500多万行， 用php返回最后几行的内容。
使用一些诸如file、file_get_contents之类的函数，这些函数可能就显的力不从心。
这种方式是最为普遍的方式,它不需要将文件的内容全部读入内存,而是直接通过指针来操作,
所以效率是相当高效的.在使用fseek来对文件进行操作时,也有多种不同的方法,
效率可能也是略有差别的,下面是常用的两种方法.
1-->
首先通过fseek找到文件的最后一位EOF，然后找最后一行的起始位置，取这一行的数据，
再找次一行的起始位置，再取这一行的位置，依次类推，直到找到了$num行。
function tail($fp,$n,$base=5)
{
    assert($n>0);
    $pos = $n+1;
    $lines = array();
    while(count($lines)< =$n){
        try{
            fseek($fp,-$pos,SEEK_END);
        } catch (Exception $e){
            fseek(0);
            break;
        }
        $pos *= $base;
        while(!feof($fp)){
            array_unshift($lines,fgets($fp));
        }
    }
    return array_slice($lines,0,$n);
}
var_dump(tail(fopen("access.log","r+"),10));

2-->
还是采用fseek的方式从文件最后开始读,但这时不是一位一位的读,而是一块一块的读,
每读一块数据时,就将读取后的数据放在一个buf里,然后通过换行符(\n)的个数来判断
是否已经读完最后$num行数据.
$fp = fopen($file, "r");
$line = 10;
$pos = -2;
$t = " ";
$data = "";
while ($line > 0) {
    while ($t != "\n") {
        fseek($fp, $pos, SEEK_END);
        $t = fgetc($fp);
        $pos --;
    }
    $t = " ";
    $data .= fgets($fp);
    $line --;
}
fclose ($fp);
echo $data;
还有一种，使用file方法。
ini_set('memory_limit','-1');
$file = 'access.log';
$data = file($file);
$line = $data[count($data)-1];
echo $line;

+++++PHP两种方法生成强密码+++++++++
$totalChar = 8; // 密码中字符串的个数
// salt to select chars from
$salt = "abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNPQRSTUVWXYZ123456789"; 
srand((double)microtime()*1000000); // 启动随机产生器
$Spass=""; // 设置初始值
for ($i=0;$i<$totalChar;$i++) // 循环创建密码
	$Spass = $Spass . substr ($salt, rand() % strlen($salt), 1);
echo $Spass;


+++++++php实现论坛中无限分类++++++++++
<?php
/*
数据表结构如下:
CREATE TABLE `category` (
`categoryID` smallint(5) unsigned NOT NULL auto_increment,
`categoryParentID` smallint(5) unsigned NOT NULL default '0',
`categoryName` varchar(50) NOT NULL default '',
PRIMARY KEY (`categoryID`)
) ENGINE=MyISAM DEFAULT CHARSET=gbk;
INSERT INTO `category` ( `categoryParentID`, `categoryName`) VALUES
(0, '一级类别'),
(1, '二级类别'),
(1, '二级类别'),
(1, '二级类别'),
(2, '三级类别'),
(2, '333332'),
(2, '234234'),
(3, 'aqqqqqd'),
(4, '哈哈'),
(5, '66333666');
*/
//指定分类id变量$category_id,然后返回该分类的所有子类
//$default_category为默认的选中的分类
function Get_Category($category_id = 0,$level = 0, $default_category =0)
{
global $DB;
$sql = "SELECT * FROM category ORDER BY categoryID DESC";
$result = $DB->query( $sql );
while ($rows = $DB->fetch_array($result))
{
$category_array[$rows[categoryParentID]][$rows[categoryID]] = array('id'=> $rows[categoryID], 'parent' => $rows[categoryParentID], 'name' =>$rows
[categoryName]);
}
if (!isset($category_array[$category_id]))
{
return "";
}
foreach($category_array[$category_id] AS $key => $category)
{
if ($category['id'] == $default_category)
{
echo "<option selectedvalue=".$category['id']."";
}else
{
echo "<option value=".$category['id']."";
}
if ($level > 0)
{
echo ">" . str_repeat( " ", $level ) . "" . $category['name'] . "</option>/n";
}
else
{
echo ">" . $category['name'] ."</option>/n";
}
Get_Category($key, $level + 1, $default_category);
}
unset($category_array[$category_id]);
}
/*
函数返回的数组格式如下所示:
Array
(
[1] => Array ( [id] => 1 [name] => 一级类别[level] => 0 [ParentID] => 0 )
[4] => Array ( [id] => 4 [name] => 二级类别[level] => 1 [ParentID] => 1 )
[9] => Array ( [id] => 9 [name] => 哈哈[level] => 2 [ParentID] => 4 )
[3] => Array ( [id] => 3 [name] => 二级类别[level] => 1 [ParentID] => 1 )
[8] => Array ( [id] => 8 [name] => aqqqqqd [level] => 2[ParentID] => 3 )
[2] => Array ( [id] => 2 [name] => 二级类别[level] => 1 [ParentID] => 1 )
[7] => Array ( [id] => 7 [name] => 234234 [level] => 2[ParentID] => 2 )
[6] => Array ( [id] => 6 [name] => 333332 [level] => 2[ParentID] => 2 )
[5] => Array ( [id] => 5 [name] => 三级类别[level] => 2 [ParentID] => 2 )
[10] => Array ( [id] => 10 [name] => 66333666 [level] => 3[ParentID] => 5 )
)
*/
//指定分类id,然后返回数组
function Category_array($category_id = 0,$level=0)
{
global $DB;
$sql = "SELECT * FROM category ORDER BY categoryID DESC";
$result = $DB->query($sql);
while ($rows = $DB->fetch_array($result))
{
$category_array[$rows['categoryParentID']][$rows['categoryID']] = $rows;
}
foreach ($category_array AS $key=>$val)
{
if ($key == $category_id)
{
foreach ($val AS $k=> $v)
{
$options[$k] =
array(
'id' => $v['categoryID'], 'name' => $v['categoryName'], 'level'=> $level, 'ParentID'=>$v['categoryParentID']
);
$children = Category_array($k, $level+1);
if (count($children) > 0)
{
$options = $options + $children;
}
}
}
}
unset($category_array[$category_id]);
return $options;
}
?>

<?php
class cate
{
       function Get_Category($category_id= 0,$level = 0, $default_category = 0)
       {
            echo$category_id;
            $arr= array(
            '0' => array(
                           '1' => array('id' => 1, 'parent' => 0, 'name' => '1111'),
                           '2' => array('id' => 2, 'parent' => 0, 'name' => '2222'),
                          '4' => array('id' => 4, 'parent' => 0, 'name' =>'4444')    
                        ),
            '1' => array(
                            '3' => array('id' => 3, 'parent' => 1, 'name' => '333333'),
                          '5' => array('id' => 5, 'parent' => 1, 'name' => '555555')    
                          ),
                        
            '3' => array(
                          '6' => array('id' => 6, 'parent' => 3, 'name' => '66666'),
                          '7' => array('id' => 7, 'parent' => 3, 'name' => '77777')
                          ),
            '4' => array(
                          '8' => array('id' => 8, 'parent' => 4, 'name' => '8888'),
                          '9' => array('id' => 9, 'parent' => 4, 'name' => '9999')
                          )    
            );
            if(!isset($arr[$category_id]))
            {
              return "";
            }
    
           foreach($arr[$category_id] AS $key => $cate)
            {
               if ($cate['id'] == $default_category)
               {
                   $txt = "<option selected value=".$cate['id']."";
               }else{
                   $txt = "<option value=".$cate['id']."";
               }
           
               if ($level > 0)
               {
                  $txt1 = ">" . str_repeat( "-", $level ) . " ". $cate['name'] . "</option>/n";
               }else{
                   $txt1 = ">" . $cate['name'] . "</option>/n";
               }
               $val = $txt.$txt1;
               echo $val;
               self::Get_Category($key, $level + 1, $default_category);
            }
           
       }
       
       
       function getFlush($category_id =0,$level = 0, $default_category = 0)
       {
           
           ob_start();
          self::Get_Category($category_id ,$level, $default_category);
           $out =ob_get_contents();
          ob_end_clean();
           return$out;
       }    
}
$id =$_GET['id'];
echo "<select>";
$c = new cate();
//$c->Get_Category();
$ttt=  $c->getFlush($id,'0','3');
echo $ttt;
echo "</select>";
?>

+++++序列化与反序列化+++++
序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这
两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 
PHP中的序列化和反序列化分别通过函数serialize()和unserialize()即可实现。
serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将serialize的返回结果作为参数，进行反序列化，得到原对象。

+++++文件压缩的原理+++++
电脑是采用二进制的，所以就全是1和0两个数字。那么难免的有的时候会重复出现，比如：10101010101010101010101010101010，那么就是16个10于是压缩的时候就记做16个10。
然后我们把16换算为二进制的，就是1000。那么电脑就会写成100010。当然，这其中一定还会有一些记号。只是我不太清楚而已。然后在解压的时候就可以把100010还原为10101010101010101010101010101010。
那么一算，就把本来的32位的数字变为了6位。所以就达到了压缩的目的！
php字符串压缩与解压缩：

+++++php扫描本地目录与文件+++++
header('content-type:text/html; charset=utf-8');
   $dirname='Public'; //要遍历的目录名字
   $dir_handle=opendir($dirname);
    echo '<table border="1" align="center" width="960px" cellspacing="0" cellpadding="0">';
   echo '<caption><h2>目录'.$dirname.'下面的内容</h2></caption>';
   echo '<tr align="left" bgcolor="#cccccc">';
   echo '<th>文件名</th><th>文件大小</th><th>文件类型</th><th>修改时间</th><th>完整路径</th><th>test1</th><th>test2</th></tr>';
   while($file=readdir($dir_handle))
   {
     if($file!="."&&$file!="..")
     {
        $dirFile=$dirname."/".$file;	
        echo '<td>'.$file.'</td>';
        echo '<td>'.filesize($dirFile).'</td>';
        echo '<td>'.filetype($dirFile).'</td>';
        echo '<td>'.date("Y/n/t",filemtime($dirFile)).'</td>';
		echo '<td>'.$dirFile.'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filectime($dirFile)).'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filemtime($dirFile)).'</td>';
        echo '</tr>';
     }
   }
   echo '</table>';
   closedir($dir_handle);

++++php版本的进化史+++++++
PHP/Mysql中几个版本的进化史，比如mysql4.0到4.1，PHP 4.x到5.1的重大改进等等：
MySQL：  
一、从 4.0 到 4.1 的主要变化  
如果在4.1.0到4.1.3版本的MySQL中创建了包含 TIMESTAMP 字段的 InnoDB表。则在升级到4.1.4及更高时需要重建表，因为存储格式发生变化了。   
字符串根据标准SQL来比较：比较之前不删除末尾的空格，以前用末尾空格扩展了比较短的字符串。现在的结果是  
'a' > 'a\t'，以前则不这样。可以用 mysqlcheck 来检查一下数据表。  
TIMESTAMP 返回 'YYYY-MM-DD HH:MM:SS' 格式的字符串。在MySQL 4.0中，可以增加选项 --new 来获得ySQL 4.1中这方面的特性。  
在MySQL4.1.1前，语句解析器不是那么严格，它在处理字符串转时间转换时会忽略第一个数字前的其他字符。在4.1.1之后，就比较严格了，返回结果是 DATE, DATETIME, 或 TIME 类型的函数的结果会被转换成时间型  
二、再看从 4.1 到 5.0 的主要变化  
◆InnoDB 和 MyISAM 表中空格结尾的 TEXT 字段索引顺序改变了。因此需要运行"CHECK TABLE" 语句修复数据表，如果出现错误，就运行 "OPTIMIZE TABLE" 或 "REPAIR TABLE" 语句修复，甚至重新转储(用mysqldump)。  
◆MySQL 5.0.15开始，如何处理 BINARY 字段中填充的值已经改变了。填充的值现在是0x00 而非空格了，并且在取值的时候不会去除末尾的空格。  
◆从MySQL 5.0.3开始，DECIMAL 的实现方式已经改变了，5.0对 DECIMAL的格式限制严格多了。在MySQL 5.0.3到5.0.5之间版本的 MyISAM 和 InnoDB 表中创建的 DECIMAL字段升级到5.0.6之后会发生崩溃。从5.0.3开始，DECIMAL 用更有效的格式来存储。5.0.3开始，在计算 DECIMAL 值和舍入精确值的时候采用精确数学。  
◆在以前，等待超时的锁会导致 InnoDB回滚当前全部事务，从5.0.13开始，就只回滚最近的SQL语句了。  
◆在4.1.13/5.0.8以前，DATETIME 的加0后就转换成 YYYYMMDDHHMMSS 格式，现在变为YYYYMMDDHHMMSS.000000 格式了  
◆4.1中，FLOAT 或 DOUBLE 之间的比较碰巧没问题，但在5.0中可能就不行了  
◆从5.0.3开始，VARCHAR 和 VARBINARY 字段中末尾的空格不再删除  
◆增加了一个新的启动选项 innodb_table_locks，它导致 LOCK TABLE 时也可以请求InnoDB 表锁。这个选项默认打开，不过可能在 AUTOCOMMIT=1 和 LOCK TABLES应用中会导致死锁。看来，我只需主要关注 时间(TIMESTAMP, DATETIME< DATE, TIME) 和数值型(FLOAD, DOUBLE, DECIMAL) 这两种类型的变化;另外，我升级过程中暂时还不需要涉及到字符集问题，因此相对轻松一些。  
升级步骤如下：  
执行  
FLUSH TABLES WITH READ LOCK;  
直接拷贝 MyISAM 表文件  
用 mysqldump 导出 Innodb 类型的表  
整个过程都很顺利，新系统启动之后，发现如下2个问题：  
新增了关键字 INOUT，因此需要检查表结构中还有其他什么字段使用关键字了  
DATE_FORMAT 函数要求严谨多了，  
DATE_FORMAT('2006/11/24 09:14:00', '%Y-%m-%d %T')   
和DATE_FORMAT('2006/11/2409:14:00', '%Y-%m-%d %T')   
的结果完全不一样，在 4.0 中，能兼容这两种格式，而在 5.0 中，只能正确的使用前者了，后者则会有问题。这也应该是上面提到的时间类型发生的变化所致。 
PHP5以下几个改进值得关注：  
1、极大地提高了面向对象能力；  
2、支持try/catch异常处理；  
3、改进了字符串地处理；  
4、改经了xml和web服务支持；  
5、对SQlite内置支持。 


+++++++++解决多进程/线程同时读写一个文件++++++
大家都知道，PHP是没有多线程概念的，尽管如此我们仍然可以用“不完美”的方法来模拟多线程。简单的说，就是队列处理。通过对文件进行加锁和解锁，来实现。当一个文件被一个用户操作时，该文件是被锁定的，其他用户只能等待，确实不够完美，但是也可以满足一些要求不高的应用。  
function T_put($filename,$string){  
$fp = fopen($filename,’a'); //追加方式打开  
if (flock($fp, LOCK_EX)){ //加写锁  
fputs($fp,$string); //写文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
}  
function T_get($filename,$length){  
$fp = fopen($filename,’r'); //追加方式打开  
if (flock($fp, LOCK_SH)){ //加读锁  
$result = fgets($fp,$length); //读取文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
return $result;  
}  

++++++MyISAM与Innodb++++++++
简单的表达。  
MyISAM 是非事务的存储引擎。  
innodb 是支持事务的存储引擎。  
innodb    的引擎比较适合于插入和更新操作比较多的应用  
而MyISAM  则适合用于频繁查询的应用  
MyISAM    --表锁。  
innodb    --设计合理的话是行锁。  
MyISAM    不会出现死锁。  
最大的区别就是MYISAM适合小数据，小并发；INNODB 适合大数据，大并发。最大的区别就是在锁的级别上。  
MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 MyISAM类型的表强调的是性能，
其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等
高级数据库功能。综述，就可以根据数据表不同的用处是用不同的存储类型。而且MyISAM是文件存储
的，可以进行直接在不同操作系统间拷贝使用。  
InnoDB：  
InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
InnoDB 提供了行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)。
这些特性均提高了多用户并发操作的性能表现。在InnoDB表中不需要扩大锁定(lock escalation)，
因为 InnoDB 的列锁定(row level locks)适宜非常小的空间。InnoDB 是 MySQL 上第一个提供外键约束(FOREIGN KEY constraints)的表引擎。
InnoDB 的设计目标是处理大容量数据库系统，它的 CPU 利用率是其它基于磁盘的关系数据库引擎所不能比的。
在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
 InnoDB 把数据和索引存放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 MyISAM 中，表被存放在单独的文件中。
InnoDB 表的大小只受限于操作系统的文件大小，一般为 2 GB。
InnoDB所有的表都保存在同一个数据文件 ibdata1 中（也可能是多个文件，或者是独立的表空间文件），相对来说比较不好备份，可以拷贝文件或用navicat for mysql。  
MyISAM  
每张MyISAM 表被存放在三个文件 ：frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex) 引伸。  
因为MyISAM相对简单所以在效率上要优于InnoDB，小型应用使用MyISAM是不错的选择。  
MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦  
2.web 架构，安全,项目经验

++++++++++介绍xdebug,apc,eAccelerator,Xcache,Zend opt的使用经验++++++++++++
Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况
。
eAccelerator是一个自由开放源码php加速器，优化和动态内容缓存，提高了php脚本的缓存性能，
使得PHP脚本在编译的状态下，对服务器的开销几乎完全消除。它还有对脚本起优化作用，以加快其执行效率。
使您的PHP程序代码执效率能提高1-10倍；
XCache 是一个开源的 opcode 缓存器/优化器, 这意味着他能够提高您服务器上的 PHP 性能. 他通过把编译 
PHP 后的数据缓冲到共享内存从而避免重复的编译过程, 能够直接使用缓冲区已编译的代码从而提高速度. 
通常能够提高您的页面生成速率 2 到5 倍, 降低服务器负载.
Zend Optimizer(以下简称ZO)用优化代码的方法来提高php应用程序的执行速度。实现的原理是对那些在被最终
执行之前由运行编译器(Run-TimeCompiler)产生的代码进行优化。
一、PHP加速器介绍
        PHP加速器是一个为了提高PHP执行效率，从而缓存起PHP的操作码，这样PHP后面执行就不用解析转换了，可以直接调用PHP操作码，这样速度上就提高了不少。
        Apache中使用mod_php的请求、响应执行流程：
　　1、Apache接收请求。
2、Apache传递请求给mod_php。
3、mod_php定位磁盘文件，并加载到内存中。
4、mod_php编译源代码成为opcode树。
5、mod_php执行opcode树。
       PHP加速器相应的就是第四步，它的目的就是防止PHP每次请求都重复编译PHP代码，因为在高访问量的网站上，大量的编译往往没有执行速度快呢？所以这里面有个瓶颈就是PHP的重复编译既影响了速度又加载了服务器负载，为了解决此问题，PHP加速器就这样诞生了。
二、PHP加速器安装与配置
        1、安装配置APC
             APC全称是Alternative PHP Cache,官方翻译叫”可选PHP缓存”,它是PHP PECL中的一个扩展，好像是facebook在使用它，下面开始安装（ubuntu环境）： 
$wget http://pecl.php.net/get/APC-3.0.19.tgz
$tar xvzf APC-3.0.19.tgz
$cd APC-3.0.19/APC-3.0.19
$/usr/local/php/bin/phpize
$./configure –enable-apc –enable-apc-mmap –with-php-config=/usr/local/php/bin/php-config
$make
$sudo make install
下面我们再配置APC,因为我的PECL扩展路径改变了，所以我得移动下编译好的文件：
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/apc.so /usr/local/php/lib/php/extensions/PECL
然后我们再编辑php.ini文件进行配置，请把下面的代码加入到php.ini中即可：
extension_dir = "/usr/local/php/lib/php/extensions/PECL"
extension = apc.so
; APC
apc.enabled = 1
apc.shm_segments = 1
apc.shm_size = 64
apc.optimization = 1
apc.num_files_hint = 0
apc.ttl = 0
apc.gc_ttl = 3600
apc.cache_by_default = on
     这样重启apache就会在phpinfo()信息中显示。
       2、安装配置eAccelerator
          eAccelerator的前身其实是truck-mmcache，因为开发truk-mmcache的人被Zend给招安了，所以开发eAccelerator的人继承了truk-mmcache的一些特性，设计出eAccelerator加速器。安装如下：
$wget http://jaist.dl.sourceforge.net/sourceforge/eaccelerator/eaccelerator-0.9.5.tar.bz2
$tar -jxf eaccelerator-0.9.5.tar.bz2
$cd eaccelerator-0.9.5
$/usr/local/php/bin/phpize
$./configure –enable-eaccelerator=shared –with-php-config=/usr/local/php/bin/php-config
$make
$sudo make install
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/eaccelerator.so /usr/local/php/lib/php/extensions/PECL
将下面代码加入php.ini文件中
extension = eaccelerator.so
; eAccelerator
eaccelerator.shm_size = "16"
eaccelerator.cache_dir = "/tmp/eaccelerator"
eaccelerator.enable = "1"
eaccelerator.optimizer = "1"
eaccelerator.check_mtime = "1"
eaccelerator.debug = "0"
eaccelerator.filter = ""
eaccelerator.shm_max = "0"
eaccelerator.shm_ttl = "0"
eaccelerator.prune_period = "0"
eaccelerator.shm_only = "0"
eaccelerator.compress = "1"
eaccelerator.compress_level = "9"
创建缓存目录,重启apache
$sudo mkdir /tmp/eaccelerator
$sudo chmod 777 /tmp/eaccelerator
$sudo /usr/local/apache/apachectl restart
在phpinfo()检查是否安装成功.
3、安装配置XCache
XCache作为国人自己开发的东西，做小菜鸟的我也感到骄傲，而且XCache无论在速度还是性能上都做的不错。下面就赶紧让我们品尝它吧！
$wget http://xcache.lighttpd.net/pub/Releases/1.2.2/xcache-1.2.2.tar.gz
$tar xvzf xcache-1.2.2.tar.gz
$cd xcache-1.2.2
$/usr/local/php/bin/phpize
$./configure –enable-xcache –enable-xcache-coverager –with-php-config=/usr/local/php/php-config
$make
$sudo make install
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/xcache.so /usr/local/php/lib/php/extensions/PECL
在php.ini添加配置信息：
extension = xcache.so
; xcache
xcache.admin.user = "admin"
xcache.admin.pass = "(执行) echo ’(你的密码)’|md5sum(得出的密文)"
;
xcache.size = 24M
xcache.shm_scheme = "mmap"
xcache.count = 2
xcache.slots = 8k
xcache.ttl = 0
xcache.gc_interval = 0
xcache.var_size = 8M
xcache.var_count = 1
xcache.var_slots = 8k
xcache.var_ttl = 0
xcache.var_maxttl = 0
xcache.var_gc_interval = 300
xcache.test = Off
xcache.readonly_protection = On
xcache.mmap_path = "/tmp/xcache"
xcache.coredump_directory = ""
xcache.cacher = On
xcache.stat = On
xcache.optimizer = Off
;
xcache.coverager = On
xcache.coveragedump_directory = ""
创建缓存目录，重启apache
$sudo mkdir /tmp/xcache
$sudo chmod 777 /tmp/xcache
$sudo /usr/local/apache/bin/apachectl restart
去查看phpinfo()信息吧！
   1、通过测试得出eAccelerator在请求时间和内存占用综合方面是最好的。
   2、通过测试得出使用加速器比无加速器在请求时间快了3倍左右。
   3、通过各个官方观察，XCache是更新最快的，这也说明最有发展的。
 以上是总结结果，你也许会问我到底用那个加速器好呢？我只能告诉你，首先，用一定比不用好，
其次每个加速器还有一些可以调优的参数，所以要根据你的系统环境而定，然后，我个人觉得你可以详细研
究下eAccelerator和XCache，这两款潜力还是很大的.

++++++++++mysql_connect 与 memcache_connect 应该哪个在在前，哪个在后++++++++++
答案应该是先 memcache_connect 再 mysql_connect,因为memcache存在不稳定因素，容易发生阻塞，
一旦memcache发生阻塞，如果是先mysql_connect,就会造成生成大量mysql空链接而无法释放
一个类似的问题是 echo $html 和 mysql_connect应该哪个在前
按照网上看到的以为叫caoz的朋友的说法，应该是mysql_connect在前，echo $html会等待网络传输，
并发量高的时候会造成数据库链接的阻塞

++++++++++Apache可以被配置为正向(forward)和反向(reverse)代理。++++++++++ 
正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个
请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要
进行一些特别的设置才能使用正向代理。 
    正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用
缓冲特性(由mod_cache提供)减少网络使用率。 使用ProxyRequests指令即可激活正向代理。因为正向代理
允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端
提供服务.
   反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。
客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)
转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。
    反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多
台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，还可以启用高级URL策略和管理技术，
从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 可以使用ProxyPass指令激活反向
代理。配置反向代理并不需要打开ProxyRequests指令

+++++++++++对于大流量的网站,您采用什么样的方法来解决各页面访问量统计问题+++++++++++
确认服务器硬件是否足够支持当前的流量,数据库读写分离,优化数据表, 
程序功能规则,禁止外部的盗链,控制大文件的下载,使用不同主机分流主要流量

+++++++++++请介绍Session的原理,大型网站中Session方面应注意什么?+++++++++++
运行机制:客户端将session id传递到服务器，服务器根据session id找到对应的文件，读取的时候对文件内容
进行反序列化就得到session的值，保存的时候先序列化再写入。
注意:1,session在大访问量网站上确实影响系统性能，影响性能的原因之一由文件系统设计造成，
在同一个目录下超过10000个文件时，文件的定位将非常耗时,可以通过修改php.ini中session.save_path设置
两级子目录 ,session将存储在两级子目录中，每个目录有16个子目录[0~f]，不过好像PHP session不支持创
建目录，你需要事先把那么些目录创建好 。
2,还有一个问题就是小文件的效率问题,可以通过存储方式中的memcache来解决I/O效率低下的问题
3,session同步问题,session同步有很多种，如果你是存储在memcached或者MySQL中，那就很容易了，
指定到同样的位置即可,还有一种方法就是在负载均衡那一层保持会话，把访问者绑定在某个服务器上，
他的所有访问都在那个服务器上就不需要session同步了


+++++++++++测试php性能和mysql数据库性能的工具,和找出瓶颈的方法。+++++++++++
xhprof  PHP性能测试工具。   MySQL 的企业监控器（Enterprise Monitor）也是值得考虑的工具之一

+++++++++++正则提出一个网页中的所有链接.+++++++++++
/(http:\/\/\[^" ']+)/gm ;
/href *= *['"]*(\S+)["']* */gm ;
preg_match_all('/a href=[\"\']|/src=[\"\']([^\"\' ]+)/i',$var,$match);


+++++++++++介绍一下常见的SSO(单点登陆)方案(比如dedecms整合discuz的passport)的原理。+++++++++++
单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在
其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，
例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系
统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯
掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，
因此要点也就以下几个：
存储信任
验证信任
如何高效存储大量临时性的信任数据
如何防止信息传递过程被篡改
如何让SSO系统信任登录系统和免登系统
对于第一个问题，一般可以采用类似与memcached的分布式缓存的方案，既能提供可扩展数据量的机制，也能
提供高效访问。对于第二个问题，一般采取数字签名的方法，要么通过数字证书签名，要么通过像md5的方式，
这就需要SSO系统返回免登URL的时候对需验证的参数进行md5加密，并带上token一起返回，最后需免登的系统
进行验证信任关系的时候，需把这个token传给SSO系统，SSO系统通过对token的验证就可以辨别信息是否被
改过。对于最后一个问题，可以通过白名单来处理，说简单点只有在白名单上的系统才能请求生产信任关系，
同理只有在白名单上的系统才能被免登录。

+++++++++++一 群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，
在把它踢出去…，如此不停的 进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。
要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。用程序模拟该过程。+++++++++++
 <html>
      <body>        
          <?php
              function monkeyKing($n, $m) {    //$n为猴子总数,$m为剔除猴子步长
                  $s = 0;    //$s为大王坐标,只有一只猴子时,大王坐标为0
                  for($i = 2; $i <= $n; $i++) {    //依次向后递推,求到共有$n只猴子,剔除步长为$m时的大王坐标
                     $s = ($s + $m) % $i;    //大王坐标递推公式
                 }
                  return $s;
            }             
             echo monkeyKing(6, 2);
         ?>
     </body>
 </html>


+++++++++++MySQL数据库，怎么优化？+++++++++++
(1)配置优化（服务器配置）   (2)建表优化（表、字段设置） (3)查询优化（sql语句） 答： 1、选取最适用
的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM 2、
使用连接（JOIN）来代替子查询: 3、使用联合(UNION)来代替手动创建的临时表 4、事务处理: 5、锁定表,
优化事务处理: 6、使用外键,优化锁定表 7、建立索引: 8、优化查询语句


+++++++++++写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。（目录操作）+++++++++++
$d = dir(dirname(__file__));
echo "Handle: " . $d->handle . "\n";
echo "Path: " . $d->path . "\n";
while ( false !== ($entry = $d->read ()) ) {
echo $entry . "";
}
$d->close ();

+++++++++++怎么防止sql注入？+++++++++++
答：①、过滤用户提交的内容，比如update、insert、select、delete、*等数据库操作的关键字。
    ②、使用函数addslashes()转义提交的内容。
③、Php配置文件中开启magic_quotes_gpc=on;将自动转换用户查询的sql语句，对防sql注入有重大作用。
④、在php配置文件中将register_globals设置为off，关闭全局变量注册。
⑤、在php配置文件中开启安全模式safe_mode=on;
⑥、Sql语句的书写尽量不要省略小引号和单引号。
⑦、提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的名称。
⑧、控制错误信息，关闭错误信息的输出，将错误信息写到日志文件中，不要在网站暴漏错误信息。


+++++++++++数据库索引有几类，分别是什么？什么时候该用索引？+++++++++++
答：①主键索引，它用于根据主键自身的唯一性来唯一标识每条记录。因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如自增加整数值。这样，无论以后是否删除以前存在的记录，每条记录都有唯一的主键索引。
②与主键索引一样，唯一索引可以防止重建重复的值。但是，不同之处在于，每个表只能有一个主键索引，但可以有多个唯一索引。
     ③常规索引。经常希望对非主键甚至并非唯一的字段上的搜索进行优化。（1）如果表中的某个列将成为大量选择查询的焦点，就应当使用单列常规索引。并且一般指定列的前N个字符对于确保唯一性已经足够，如：INDEX(lastname(5))。（2）如果指定列会经常在获取查询中一起使用，则推荐使用多列索引。Mysql的多列索引方法基于一种称为最左前缀的策略。
     ④全文索引。提供了一种高效的方法来搜索存储在CHAR、VARCHAR或者TEXT类型中的文本。Mysql默认会忽略少于4个字符的关键字。Boolean全文搜索对搜索查询提供了更细粒度的控制，允许显示的标识结果中应当或不应当出现哪些单词。
索引最佳实践
只对where和order by子句中需要的列添加索引。多余的索引会导致不必要的硬盘空间消耗，在修改表信息的时候会降低性能。有索引的表在性能会降低，这是由于每次修改记录都必须更新索引。
如果创建诸如INDEX(firstname,lastname)的索引，不要再创建INDEX(firstname),因为mysql能搜索索引前缀。不过，要记住只有前缀有索引，这个多列索引不能应用于对lastname的搜索。
对于准备索引的列要使用属性NOT NULL，这样就永远不会存在存储NULL值。
对不使用索引的查询，使用选项—log-long-format来记录日志。然后可以检查日志文件，对查询进行相应的调整。
EXPLAIN语句有助于确定mysql如何执行查询，展示表是如何连接的，以及按怎样的顺序连接。


+++++++++++引用传值和非引用传值的区别，什么时候该用引用传值，什么时候该用非引用传值+++++++++++
答：按值传递：函数内对值的任何改变在函数外都被忽略。
引用传值：函数内对值的任何改变在函数外也将反映出这些修改。
按值传递时php必须复制值，操作大型对象和字符串这将是代价很大的操作。按引用传值不需要复制值，对性能的提高有好处。
当需要在函数内改变原变量的值时用引用传值，如果不想改变原变量的值时用传值。


+++++++++++PHP遍历文件夹及子文件夹所有文件 +++++++++++
 <html>
      <body>
         <?php
             function traverse($path = '.') {
                  $current_dir = opendir($path);    //opendir()返回一个目录句柄,失败返回false
                 while(($file = readdir($current_dir)) !== false) {    //readdir()返回打开目录句柄中的一个条目
                      $sub_dir = $path . DIRECTORY_SEPARATOR . $file;    //构建子目录路径
                     if($file == '.' || $file == '..') {
                          continue;
                     } else if(is_dir($sub_dir)) {    //如果是目录,进行递归
                         echo 'Directory ' . $file . ':<br>';
                         traverse($sub_dir);
                     } else {    //如果是文件,直接输出
                         echo 'File in Directory ' . $path . ': ' . $file . '<br>';
                     }
                 }
             }             
             traverse('xxtt');
         ?>
 </html>


 +++++++++++PHP中单引号双引号的区别 +++++++++++
1.双引号可以解析变量表达式,单引号不能
2.双引号会对换行符等转义字符进行解析,而单引号不能
1  <?php
2     $name = "Jack";
3     echo '$nameJones, you are a good \t\tguy <br>';
4     echo "{$name}Jones, you are a good \t\tguy";
5  ?>
页面输出
$nameJones, you are a good \t\tguy 
JackJones, you are a good guy


++++++++php分析当前url的域名和顶级域名++++++++++
function parseDomain($url){
    $url = strtolower(trim($url));
    if(empty($url)) return '';
    $regx1 = '/(https?:\/\/)(([^\/\?#]+\.)?([^\/\?#-\.]+\.)(com\.cn|org\.cn|net\.cn|com\.jp|co\.jp|com\.kr|com\.tw)(\:[0-9]+)?)/i';
    $regx2 = '/(https?:\/\/)(([^\/\?#]+\.)?([^\/\?#-\.]+\.)(cn|com|org|net|cc|biz|hk|jp|kr|name|me|tw|la)(\:[0-9]+)?)/i';
    $domain = $topDomain = '';
    if(preg_match($regx1, $url, $matches)){
        $domain = $matches[0];
    }elseif(preg_match($regx2, $url, $matches)){
        $domain = $matches[0];
    }
    if($matches){
        if($matches[3] == 'www.'){
            $topDomain = $domain;
        }else{
            foreach($matches as $key => $value){
                if($key!=1 && $key<4) continue;
                $topDomain .= $value;
            }
        }
    }
    return array('domain' => $domain, 'top_domain' => $topDomain);
}
//测试代码
$url = 'http://www.justflyhigh.com:8080';
printf('<pre>%s</pre>', print_r(parseDomain($url), true));
结果为：
Array(
  [domain] => http://www.justflyhigh.com:8080
  [top_domain] => http://justflyhigh.com:8080
)


++++++php手机号中间几位替换成星号+++++++
$string = '王经理：13241262019，李经理：13841261234';
echo preg_replace('/(\d{3})\d{4}/', '$1****', $string);
或者
$phone = '13241262019';
echo substr_replace($phone, '****', 3, 4);


+++++++++php采集图片程序+++++++++++++
/**
*  采集图片php程序
*/
set_time_limit(0);
/**
* 写文件
* @param    string  $file   文件路径
* @param    string  $str    写入内容
* @param    char    $mode   写入模式
*/
function wfile($file,$str,$mode='w')
{
    $oldmask = @umask(0);
    $fp = @fopen($file,$mode);
    @flock($fp, 3);
    if(!$fp)
    {
        Return false;
    }
    else
    {
        @fwrite($fp,$str);
        @fclose($fp);
        @umask($oldmask);
        Return true;
    }
}
function savetofile($path_get,$path_save)
{
        @$hdl_read = fopen($path_get,'rb');
        if($hdl_read == false)
        {
                echo("<span style='color:red'>$path_get can not get</span>");
                Return ;
        }
        if($hdl_read)
        {
                @$hdl_write = fopen($path_save,'wb');
                if($hdl_write)
                {
                        while(!feof($hdl_read))
                        {
                                fwrite($hdl_write,fread($hdl_read,8192));
                        }
                        fclose($hdl_write);
                        fclose($hdl_read);
                        return 1;
                }
                else
                        return 0;
        }
        else
                return -1;
}
function getExt($path)
{
        $path = pathinfo($path);
        return strtolower($path['extension']);
}
/**
* 按指定路径生成目录
*
* @param    string     $path    路径
*/
function mkDirs($path)
{
    $adir = explode('/',$path);
    $dirlist = '';
    $rootdir = array_shift($adir);
    if(($rootdir!='.'||$rootdir!='..')&&!file_exists($rootdir))
    {
        @mkdir($rootdir);
    }
    foreach($adir as $key=>$val)
    {
        if($val!='.'&&$val!='..')
        {
            $dirlist .= "/".$val;
            $dirpath = $rootdir.$dirlist;
            if(!file_exists($dirpath))
            {
                @mkdir($dirpath);
                @chmod($dirpath,0777);
            }
        }
    }
}
/**
* 从文本中取得一维数组
*
* @param    string     $file_path    文本路径
*/
function getFileListData($file_path)
{
    $arr = @file($file_path);
    $data = array();
    if(is_array($arr) && !empty($arr))
    {
        foreach($arr as $val)
        {
            $item = trim($val);
            if(!empty($item))
            {
                $data[] = $item;
            }
        }
    }
    Return $data;
}
//采集开始
//传入自己的需要采集的图片url列表文本文件 每个图片url写一行
$url_file = isset($_GET['file'])&&!empty($_GET['file'])?$_GET['file']:null;
$txt_url = "txt/".$url_file;
$urls = array_unique(getFileListData($txt_url));
if(empty($urls))
{
        echo('<div style="color:red">无链接地址</div>');
        die();
}
$save_url = "images/".date("y_m_d",time())."/";
mkDirs($save_url);  //按日期建立文件夹
$i = 1;
if(is_array($urls)&&count($urls))
{
        foreach($urls as $val)
        {
                savetofile($val,$save_url.date("His",time())."_".$i.".".getExt($val));
                echo($i.".".getExt($val)." got\n");
                $i++;
        }
}
echo('<div style="color:green">finish</div>');

+++++++++++大型的论坛/新闻文章系统/SNS网站在性能优化上有什么区别?+++++++++++
新闻媒体注意细览页的性能优化，比如图片、结构，保持清爽；
SNS注意交互、页面JS、ajxa、动态内容大小；
严格控制大小、减少定向、压缩图片、降低CSS加载速度，利用好缓存，这是通的。



++++++php红包算法+++++++
/** 
* 生产min和max之间的随机数，但是概率不是平均的，从min到max方向概率逐渐加大。 
* 先平方，然后产生一个平方值范围内的随机数，再开方，这样就产生了一种“膨胀”再“收缩”的效果。 
*/    
function xRandom($bonus_min,$bonus_max){  
    $sqr = intval(sqr($bonus_max-$bonus_min));  
    $rand_num = rand(0, ($sqr-1));  
    return intval(sqrt($rand_num));  
}  
 /**   
 * @param $bonus_total 红包总额 
 * @param $bonus_count 红包个数 
 * @param $bonus_max 每个小红包的最大额 
 * @param $bonus_min 每个小红包的最小额 
 * @return 存放生成的每个小红包的值的一维数组 
 */    
function getBonus($bonus_total, $bonus_count, $bonus_max, $bonus_min) {    
    $result = array();    
    $average = $bonus_total / $bonus_count;    
    $a = $average - $bonus_min;    
    $b = $bonus_max - $bonus_min;      
    //这样的随机数的概率实际改变了，产生大数的可能性要比产生小数的概率要小。    
    //这样就实现了大部分红包的值在平均数附近。大红包和小红包比较少。    
    $range1 = sqr($average - $bonus_min);    
    $range2 = sqr($bonus_max - $average);    
    for ($i = 0; $i < $bonus_count; $i++) {    
        //因为小红包的数量通常是要比大红包的数量要多的，因为这里的概率要调换过来。    
        //当随机数>平均值，则产生小红包    
        //当随机数<平均值，则产生大红包    
        if (rand($bonus_min, $bonus_max) > $average) {    
            // 在平均线上减钱    
            $temp = $bonus_min + xRandom($bonus_min, $average);    
            $result[$i] = $temp;    
            $bonus_total -= $temp;    
        } else {    
            // 在平均线上加钱    
            $temp = $bonus_max - xRandom($average, $bonus_max);    
            $result[$i] = $temp;    
            $bonus_total -= $temp;    
        }    
    }    
    // 如果还有余钱，则尝试加到小红包里，如果加不进去，则尝试下一个。    
    while ($bonus_total > 0) {    
        for ($i = 0; $i < $bonus_count; $i++) {    
            if ($bonus_total > 0 && $result[$i] < $bonus_max) {    
                $result[$i]++;    
                $bonus_total--;    
            }    
        }    
    }    
    // 如果钱是负数了，还得从已生成的小红包中抽取回来    
    while ($bonus_total < 0) {    
        for ($i = 0; $i < $bonus_count; $i++) {    
            if ($bonus_total < 0 && $result[$i] > $bonus_min) {    
                $result[$i]--;    
                $bonus_total++;    
            }    
        }    
    }    
    return $result;    
}  
$bonus_total = 200;  
$bonus_count = 100;  
$bonus_max = 10;//此算法要求设置的最大值要大于平均值  
$bonus_min = 1;  
$result_bonus = getBonus($bonus_total, $bonus_count, $bonus_max, $bonus_min);  
$total_money = 0;  
$arr = array();  
foreach ($result_bonus as $key => $value) {  
    $total_money += $value;  
    if(isset($arr[$value])){  
        $arr[$value] += 1;  
    }else{  
        $arr[$value] = 1;  
    }    
}  
//输出总钱数，查看是否与设置的总数相同  
echo $total_money;  
//输出所有随机红包值  
var_dump($result_bonus);  
//统计每个钱数的红包数量，检查是否接近正态分布  
//ksort($arr);  
//var_dump($arr);  


++++++较为简单的红包算法+++++++
$n = 200; //红包个数
$amount = 5000; //红包总金额
$s = 2.00*100; //最小金额 精确到分
$b = 48.00*100; //最大金额 精确到分
getPacket($n,$amount,$s,$b);
function getPacket($n,$amount,$s,$b){
	$arr = array();
	for($i=0;$i< $n-1;$i++){
		$arr[$i] = rand($s,$b)/100;
	}
	$last = ($amount - array_sum($arr))/100;
	$arr[$n-1] = sprintf("%.2f",$last);
	if($arr[$n-1]>$s/100 && $arr[$n-1]< $b/100){
		echo "<pre>";
		print_r($arr);
	}else{
		getPacket($n,$amount,$s,$b);
	}
}


++++抽奖全概率计算+++++
/**
 * 全概率计算
 *
 * @param array $p array('a'=>0.5,'b'=>0.2,'c'=>0.4)
 * @return string 返回上面数组的key
 */
function random($ps){
    static $arr = array();
    $key = md5(serialize($ps));

    if (!isset($arr[$key])) {
        $max = array_sum($ps);
        foreach ($ps as $k=>$v) {
            $v = $v / $max * 10000;
            for ($i=0; $i<$v; $i++) $arr[$key][] = $k;
        }
    }
    return $arr[$key][mt_rand(0,count($arr[$key])-1)];
}  


+++++++PHP生成静态页面实例代码++++++
<?  
ob_start();  
echo "<html>".  
"<head>".  
"<title>PHP网站静态化教程</title>".  
"</head>".  
"<body>欢迎访问PHP网站开发教程网www.leapsoul.cn，本文主要介绍PHP网站页面静态化的方法</body>".  
"</html>";  
$out1 = ob_get_contents();  
ob_end_clean();  
$fp = fopen("leapsoulcn.html","w");  
if(!$fp)  
{  
echo "System Error";  
exit();  
}  
else  
{  
fwrite($fp,$out1);  
fclose($fp);  
echo "Success";  
}  
?>  


++++++php自己写的红包算法+++++
header("Content-Type: text/html;charset=utf-8");  
$total=10;//红包总额  
$num=8;// 分成8个红包，支持8人随机领取  
$min=0.01;//每个人最少能收到0.01元  
  
for ($i=1;$i<$num;$i++)  
{  
    $safe_total=$total-($num-$i)*$min;//随机安全上限  
    $money=mt_rand($min*100,$safe_total*100)/100;  
    $total=$total-$money;  
    echo '第'.$i.'个红包：'.$money.' 元，余额：'.$total.' 元 <br/>';  
}  
echo '第'.$num.'个红包：'.$total.' 元，余额：0 元'; 

结果为：
第1个红包：0.19 元，余额：9.81 元 
第2个红包：5.5 元，余额：4.31 元 
第3个红包：0.81 元，余额：3.5 元 
第4个红包：0.89 元，余额：2.61 元 
第5个红包：1.15 元，余额：1.46 元 
第6个红包：1.2 元，余额：0.26 元 
第7个红包：0.03 元，余额：0.23 元 
第8个红包：0.23 元，余额：0 元
----》》》》改良一下，将平均值作为随机安全上限来控制波动差
header("Content-Type: text/html;charset=utf-8");  
$total=10;//红包总额  
$num=8;// 分成8个红包，支持8人随机领取  
$min=0.01;//每个人最少能收到0.01元  
for ($i=1;$i<$num;$i++)  
{  
    $safe_total=($total-($num-$i)*$min)/($num-$i);//随机安全上限  
    $money=mt_rand($min*100,$safe_total*100)/100;  
    $total=$total-$money;  
    echo '第'.$i.'个红包：'.$money.' 元，余额：'.$total.' 元 <br/>';  
}  
echo '第'.$num.'个红包：'.$total.' 元，余额：0 元';

结果为：
第1个红包：0.77 元，余额：9.23 元 
第2个红包：0.3 元，余额：8.93 元 
第3个红包：1.41 元，余额：7.52 元 
第4个红包：1.42 元，余额：6.1 元 
第5个红包：0.55 元，余额：5.55 元 
第6个红包：2.45 元，余额：3.1 元 
第7个红包：1.08 元，余额：2.02 元 
第8个红包：2.02 元，余额：0 元



很多牛逼的工具，就在这里：
http://justcoding.iteye.com/blog/2186554


++++++php中extract()函数++++++
将数组中的键名作为变量，键值作为值的转换方法！
对于数组中的每个元素，键名用于变量名，键值用于变量值
$a = 'Original';  
$my_array = array("a" => "Cat","b" => "Dog", "c" => "Horse");  
extract($my_array);  
echo "\$a = $a; \$b = $b; \$c = $c"; 
结果是：
$a = Cat; $b = Dog; $c = Horse


+++++++++哈希算法加密+++++++
$pwd = "123456";  
$hash = password_hash($pwd, PASSWORD_DEFAULT);  
echo $hash; 



++++++++PHP把阿拉伯数字转化为中文汉字(大、小写)++++++++
function number2Chinese($num, $m = 1) {  
    switch($m) {  
        case 0:  
            $CNum = array(  
                        array('零','壹','贰','叁','肆','伍','陆','柒','捌','玖'),  
                        array('','拾','佰','仟'),  
                        array('','萬','億','萬億')  
                    );  
            break;  
        default:  
            $CNum = array(  
                    array('零','一','二','三','四','五','六','七','八','九'),  
                    array('','十','百','千'),  
                    array('','万','亿','万亿')  
            );  
            break;  
    }  
        
    // $cNum = array('零','一','二','三','四','五','六','七','八','九');  
   
    if (is_integer($num)) {  
        $int = (string)$num;  
    } else if (is_numeric($num)) {  
        $num = explode('.', (string)floatval($num));  
        $int = $num[0];  
        $fl  = isset($num[1]) ? $num[1] : FALSE;  
    }  
        
    // 长度  
    $len = strlen($int);  
        
    // <a href="http://www.sharetk.com/" target="_blank"><u>中文</u></a>  
    $chinese = array();  
   
    // 反转的<a href="http://www.sharetk.com/" target="_blank"><u>数字</u></a>  
    $str = strrev($int);  
        
    for($i = 0; $i<$len; $i+=4 ) {  
        $s = array(0=>$str[$i], 1=>$str[$i+1], 2=>$str[$i+2], 3=>$str[$i+3]);  
            
        $j = '';  
        // 千位  
        if ($s[3] !== '') {  
            $s[3] = (int) $s[3];  
            if ($s[3] !== 0) {  
                $j .= $CNum[0][$s[3]].$CNum[1][3];  
            } else {  
                if ($s[2] != 0 || $s[1] != 0 || $s[0]!=0) {  
                    $j .= $CNum[0][0];  
                }  
            }  
        }  
        // 百位  
        if ($s[2] !== '') {  
            $s[2] = (int) $s[2];  
            if ($s[2] !== 0) {  
                $j .= $CNum[0][$s[2]].$CNum[1][2];  
            } else {  
                if ($s[3]!=0 && ($s[1] != 0 || $s[0]!=0) ) {  
                    $j .= $CNum[0][0];  
                }  
            }  
        }  
        // 十位  
        if ($s[1] !== '') {  
            $s[1] = (int) $s[1];  
            if ($s[1] !== 0) {  
                $j .= $CNum[0][$s[1]].$CNum[1][1];  
            } else {  
                if ($s[0]!=0 && $s[2] != 0) {  
                    $j .= $CNum[0][$s[1]];  
                }  
            }  
        }  
        // 个位  
        if ($s[0] !== '') {  
            $s[0] = (int) $s[0];  
            if ($s[0] !== 0) {  
                $j .= $CNum[0][$s[0]].$CNum[1][0];  
            } else {  
                    
                // $j .= $CNum[0][0];  
                    
            }  
        }  
            
        $j.=$CNum[2][$i/4];  
        array_unshift($chinese, $j);  
    }  
        
    $chs = implode('', $chinese);  
        
    if ($fl) {  
        $chs .= '点';  
        for($i=0,$j=strlen($fl); $i<$j; $i++) {  
            $t = (int)$fl[$i];  
            $chs.= $str[0][$t];  
        }  
    }          
    return $chs;  
}   


++++php生成唯一会员卡号+++++++
class Code {           //进行进制转换，10进制转36进制
    //密码字典   
    private $dic = array(   
        0=>'0',    1=>'1', 2=>'2', 3=>'3', 4=>'4', 5=>'5', 6=>'6', 7=>'7', 8=>'8',       
        9=>'9', 10=>'A',  11=>'B', 12=>'C', 13=>'D', 14=>'E', 15=>'F',  16=>'G',  17=>'H',       
        18=>'I',19=>'J',  20=>'K', 21=>'L',  22=>'M',  23=>'N', 24=>'O', 25=>'P', 26=>'Q',       
    27=>'R',28=>'S',  29=>'T',  30=>'U', 31=>'V',  32=>'W',  33=>'X', 34=>'Y', 35=>'Z'   
    );   
    public function encodeID($int, $format=8) {   
        $dics = $this->dic;   
        $dnum = 36; //进制数   
        $arr = array ();   
        $loop = true;   
        while ($loop) {   
            $arr[] = $dics[bcmod($int, $dnum)];   
            $int = bcdiv($int, $dnum, 0);   
            if ($int == '0') {   
                $loop = false;   
            }   
        }   
        if (count($arr) < $format)   
            $arr = array_pad($arr, $format, $dics[0]);   
   
        return implode('', array_reverse($arr));   
    }      
    public function decodeID($ids) {   
        $dics = $this->dic;   
        $dnum = 36; //进制数   
        //键值交换   
        $dedic = array_flip($dics);   
        //去零   
        $id = ltrim($ids, $dics[0]);   
        //反转   
        $id = strrev($id);   
        $v = 0;   
        for ($i = 0, $j = strlen($id); $i < $j; $i++) {   
            $v = bcadd(bcmul($dedic[$id {   
                $i }   
            ], bcpow($dnum, $i, 0), 0), $v, 0);   
        }   
        return $v;   
    }   
}  
$code = new Code();   
$card_no = $code->encodeID(888888,5); 
$card_pre = '756';     //改这里
$card_vc = substr(md5($card_pre.$card_no),0,2);   
$card_vc = strtoupper($card_vc);   
echo $card_pre.$card_no.$card_vc;   


++++++php制作二维码++++++   该文件在 -》工具包 -》phpqrcode
include "./phpqrcode/phpqrcode.php"; 
$value="Jason"; 
$errorCorrectionLevel = "L"; 
$matrixPointSize = "4"; 
QRcode::png($value, false, $errorCorrectionLevel, $matrixPointSize); 
exit; 



+++++++PHP无限极分类生成树方法无限分级++++++
function generateTree($items){  
    $tree = array();  
    foreach($items as $item){  
        if(isset($items[$item['pid']])){  
            $items[$item['pid']]['son'][] = &$items[$item['id']];  
        }else{  
            $tree[] = &$items[$item['id']];  
        }  
    }  
    return $tree;  
}  
$items = array(  
    1 => array('id' => 1, 'pid' => 0, 'name' => '安徽省'),  
    2 => array('id' => 2, 'pid' => 0, 'name' => '浙江省'),  
    3 => array('id' => 3, 'pid' => 1, 'name' => '合肥市'),  
    4 => array('id' => 4, 'pid' => 3, 'name' => '长丰县'),  
    5 => array('id' => 5, 'pid' => 1, 'name' => '安庆市'),  
);  
print_r(generateTree($items));  


+++++++php文件下载++++++++++
  $file_name = "test.jpg";  
    $file_dir = "./";  
    //检查文件是否存在  
    if(!file_exists($file_dir . $file_name)){
	  echo "没有文件";exit;
	}
    else   
    {  
        $file = fopen($file_dir . $file_name,"r"); // 打开文件   
        Header("Content-type: application/octet-stream");  
        Header("Accept-Ranges: bytes");  
        Header("Accept-Length: ".filesize($file_dir . $file_name));  
        Header("Content-Disposition: attachment; filename=" . $file_name);  // 输出文件内容          
        echo fread($file,filesize($file_dir . $file_name));  
        fclose($file);  
    }  


++++php反盗链类++++++++
<?php  
$ADMIN[defaulturl] = "test.gif";//盗链返回的地址  
$okaysites = array("http://www.deographics.com/","http://deographics.com/");  //白名单    
$ADMIN[url_1] = "http://deographics.com/";//下载地点1  
$ADMIN[url_2] = ""; //下载地点2，以此类推  
   
$reffer = $HTTP_REFERER;  
  
if($reffer) {  
    $yes = 0;  
    while(list($domain, $subarray) = each($okaysites)) {  
        if (ereg($subarray,"$reffer")) {  
            $yes = 1;  
        }  
    }  
  
    $theu = "url"."_"."$site";  
  
    if ($ADMIN[$theu] AND $yes == 1) {  
        header("Location: $ADMIN[$theu]/$file");  
    } else {  
        header("Location: $ADMIN[defaulturl]");  
    }  
} else {  
    header("Location: $ADMIN[defaulturl]");  
}  


+++++PHP生成网页快照+++++++
<?php  
$url = 'http://www.baidu.com/'; //抓取百度  
echo snapshot($url);  //输出结果为图片地址  
echo snapshot($url, './baidu.png'); //将图片保存至本地baidu.png, 输出内容图片大小  
  
/** 
 * 生成网页快照 
 * @param   string  $site   目标地址 
 * @param   string  $path   保存地址, 为空则不保存 
 * @param   integer $dealy  延迟 
 * @return  mixed   根据参数返回 
 */  
function snapshot($site, $path = '', $dealy = 0)  
{  
    $url   = 'http://ppt.cc/yo2/catch.php';  
    $query = 'url=' . $site . '&delay=' . $dealy . '&rnd=' . mt_rand(1, 9);  
    $ch    = curl_init($url);  
    curl_setopt($ch, CURLOPT_POST, true);  
    curl_setopt($ch, CURLOPT_POSTFIELDS, $query);  
    curl_setopt($ch, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT']);  
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);  
    $data = curl_exec($ch);  
    curl_close($ch);  
  
  
    if (strlen($data) != 32) {  
        exit('无效网址');  
    }  
  
  
    $file = $data{0} . '/' . $data{1} . '/' . $data{2} . '/';  
    $file = 'http://cache.ppt.cc/' . $file . 'src_' . $data . '.png';  
  
  
    if (!emptyempty($path)) {  
        $data = file_get_contents($file);  
        return file_put_contents($path, $data);  
    }  
    return $file;  
}  


+++++用PHP解决“约瑟夫环”的2种方法++++++
“约瑟夫环”是一个数学的应用问题：一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，
数到第m只,把它踢出圈，从它后面再开始数， 再数到第m只，在把它踢出去…，如此不停的进行下去，
 直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后
那个大王的编号。
1———》》》
function killMonkey($monkeys , $m , $current = 0){
    $number = count($monkeys);
    $num = 1;
    if(count($monkeys) == 1){
        echo $monkeys[0]."成为猴王了";
        return;
    }
    else{
        while($num++ < $m){
            $current++ ;
            $current = $current%$number;
        }
        echo $monkeys[$current]."的猴子被踢掉了<br/>";
        array_splice($monkeys , $current , 1);
        killMonkey($monkeys , $m , $current);
    }
}
$monkeys = array(1 , 2 , 3 , 4 , 5 , 6 , 7, 8 , 9 , 10); //monkeys的编号
$m = 3; //数到第几只猴子被踢出
killMonkey($monkeys , $m);
2———》》》
最后这个算法最牛，有网友给了解释：
哦，是这样的，每个猴子出列后，剩下的猴子又组成了另一个子问题。只是他们的编号变化了。第一个
出列的猴子肯定是a[1]=m(mod)n(m/n的余数)，他除去后剩下的猴子是a[1]+1,a[1]+2,…,n,1,2,…a[1]-2,a[1]-1，
对应的新编号是1,2,3…n-1。设此时某个猴子的新编号是i，他原来的编号就是(i+a[1])%n。
于是，这便形成了一个递归问题。假如知道了这个子问题(n-1个猴子)的解是x，
那么原问题(n个猴子)的解便是：(x+m%n)%n=(x+m)%n。问题的起始条件：如果n=1,那么结果就是1。
function yuesefu($n,$m) {  
    $r=0;  
    for($i=2; $i<=$n; $i++) {
        $r=($r+$m)%$i;  
    }
    return $r+1;  
}  
echo yuesefu(10,3)."是猴王";


++++++php按每日时间段生成固定随机数小功能+++++
//获取指定日期直接的天数
function numday($e='',$s=''){
	$startdate=strtotime($s);
	$enddate=strtotime($e);
	$days=round(($enddate-$startdate)/3600/24)+1;
	return $days;
}
//获取前一天的日期
function qiant($t){
	$s = date('Y-m-d',strtotime($t)-(3600*24));
	return $s;
}
//根据日期产生固定随机数
function suiji($a,$t){
	$num = date('j',strtotime($t));
	if(is_even($num)){
		if($num>($a/3)){
		$n = round($num/3) + $a;
		}else{
			$n = $num + $a;
		}
	}else{
		if($num>($a/3)){
			$n = $a - round($num/3);
		}else{
			$n = $a - $num;
		}
	}
	return $n;
}
//判断是否为偶数
function is_even($num){
     return (is_numeric($num)&(!($num&1)));
 }
$num       = 1000;//总数
$startTime = '2015-12-01';
$endTime   = '2015-12-09';
$onceNum   ='';//每天限制多少左右，不写，按总数除以天生的平均值左右
//$time = date('Y-m-d',time());
$time = '2015-12-02';
$sy = 0;//剩余
$jr = 0;//今日
$zr = 0;//昨日
if(''==$onceNum){
	$numday = numday($endTime,$startTime);
	$onceNum = round($num/$numday);
}
if($time<$startTime){
	$sy = $num;
	$jr = 0;
	$zr = 0;
}elseif($startTime==$time){
	$jr = suiji($onceNum,$time);
	$sy = $num - $jr;
	$zr = 0;
}elseif($startTime==qiant($time)){
	$jr = suiji($onceNum,$time);
	$zr = suiji($onceNum,qiant($time));
	$sy = $num-$jr-$zr;
}elseif($time<=$endTime){
	!empty($numday)?$numday=$numday:$numday =numday($endTime,$startTime);
	$sy = $num-round($num/$numday)*(numday($time,$startTime))+suiji(10,$time);
	$jr = suiji($onceNum,$time);
	$zr = suiji($onceNum,qiant($time));
}elseif($endTime==qiant($time)){
	$sy = 0;
	$jr = 0;
	$zr = suiji($onceNum,qiant($time));
}else{
	$sy = $jr =$zr=0;
}
$sy<0?$sy=60:$sy=$sy;
echo '<br />剩余'.$sy.'-今日'.$jr.'-昨日'.$zr;


+++php字符加密算法++++++
function caesar_encode($s, $k) {
  $k = "$k";
  for($i=0; $i<strlen($k); $i++) {
    $d = base_convert($k{$i}, 36, 10);
    $t = '';
    for($j=0; $j<strlen($s); $j++)
      $t .= base_convert((base_convert($s{$j}, 36, 10)+$d)%36, 10, 36);
    $s = $t;
  }
  return $t;
 }
function caesar_decode($s, $k) {
  $k = "$k";
  for($i=0; $i<strlen($k); $i++) {
    $d = 36 - base_convert($k{$i}, 36, 10);
    $t = '';
    for($j=0; $j<strlen($s); $j++)
      $t .= base_convert((base_convert($s{$j}, 36, 10)+$d)%36, 10, 36);
    $s = $t;
  }
  return $t;
}
$key = '12345';
$s = caesar_encode('test', $key);
echo "$s\n";
echo caesar_decode($s, $key);


+++++php计算当前在线的人数+++++
<?php
//首先你要有读写文件的权限
//本程序可以直接运行,第一次报错,以后就可以了，当然也可以屏蔽一下错误
$online_log = "count.dat"; //保存人数的文件,
$timeout = 30;//30秒内没动作者,认为掉线
$entries = file($online_log);

$temp = array();

for ($i=0;$i<count($entries);$i++) {
$entry = explode(",",trim($entries[$i]));
if (($entry[0] != getenv('REMOTE_ADDR')) && ($entry[1] > time())) {
array_push($temp,$entry[0].",".$entry[1]."\n"); //取出其他浏览者的信息,并去掉超时者,保存进$temp
}
}

array_push($temp,getenv('REMOTE_ADDR').",".(time() + ($timeout))."\n"); //更新浏览者的时间
$users_online = count($temp); //计算在线人数

$entries = implode("",$temp);
//写入文件
$fp = fopen($online_log,"w");
flock($fp,LOCK_EX); //flock() 不能在NFS以及其他的一些网络文件系统中正常工作
fputs($fp,$entries);
flock($fp,LOCK_UN);
fclose($fp);
echo "当前有".$users_online."人在线";


+++php实现穷举法+++++
<?php
function createpassword(){
	$passwordmax=8;
	$a="0123456789abcdefghijklmnopqrstuvwxyz";//可能的字符
	$ndictcount=strlen($a);
	$cpass=array();$arrIndex=array();
	$nminl=1;$nmaxl=3;//本例中密码长度从1-3
	$nlength=$nminl;
	assert($nminl<=$nmaxl && $nmaxl<=$passwordmax);
	$fp=fopen("e:\\dict.txt","w");
	while($nlength<=$nmaxl)
	{
		for($i=0;$i<$passwordmax;$i++)$arrIndex[$i]=0;
		$bnext=true;
		while($bnext){
			for($i=0;$i<$nlength;$i++)$cpass[$i]=$a[$arrIndex[$i]];
			fwrite($fp,implode($cpass,"")."\r\n");
			for($j=$nlength-1;$j>=0;$j--){
				//密码指针进位
				$arrIndex[$j]++; 
				if($arrIndex[$j]!=$ndictcount)
					break;
				else{
					$arrIndex[$j]=0;
					if($j==0)$bnext=false;
				}
			} 
		}
		$nlength++;
	}
	fclose($fp);
	echo "OK";
}
createpassword();
?>


++++php防止XSS攻击++++++
XSS 全称为 Cross Site Scripting，用户在表单中有意或无意输入一些恶意字符，从而破坏页面的表现！
看看常见的恶意字符XSS 输入：
1.XSS 输入通常包含 JavaScript 脚本，如弹出恶意警告框：<script>alert("XSS");</script>
2.XSS 输入也可能是 HTML 代码段，譬如：
(1).网页不停地刷新 <meta http-equiv="refresh" content="0;">
(2).嵌入其它网站的链接 <iframe src=http://www.qq.com width=250 height=250></iframe>
<?PHP
/**
* @blog http://www.phpddt.com
* @param $string
* @param $low 安全别级低
*/
function clean_xss(&$string, $low = False)
{
if (! is_array ( $string ))
{
$string = trim ( $string );
$string = strip_tags ( $string );
$string = htmlspecialchars ( $string );
if ($low)
{
return True;
}
$string = str_replace ( array ('"', "\\", "'", "/", "..", "../", "./", "//" ), '', $string );
$no = '/%0[0-8bcef]/';
$string = preg_replace ( $no, '', $string );
$no = '/%1[0-9a-f]/';
$string = preg_replace ( $no, '', $string );
$no = '/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]+/S';
$string = preg_replace ( $no, '', $string );
return True;
}
$keys = array_keys ( $string );
foreach ( $keys as $key )
{
clean_xss ( $string [$key] );
}
}
//just a test
$str = 'phpddt.com<meta http-equiv="refresh" content="0;">';
clean_xss($str); //如果你把这个注释掉，你就知道xss攻击的厉害了
echo $str;
?>
通过clean_xss()就过滤了恶意内容！


+++++array_multisort()函数多维数组排序+++++++
function my_sort($arrays,$sort_key,$sort_order=SORT_ASC,$sort_type=SORT_NUMERIC ){
 if(is_array($arrays)){
 foreach ($arrays as $array){
 if(is_array($array)){
 $key_arrays[] = $array[$sort_key];
 }else{
 return false;
 }
 }
 }else{
 return false;
 }
 array_multisort($key_arrays,$sort_order,$sort_type,$arrays);
 return $arrays;
 }
 $person = array(
 array('id'=>1,'name'=>'fj','weight'=>180,'height'=>110),
 array('id'=>2,'name'=>'tom','weight'=>53,'height'=>150),
 array('id'=>3,'name'=>'jerry','weight'=>120,'height'=>156),
 array('id'=>4,'name'=>'bill','weight'=>110,'height'=>190),
 array('id'=>5,'name'=>'linken','weight'=>80,'height'=>200),
 array('id'=>6,'name'=>'adana','weight'=>95,'height'=>110),
 array('id'=>7,'name'=>'jordan','weight'=>70,'height'=>170)
 );
//person1通过对name值按照a、b、c升序的方法进行排序
$person1= my_sort($person,'name',SORT_ASC,SORT_STRING);
var_dump($person1);
//person2通过weight的数字升序进行排序，如果想按照从大到小排序，这里增加一个SORT_DESC参数即可，即：my_sort($person,'weight','SORT_DESC')此方法模式是升序（SORT_ASC）
$person2= my_sort($person,'weight');
var_dump($person2);


+++++PHP的echo输出内容过多会很慢++++++
早在2003年就有前辈认为通过echo输出大字符串到客户端会引起服务器的性能问题，据我测试，
在这个场景下使用print其实也是一样的慢。建议的解决办法是把字符串切割成更小的字符串输出，
展现速度会有提升，输出函数如下：
<?php
//对大字节字符串进行分割保存到数组中，然后循环输出
function echoBigChar($string,$bufferSize=8192){
    $splitString=str_split($string,$bufferSize);
    foreach($splitString as $chunk){
        echo $chunk;
    }
}
但是上面的处方不太对症，整个echobig的输出时间仍然在400毫秒左右，没有太大改善。考虑到是输出
大量内容到客户端比较慢，于是检查了apache的配置，原来还没打开deflate进行压缩，遂启用之。
再次使用xhprof进行检查，这条echo的输出时间降低到5ms左右。400ms到5ms
，一个配置问题会产生80倍的差距，还真是省老钱了。


++++++取得客户端的ip、地理信息、浏览器、本地真实IP++++++
//作用取得客户端的ip、地理信息、浏览器、本地真实IP
 class get_gust_info { 
  ////获得访客浏览器类型
  function GetBrowser(){
   if(!empty($_SERVER['HTTP_USER_AGENT'])){
    $br = $_SERVER['HTTP_USER_AGENT'];
    if (preg_match('/MSIE/i',$br)) {    
               $br = 'MSIE';
             }elseif (preg_match('/Firefox/i',$br)) {
     $br = 'Firefox';
    }elseif (preg_match('/Chrome/i',$br)) {
     $br = 'Chrome';
       }elseif (preg_match('/Safari/i',$br)) {
     $br = 'Safari';
    }elseif (preg_match('/Opera/i',$br)) {
        $br = 'Opera';
    }else {
        $br = 'Other';
    }
    return $br;
   }else{return "获取浏览器信息失败！";} 
  }
  ////获得访客浏览器语言
  function GetLang(){
   if(!empty($_SERVER['HTTP_ACCEPT_LANGUAGE'])){
    $lang = $_SERVER['HTTP_ACCEPT_LANGUAGE'];
    $lang = substr($lang,0,5);
    if(preg_match("/zh-cn/i",$lang)){
     $lang = "简体中文";
    }elseif(preg_match("/zh/i",$lang)){
     $lang = "繁体中文";
    }else{
        $lang = "English";
    }
    return $lang; 
   }else{return "获取浏览器语言失败！";}
  }
   ////获取访客操作系统
  function GetOs(){
   if(!empty($_SERVER['HTTP_USER_AGENT'])){
    $OS = $_SERVER['HTTP_USER_AGENT'];
      if (preg_match('/win/i',$OS)) {
     $OS = 'Windows';
    }elseif (preg_match('/mac/i',$OS)) {
     $OS = 'MAC';
    }elseif (preg_match('/linux/i',$OS)) {
     $OS = 'Linux';
    }elseif (preg_match('/unix/i',$OS)) {
     $OS = 'Unix';
    }elseif (preg_match('/bsd/i',$OS)) {
     $OS = 'BSD';
    }else {
     $OS = 'Other';
    }
          return $OS;  
   }else{return "获取访客操作系统信息失败！";}   
  }
  ////获得访客真实ip
  function Getip(){
   if(!empty($_SERVER["HTTP_CLIENT_IP"])){   
      $ip = $_SERVER["HTTP_CLIENT_IP"];
   }
   if(!empty($_SERVER['HTTP_X_FORWARDED_FOR'])){ //获取代理ip
    $ips = explode(',',$_SERVER['HTTP_X_FORWARDED_FOR']);
   }
   if($ip){
      $ips = array_unshift($ips,$ip); 
   }
   $count = count($ips);
   for($i=0;$i<$count;$i++){   
     if(!preg_match("/^(10|172\.16|192\.168)\./i",$ips[$i])){//排除局域网ip
      $ip = $ips[$i];
      break;    
      }  
   }  
   $tip = empty($_SERVER['REMOTE_ADDR']) ? $ip : $_SERVER['REMOTE_ADDR']; 
   if($tip=="127.0.0.1"){ //获得本地真实IP
      return $this->get_onlineip();   
   }else{
      return $tip; 
   }
  }
  ////获得本地真实IP
  function get_onlineip() {
      $mip = file_get_contents("http://city.ip138.com/city0.asp");
       if($mip){
           preg_match("/\[.*\]/",$mip,$sip);
           $p = array("/\[/","/\]/");
           return preg_replace($p,"",$sip[0]);
       }else{return "获取本地IP失败！";}
   }
  ////根据ip获得访客所在地地名
  function Getaddress($ip=''){
   if(empty($ip)){
       $ip = $this->Getip();    
   }
   $ipadd = file_get_contents("http://int.dpool.sina.com.cn/iplookup/iplookup.php?ip=".$ip);//根据新浪api接口获取
   if($ipadd){
    $charset = iconv("gbk","utf-8",$ipadd);   
    preg_match_all("/[\x{4e00}-\x{9fa5}]+/u",$charset,$ipadds);
    return $ipadds;   //返回一个二维数组
   }else{return "addree is none";}  
  } 
 }
 $gifo = new get_gust_info();
 echo "你的ip:".$gifo->Getip();
 echo "<br/>所在地：";
 $ipadds = $gifo->Getaddress();
 foreach($ipadds[0] as $value){
     echo "\r\n    ".iconv("utf-8","gbk",$value);    
 }
 echo "<br/>浏览器类型：".$gifo->GetBrowser();
 echo "<br/>浏览器语言：".$gifo->GetLang();
 echo "<br/>操作系统：".$gifo->GetOs();


++++++PHP将一个字符串带有中文转换成数组，支持中文+++++
function strToArray($string) {
    $strlen = mb_strlen($string);
    while ($strlen) {
        $array[] = mb_substr($string, 0, 1, "utf8");
        $string = mb_substr($string, 1, $strlen, "utf8");
        $strlen = mb_strlen($string);
    }
    return $array;
}
$string = '这里就是要转换成数组的字符串';
$arr = strToArray($string);
print_r($arr);


+++++PHP检测url地址是否被百度收录+++++++
/**
 * PHP检测url地址是否被百度收录
 * @param string    $url 要检测的URL地址
 */
function checkBaidu($url) { 
    $url = 'http://www.baidu.com/s?wd=' . urlencode($url); 
    $curl = curl_init(); 
    curl_setopt($curl, CURLOPT_URL, $url); 
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); 
    $rs = curl_exec($curl); 
    curl_close($curl); 
    if (!strpos($rs, '没有找到')) { //没有找到说明已被百度收录 
        return 1; 
    } else { 
        return -1; 
    } 
 }
$url = 'http://liqingbo.cn/blog-385.html'; 
echo checkBaidu($url);    //如果输出1表示已经收录，-1表示没收录


++++++PHP多进程协作编程之-socket+++++++
<?php
//a.php
function runThread(){
$fp = fsockopen('127.0.0.1', 82, $errno, $errmsg);
fputs($fp, "GET /a.php?act=b/r/n"); //这里的第二个参数是HTTP协议中规定的请求头
//不明白的请看RFC中的定义
fclose($fp);
}
function a(){
$fp = fopen('result_a.log', 'w');
fputs($fp, 'Set in ' . Date('h:i:s', time()) . (double)microtime() . "/r/n");
fclose($fp);
}
function b(){
$fp = fopen('result_b.log', 'w');
fputs($fp, 'Set in ' . Date('h:i:s', time()) . (double)microtime() . "/r/n");
fclose($fp);
}
if(!isset($_GET['act'])) $_GET['act'] = 'a';
if($_GET['act'] == 'a')
{
runThread();
a();
echo 'ok';
}
else if($_GET['act'] == 'b') {
b();
}
?>


+++++PHP不用第三个变量交换两个变量的值的几种方法+++++
方法一：使用字符串截取
<?php
$a = "fsdfds";
$b = "xiaorui";
$a = $a.$b;
$b = substr($a,0,strlen($a)-strlen($b));
$a = substr($a,strlen($b));
echo $a."-".$b;
?>
方法二：使用list()
<?php
$a = "fsdfds";
$b = "xiaorui";
list($a,$b) = array($b,$a);
echo $a."-".$b;
?>
方法三：使用数组分割
<?php
$a = "fsdfds";
$b = "xiaorui";
$b = $a."#$".$b;
$b = explode("#$",$b);
$a = $b[1];
$b = $b[0];
echo $a."-".$b;
?>
方法四：使用异或运算
<?php
$a = "fsdfds";
$b = "xiaorui";
$a = $a^$b;
$b = $b^$a;
$a = $a^$b;
echo $a."-".$b;
?>


++++++php将数据表中的数据导出到excel表++++++
<?php
	header("Content-type:application/vnd.ms-excel");
	header("Content-Disposition:filename=xls_region.xls");
	$cfg_dbhost = 'localhost';
	$cfg_dbname = 'testdb';
	$cfg_dbuser = 'root';
	$cfg_dbpwd = 'root';
	$cfg_db_language = 'utf8';
	// END 配置
	//链接数据库
	$link = mysql_connect($cfg_dbhost,$cfg_dbuser,$cfg_dbpwd);
	mysql_select_db($cfg_dbname);
	//选择编码
	mysql_query("set names ".$cfg_db_language);
	//users表
	$sql = "desc users";
	
	$res = mysql_query($sql);
	echo "<table><tr>";
	//导出表头（也就是表中拥有的字段）
	while($row = mysql_fetch_array($res)){
		$t_field[] = $row['Field'];	//Field中的F要大写，否则没有结果
		echo "<th>".$row['Field']."</th>";
	}
	echo "</tr>";
	//导出100条数据
	$sql = "select * from users limit 100";
	$res = mysql_query($sql);
	while($row = mysql_fetch_array($res)){
		echo "<tr>";
		foreach($t_field as $f_key){
			echo "<td>".$row[$f_key]."</td>";
		}
		echo "</tr>";
	}
	echo "</table>";
?>



++++php文件查找器源码查找本地文件+++++
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>php版文件查找（file search）</title>
	</head>
	<body>
		<form action="" method="post">
		<p> 文件查找（注：区分大小写）</p>
		<p>路径：<input type="text" name="path" /></p>
		<p>查找：<input type="text" name="key" /></p>
		<p><input type="submit" name="sub" value=" 开 始 " /></p>
		</form>
	</body>
</html>
<?php
/*
 * 注：区分大小写
 * by: http://www.daixiaorui.com
 */
if(!empty($_POST['path'])&&!empty($_POST['key'])){
	echo "在路径 ".$_POST['path']."/ 中查找 ".$_POST['key']." 的结果为：<hr/>";
	$file_num = $dir_num = 0;
	$r_file_num = $r_dir_num= 0;
	$findFile = $_POST['key'];
	function delDirAndFile( $dirName ){	
		if ( $handle = @opendir( "$dirName" ) ) {
			while ( false !== ( $item = readdir( $handle ) ) ) {  
				if ( $item != "." && $item != ".." ) {  
					if ( is_dir( "$dirName/$item" ) ) {  
						delDirAndFile( "$dirName/$item" );
					} else {  
						$GLOBALS['file_num']++;
						if(strstr($item,$GLOBALS['findFile'])){
							echo " <span><b> $dirName/$item </b></span><br />\n";
							$GLOBALS['r_file_num']++;
						}
					}  
				}
			}
			closedir( $handle );  
			$GLOBALS['dir_num']++;
			if(strstr($dirName,$GLOBALS['findFile'])){
				$loop = explode($GLOBALS['findFile'],$dirName);
				$countArr = count($loop)-1;
				if(empty($loop[$countArr])){
					echo " <span style='color:#297C79;'><b> $dirName </b></span><br />\n";
					$GLOBALS['r_dir_num']++;
				}
			}
		}else{
			die("没有此路径！");
		}
	}

	delDirAndFile($_POST['path']);
	echo "<hr/>本次共搜索到".$file_num."个文件，文件夹".$dir_num."个<br/>";
	echo "<hr/>符合结果的共".$r_file_num."个文件，文件夹".$r_dir_num."个<br/>";
}
?>
 


+++++php实现数据库备份导出成sql+++++++
<?php
	header("Content-type:text/html;charset=utf-8");
	//配置信息
	$cfg_dbhost = 'localhost';
	$cfg_dbname = 'ftdm';
	$cfg_dbuser = 'root';
	$cfg_dbpwd = 'root';
	$cfg_db_language = 'utf8';
	$to_file_name = "ftdm.sql";
	// END 配置
	//链接数据库
	$link = mysql_connect($cfg_dbhost,$cfg_dbuser,$cfg_dbpwd);
	mysql_select_db($cfg_dbname);
	//选择编码
	mysql_query("set names ".$cfg_db_language);
	//数据库中有哪些表
	$tables = mysql_list_tables($cfg_dbname);
	//将这些表记录到一个数组
	$tabList = array();
	while($row = mysql_fetch_row($tables)){
		$tabList[] = $row[0];
	}
	echo "运行中，请耐心等待...<br/>";
	$info = "-- ----------------------------\r\n";
	$info .= "-- 日期：".date("Y-m-d H:i:s",time())."\r\n";
	$info .= "-- Power by 代潇瑞博客(http://www.daixiaorui.com/read/34.html)\r\n";
	$info .= "-- 仅用于测试和学习,本程序不适合处理超大量数据\r\n";
	$info .= "-- ----------------------------\r\n\r\n";
	file_put_contents($to_file_name,$info,FILE_APPEND);
	//将每个表的表结构导出到文件
	foreach($tabList as $val){
		$sql = "show create table ".$val;
		$res = mysql_query($sql,$link);
		$row = mysql_fetch_array($res);
		$info = "-- ----------------------------\r\n";
		$info .= "-- Table structure for `".$val."`\r\n";
		$info .= "-- ----------------------------\r\n";
		$info .= "DROP TABLE IF EXISTS `".$val."`;\r\n";
		$sqlStr = $info.$row[1].";\r\n\r\n";
		//追加到文件
		file_put_contents($to_file_name,$sqlStr,FILE_APPEND);
		//释放资源
		mysql_free_result($res);
	}
	//将每个表的数据导出到文件
	foreach($tabList as $val){
		$sql = "select * from ".$val;
		$res = mysql_query($sql,$link);
		//如果表中没有数据，则继续下一张表
		if(mysql_num_rows($res)<1) continue;
		//
		$info = "-- ----------------------------\r\n";
		$info .= "-- Records for `".$val."`\r\n";
		$info .= "-- ----------------------------\r\n";
		file_put_contents($to_file_name,$info,FILE_APPEND);
		//读取数据
		while($row = mysql_fetch_row($res)){
			$sqlStr = "INSERT INTO `".$val."` VALUES (";
			foreach($row as $zd){
				$sqlStr .= "'".$zd."', ";
			}
			//去掉最后一个逗号和空格
			$sqlStr = substr($sqlStr,0,strlen($sqlStr)-2);
			$sqlStr .= ");\r\n";
			file_put_contents($to_file_name,$sqlStr,FILE_APPEND);
		}
		//释放资源
		mysql_free_result($res);
		file_put_contents($to_file_name,"\r\n",FILE_APPEND);
	}
	echo "OK!";
?>



+++php计算程序网页的运行时间++++++
<?php		
	//程序运行时间
	$starttime = explode(' ',microtime());
	echo microtime();
	/*········以下是代码区·········*/
	for($i=0;$i<1000000;$i++){
		$i;
	}
	/*········以上是代码区·········*/
	//程序运行时间
	$endtime = explode(' ',microtime());
	$thistime = $endtime[0]+$endtime[1]-($starttime[0]+$starttime[1]);
	$thistime = round($thistime,3);
	echo "本网页执行耗时：".$thistime." 秒。".time();
?>


+++++PHP根据经纬度计算两地距离++++++++
<?php
    //根据经纬度计算两地距离
    function getDistance($lat1, $lng1, $lat2, $lng2){
        $r = 6378.137;  //地球半径
        //角度转为弧度
        $radLat1 = deg2rad($lat1);
        $radLat2 = deg2rad($lat2);
        $radLng1 = deg2rad($lng1);
        $radLng2 = deg2rad($lng2);     
        //sqrt：平方根，pow(x, n)：x的n次方的幂，asin：反正弦，sin：正弦
        $s = 2*asin(sqrt(pow(sin(($radLat1 - $radLat2)/2),2)+cos($radLat1)*cos($radLat2)*pow(sin(($radLng1-$radLng2)/2),2)))*$r;
        return $s;
    }
    //根据经纬度查地址
    function get_location($location_x,$location_y){
            $url = "http://api.map.baidu.com/geocoder/v2/?ak=GHvfRpIKsKLAgGNacrFdG8Uy&location=$location_x,$location_y&output=json&pois=0";
            $curl = curl_init();
            curl_setopt($curl, CURLOPT_URL, $url);
            curl_setopt($curl, CURLOPT_HEADER, 0);
            curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
            $data = curl_exec($curl);
            curl_close($curl);
            $res = json_decode($data,true);
            return $res;
    }
    //根据地址查经纬度
    function get_loca($address){
            $url = "http://api.map.baidu.com/geocoder/v2/?address=$address&output=json&ak=GHvfRpIKsKLAgGNacrFdG8Uy";
            $curl = curl_init();
            curl_setopt($curl, CURLOPT_URL, $url);
            curl_setopt($curl, CURLOPT_HEADER, 0);
            curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
            $data = curl_exec($curl);
            curl_close($curl);
            $res = json_decode($data,true);
            return $res;
    }




+++++PHP统计在线人数+++++++
  $filename='online.txt';//数据文件
    $cookiename='VGOTCN_OnLineCount';//cookie名称
    $onlinetime=600;//在线有效时间，单位：秒 (即600等于10分钟)
    $online=file($filename);
    //PHP file() 函数把整个文件读入一个数组中。与 file_get_contents() 类似，不同的是 file() 将文件作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内。如果失败，则返回 false
    $nowtime=$_SERVER['REQUEST_TIME'];
    $nowonline=array();
    //得到仍然有效的数据
    foreach($online as $line){
      $row=explode('|',$line);
      $sesstime=trim($row[1]);
      if(($nowtime - $sesstime)<=$onlinetime){//如果仍在有效时间内，则数据继续保存，否则被放弃不再统计
        $nowonline[$row[0]]=$sesstime;//获取在线列表到数组，会话ID为键名，最后通信时间为键值
      }
    }
    /*
    @创建访问者通信状态
    使用cookie通信
    COOKIE 将在关闭浏览器时失效，但如果不关闭浏览器，此 COOKIE 将一直有效，直到程序设置的在线时间超时
    */
    if(isset($_COOKIE[$cookiename])){//如果有COOKIE即并非初次访问则不添加人数并更新通信时间
      $uid=$_COOKIE[$cookiename];
    }else{//如果没有COOKIE即是初次访问
      $vid=0;//初始化访问者ID
      do{//给用户一个新ID
        $vid++;
        $uid='U'.$vid;
      }while(array_key_exists($uid,$nowonline));
      setcookie($cookiename,$uid);
    }
    $nowonline[$uid]=$nowtime;//更新现在的时间状态  
    //统计现在在线人数
    $total_online=count($nowonline);
    //写入数据
    if($fp=@fopen($filename,'w')){
      if(flock($fp,LOCK_EX)){
        rewind($fp);
        foreach($nowonline as $fuid=>$ftime){
          $fline=$fuid.'|'.$ftime."\n";
          @fputs($fp,$fline);
        }
        flock($fp,LOCK_UN);
        fclose($fp);
      }
    }
    echo '<script>document.write("'.$total_online.'");</script>';




+++++++PHP防止网站被攻击的应急代码+++++++
通过禁止IP频繁访问防止网站被攻击。
header('Content-type: text/html; charset=utf-8');
    $ip=$_SERVER['REMOTE_ADDR'];//获取当前访问者的ip
    $logFilePath='./log/';//日志记录文件保存目录
    $fileht='.htaccess2';//被禁止的ip记录文件
    $allowtime=60;//防刷新时间
    $allownum=5;//防刷新次数
    $allowRefresh=120;//在允许刷新次数之后加入禁止ip文件中
    if(!file_exists($fileht)){
        file_put_contents($fileht,'');
    }
    $filehtarr=@file($fileht);
    if(in_array($ip."\r\n",$filehtarr)){
        exit('警告：你的IP已经被禁止了！');
    }
    //加入禁止ip
    $time=time();
    $fileforbid=$logFilePath.'forbidchk.dat';
    if(file_exists($fileforbid)){
      if($time-filemtime($fileforbid)>30){
        @unlink($fileforbid);
      }else{
        $fileforbidarr=@file($fileforbid);
        if($ip==substr($fileforbidarr[0],0,strlen($ip))){
          if($time-substr($fileforbidarr[1],0,strlen($time))>120){
            @unlink($fileforbid);
          }else if($fileforbidarr[2]>$allowRefresh){
            file_put_contents($fileht,$ip."\r\n",FILE_APPEND);
            @unlink($fileforbid);
          }else{
            $fileforbidarr[2]++;
            file_put_contents($fileforbid,$fileforbidarr);
          }
        }
      }
    }
    //防刷新
    $str='';
    $file=$logFilePath.'ipdate.dat';
    if(!file_exists($logFilePath)&&!is_dir($logFilePath)){
      mkdir($logFilePath,0777);
    }
    if(!file_exists($file)){
      file_put_contents($file,'');
    }
    $uri=$_SERVER['REQUEST_URI'];//获取当前访问的网页文件地址
    $checkip=md5($ip);
    $checkuri=md5($uri);
    $yesno=true;
    $ipdate=@file($file);
    foreach($ipdate as $k=>$v){
      $iptem=substr($v,0,32);
      $uritem=substr($v,32,32);
      $timetem=substr($v,64,10);
      $numtem=substr($v,74);
      if($time-$timetem<$allowtime){
        if($iptem!=$checkip){
          $str.=$v;
        }else{
          $yesno=false;
          if($uritem!=$checkuri){
            $str.=$iptem.$checkuri.$time."\r\n";
          }else if($numtem<$allownum){
            $str.=$iptem.$uritem.$timetem.($numtem+1)."\r\n";
          }
          else{
            if(!file_exists($fileforbid)){
              $addforbidarr=array($ip."\r\n",time()."\r\n",1);
              file_put_contents($fileforbid,$addforbidarr);
            }
            file_put_contents($logFilePath.'forbided_ip.log',$ip.'--'.date('Y-m-d H:i:s',time()).'--'.$uri."\r\n",FILE_APPEND);
            $timepass=$timetem+$allowtime-$time;
            exit('警告：不要刷新的太频繁！');
          }
        }
      }
    }
    if($yesno){
      $str.=$checkip.$checkuri.$time."\r\n";
    }
    file_put_contents($file,$str);


+++++PHP根据设备类型自动跳转相应页面+++++
<?php
    $agent = strtolower($_SERVER['HTTP_USER_AGENT']);
    $iphone = (strpos($agent, 'iphone')) ? true : false;
    $ipad = (strpos($agent, 'ipad')) ? true : false;
    $android = (strpos($agent, 'android')) ? true : false;
    if($iphone || $ipad){
        echo "<script>window.location.href='http://www.php520.cn'</script>";
    }
    if($android){
        echo "<script>window.location.href='http://www.php520.cn/php'</script>";
    }



++++++PHP计算数组中重复出现的数据的个数+++++++
$array=array(1,2,3,4,5,6,8,5,2,3,6,3,5,2,3,6,5,2,2);
print_r($array);
echo'<hr>';
$b=array_count_values($array);//统计重复值
foreach($b as $key=>$value){
if($value>1){
echo'重复值'.'<font color=red>'.$key.'</font>'.'---------'.'重复次数'.$value.'<br>';
}
}


+++++++PHP字符串进行编码的类++++++
PHP这个类可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。
javascript中的escape()函数有类似功能。
classcoding
{
    //模仿JAVASCRIPT的ESCAPE和UNESCAPE函数的功能 
    functionunescape($str)
    {
        $text=preg_replace_callback("/%u[0-9A-Za-z]{4}/",array(
            &$this,
            'toUtf8'
        ),$str);
        returnmb_convert_encoding($text,"gb2312","utf-8");
    }
    
    functiontoUtf8($ar)
    {
        foreach($aras$val){
            $val=intval(substr($val,2),16);
            if($val<0x7F){// 0000-007F 
                $c.=chr($val);
            }elseif($val<0x800){// 0080-0800 
                $c.=chr(0xC0|($val/64));
                $c.=chr(0x80|($val%64));
            }else{// 0800-FFFF 
                $c.=chr(0xE0|(($val/64)/64));
                $c.=chr(0x80|(($val/64)%64));
                $c.=chr(0x80|($val%64));
            }
        }
        return$c;
    }
    
    functionescape($string,$encoding='gb2312')
    {
        $return='';
        for($x=0;$x<mb_strlen($string,$encoding);$x++){
            $str=mb_substr($string,$x,1,$encoding);
            if(strlen($str)>1){// 多字节字符 
                $return.='%u'.strtoupper(bin2hex(mb_convert_encoding($str,'UCS-2',$encoding)));
            }else{
                $return.='%'.strtoupper(bin2hex($str));
            }
        }
        return$return;
    }
    
    functiongb2utf8($string,$encoding='utf-8',$from_encode='gb2312')
    {
        returnmb_convert_encoding($string,$encoding,$from_encode);
    }
}



+++++PHP生成一个简单的在线日历+++++++
/**
  * PHP生成一个简单的在线日历
  *
  * @param string $language 日历语言，值为EN,表示英文，值为CN，代表中文
  * @return string 返回日历的HTML代码
  */
define("EMPTY_COLUMN","");
function php_calendar($language = 'EN')
{
    $lang = array('EN','CN');
    if (!in_array($language,$lang)) {
        $language = "EN";
    }
    
    $months = array(
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
    );
    
    $EN=array(
        'month' => array(
            'January'   => 'January', 
            'February'  => 'February',
            'March'     => 'March',
            'April'     => 'April',
            'May'       => 'May',
            'June'      => 'June',
            'July'      => 'July',
            'August'    => 'August',
            'September' =>'September',
            'October'   => 'October',
            'November'  => 'November',
            'December'  => 'December',
        ),
        'week' => array(
            'Mon' => 'Mon',
            'Tue' => 'Tue',
            'Wed' => 'Wed',
            'Thu' => 'Thu',
            'Fri' => 'Fri',
            'Sat' => 'Sat',
            'Sun' => 'Sun'
        ),
        'today'=>'today',
    );
    $CN=array(
        'month' => array(
            'January'   => '一月',
            'February'  => '二月',
            'March'     => '三月',
            'April'     => '四月',
            'May'       => '五月',
            'June'      => '六月',
            'July'      => '七月',
            'August'    => '八月',
            'September' => '九月',
            'October'   => '十月',
            'November'  => '十一月',
            'December'  => '十二月',
        ),
        'week' => array(
            'Mon' => '星期一',
            'Tue' => '星期二',
            'Wed' => '星期三',
            'Thu' => '星期四',
            'Fri' => '星期五',
            'Sat' => '星期六',
            'Sun' => '星期天'
        ),
        'today' => '转到今天',
    );
    
    if (isset($_GET['month']) && in_array($_GET['month'], $months)) {
        $month = $_GET['month'];
    } else {
        $month = date("F");
    }
    if (isset($_GET['year']) && is_numeric($_GET['year']) && $_GET['year']<=2038 && $_GET['year']>=1970) {
        $year=$_GET['year'];
    } else {
        $year=date("Y");
    }
    $start          = strtotime("$month 1st $year");
    $end            = strtotime("$month ".date("t",$start)." $year");
    $previous_year  = strtotime("-1 year",$start);
    $next_year      = strtotime("+1 year",$start);
    $previous_month = strtotime("-1 month",$start);
    $next_month     = strtotime("+1 month",$start);
    $link           = "<a href='?month=%s&year=%s' target='_self'>%s</a>";
    
    if (date("Y", $previous_year) >= 1970) {
        $calendar[] = sprintf($link, date("F", $start), date("Y", $previous_year), date("Y", $previous_year));
    } else {
        $calendar[] = EMPTY_COLUMN;
    }
    
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = date("Y",$start);
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = EMPTY_COLUMN;
    
    if (date("Y", $next_year)<2038 && date("Y", $next_year) != 1969) {
        $calendar[] = sprintf($link, date("F", $start),date("Y", $next_year), date("Y", $next_year));
    } else {
        $calendar[] = EMPTY_COLUMN;
    }
    $calendar[] = sprintf($link, date("F", $previous_month), date("Y", $previous_month), ${$language}['month'][date("F", $previous_month)]);
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = ${$language}['month'][date("F",$start)];
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = EMPTY_COLUMN;
    $calendar[] = sprintf($link, date("F", $next_month), date('Y',$next_month), ${$language}['month'][date('F', $next_month)]);
    $calendar[] = ${$language}['week']['Mon'];
    $calendar[] = ${$language}['week']['Tue'];
    $calendar[] = ${$language}['week']['Wed'];
    $calendar[] = ${$language}['week']['Thu'];
    $calendar[] = ${$language}['week']['Fri'];
    $calendar[] = ${$language}['week']['Sat'];
    $calendar[] = ${$language}['week']['Sun'];
    $blank_td   = date("N",$start);

    for ($i = 1; $i < $blank_td; $i++) {
        $calendar[] = EMPTY_COLUMN;
    }
    $dates=range(1, date("t", $start));
    foreach ($dates as $value) {
        $calendar[] = $value;
    }
    
    $cc = count($calendar);
    for ($i = 1; $i <= 63-$cc; $i++) {
        $calendar[] = EMPTY_COLUMN;
    }
    
    $k     = 0;
    $today = date("Y")." ".date("F")." ".date("j");
    $html  = "<table>";
    for ($i = 1; $i <= 9; $i++) {
        $html .= "<tr>";
        for($j = 1; $j <= 7; $j++) {
            if (is_int($calendar[$k])) {
                $cur_date = "$year $month $calendar[$k]";
                if ($cur_date == $today) {
                    $html .= "<td width='50' style='font-weight:bold;color:blue'>" . $calendar[$k++] . "</td>";
                } else {
                    $html .= "<td width='50'>" . $calendar[$k++] . "</td>";
                }
            } else {
                $html .= "<td width='50'>" . $calendar[$k++] . "</td>";
            }
        }
        $html .= "</tr>";
    }
    $html .= '<tr><td align="center" colspan="7">' . sprintf($link, date('F'), date('Y'), ${$language}['today']) . '</td></tr>';
    $html .= "</table>";
    return $html;
}
echo "英文版本日历：<br />";
echo php_calendar("EN");
echo "<p />";
echo "中文版本日历：<br />";
echo php_calendar("CN");



++++PHP画一个圆形扇形+++++
//新建一个画布
$image=imagecreatetruecolor(400,300);
//新建画布默认是黑色背景，将其改为白色
$white=imagecolorallocate($image,255,255,255);
imagefill($image,0,0,$white);
//画出扇形
//创建三种颜色
$red=imagecolorallocate($image,255,0,0);
$blue=imagecolorallocate($image,0,0,128);
$gray=imagecolorallocate($image,192,192,192);
//用三种颜色填充扇形
imagefilledarc($image,100,50,100,50,0,35,$blue,IMG_ARC_PIE);
imagefilledarc($image,100,50,100,50,35,75,$gray,IMG_ARC_PIE);
imagefilledarc($image,100,50,100,50,75,360,$red,IMG_ARC_PIE);
//告诉浏览器输出的内容是PNG格式的图片
header('Content-type:image/png');
imagepng($image);
//释放图像占用的内存资源
imagedestory($image);


+++++++PHP生成国内随机IP地址++++++++
$ip_long = array(
    array('607649792', '608174079'), //36.56.0.0-36.63.255.255
    array('1038614528', '1039007743'), //61.232.0.0-61.237.255.255
    array('1783627776', '1784676351'), //106.80.0.0-106.95.255.255
    array('2035023872', '2035154943'), //121.76.0.0-121.77.255.255
    array('2078801920', '2079064063'), //123.232.0.0-123.235.255.255
    array('-1950089216', '-1948778497'), //139.196.0.0-139.215.255.255
    array('-1425539072', '-1425014785'), //171.8.0.0-171.15.255.255
    array('-1236271104', '-1235419137'), //182.80.0.0-182.92.255.255
    array('-770113536', '-768606209'), //210.25.0.0-210.47.255.255
    array('-569376768', '-564133889'), //222.16.0.0-222.95.255.255
);
$rand_key = mt_rand(0, 9);
$ip= long2ip(mt_rand($ip_long[$rand_key][0],  $ip_long[$rand_key][1]));
echo $ip;



+++++++PHP发送邮件代码-不需要安装任何组件跟配置邮件服务器+++++++
//例子
if(send_mail('903456967@qq.com','发信标题11','<b><font color=red>发信内容11</font></b>')=="")
{
echo "发送成功！<br>";
}
else{
echo "发送失败！<br>";
}

 
function send_mail($to, $subject = 'No subject', $body)
{
$loc_host = "im286"; //发信计算机名，可随意
$smtp_acc = "413951426@qq.com"; //Smtp认证的用户名，类似fish1240@fishcat.com.cn，或者fish1240
$smtp_pass="chinaqqq"; //Smtp认证的密码，一般等同pop3密码
$smtp_host="smtp.qq.com"; //SMTP服务器地址，类似 smtp.tom.com
$from="413951426@qq.com"; //发信人Email地址，你的发信信箱地址
$headers = "Content-Type: text/html; Content-Transfer-Encoding: base64";
$lb=" "; //linebreak
$hdr = explode($lb,$headers); //解析后的hdr
$body= $body;
if($body)
{
$bdy = preg_replace("/^./","..",explode($lb,$body));//解析后的Body
}

$smtp = array(
//1、EHLO，期待返回220或者250
array("EHLO ".$loc_host.$lb,"220,250","HELO error: "),
//2、发送Auth Login，期待返回334
array("AUTH LOGIN".$lb,"334","AUTH error:"),
//3、发送经过Base64编码的用户名，期待返回334
array(base64_encode($smtp_acc).$lb,"334","AUTHENTIFICATION error : "),
//4、发送经过Base64编码的密码，期待返回235
array(base64_encode($smtp_pass).$lb,"235","AUTHENTIFICATION error : ")
);
//5、发送Mail From，期待返回250
$smtp[] = array("MAIL FROM: <".$from.">".$lb,"250","MAIL FROM error: ");
//6、发送Rcpt To。期待返回250
$smtp[] = array("RCPT TO: <".$to.">".$lb,"250","RCPT TO error: ");
//7、发送DATA，期待返回354
$smtp[] = array("DATA".$lb,"354","DATA error: ");
//8.0、发送From
$smtp[] = array("From: ".$from.$lb,"","");
//8.2、发送To
$smtp[] = array("To: ".$to.$lb,"","");
//8.1、发送标题
$smtp[] = array("Subject: ".$subject.$lb,"","");
//8.3、发送其他Header内容
foreach($hdr as $h)
{
$smtp[] = array($h.$lb,"","");
}
//8.4、发送一个空行，结束Header发送
$smtp[] = array($lb,"","");
//8.5、发送信件主体
if($bdy)
{
foreach($bdy as $b)
{
$smtp[] = array(base64_encode($b.$lb).$lb,"","");
}
}
//9、发送“.”表示信件结束，期待返回250
$smtp[] = array(".".$lb,"250","DATA(end)error: ");
//10、发送Quit，退出，期待返回221
$smtp[] = array("QUIT".$lb,"221","QUIT error: ");
//打开smtp服务器端口
$fp = @fsockopen($smtp_host, 25);
if (!$fp)
echo "<b>Error:</b> Cannot conect to ".$smtp_host."<br>";
while($result = @fgets($fp, 1024))
{
if(substr($result,3,1) == " ")
{
break;
}
}
$result_str="";
//发送smtp数组中的命令/数据
foreach($smtp as $req)
{
//发送信息
@fputs($fp, $req[0]);
//如果需要接收服务器返回信息，则
if($req[1])
{
//接收信息
while($result = @fgets($fp, 1024))
{
if(substr($result,3,1) == " ")
{
break;
}
};
if (!strstr($req[1],substr($result,0,3)))
{
$result_str.=$req[2].$result."<br>";
}
}
}
//关闭连接
@fclose($fp);
return $result_str;
}
 



+++++PHP把一个txt文件的内容照原文格式读取到一个数组里面+++++
$myFile=file("license.txt");
//打印每一行
for($index=0;$index<count($myFile);$index++){
    print($myFile[$index]."<br>");
}

+++++php正则分析是否是纯中文++++++
echo preg_match("/^[".chr(0xa1)."-".chr(0xff)."]+$/","123")?"<br>纯中文":"<br>非纯中文";
echo preg_match("/^[".chr(0xa1)."-".chr(0xff)."]+$/","啊aaa")?"<br>纯中文":"<br>非纯中文";
echo preg_match("/^[".chr(0xa1)."-".chr(0xff)."]+$/","啊啊")?"<br>纯中文":"<br>非纯中文";

++++千万,亿万级数据的排行榜php查询数据库实时更新+++++++
比如积分排行搬,最新获奖列表(按时间),风向标(点击数), 对于这些积分排行榜,实际并不用所有的数据,拉新只需要显示最新50位中奖用户,
游戏中显示排名在一万名以内的用户? 把亿万,千万级别的数据排序, 冒泡,快速排序? 如此大数据,消耗的时间和内存.会让计算机抓狂!
可是却要求1小时,半小时,1分钟....更新，这是不是让你崩溃啊. 没事儿,看一下下面的算法,你就会发现甚至可以做到
实时更新,那应用什么原理呢? 
巧妙之处就是在原来的排行榜中排序. 如果有用户玩游戏得分数了,此时需要更新排行榜, 如下：
<?php
//已经排好的排行榜
$rank_list = array(100,10,9,6,5,4);
//更新排行榜
function sort_rank($rank_list,$item) {
    $pop_arr = array();
    while ($entry = array_pop($rank_list) ) {
        if ($entry >= $item) {
            if ($pop_arr) {
                array_push($rank_list,$entry,$item);
                array_pop($pop_arr);
                return array_merge($rank_list,$pop_arr);
            }
            array_push($rank_list,$entry);
            return $rank_list;
        } else {
            array_unshift($pop_arr,$entry);
        }
    }
}
//假如用户得到2分
print_r(sort_rank($rank_list,2));
//用户得到7分更新排行榜
print_r(sort_rank($rank_list,7) );
?>
这样排序限制在了,排行榜中有多少条记录, 而且事情比想象中更好, 
因为进入排行榜不是那么容易,绝大多数用户永远徘徊在排行榜外的:)
但现实似乎不是这样,服务器有很多,如何处理并发呢? 引入队列机吧，
在大型系统中,队列机真是好东西。


++++php性能优化之APC的使用+++++++
apc能够缓存php的opcode码，能普遍提升30%的性能。但是默认apc.stat=1，这样每次请求都会访问需要使用的php文件，
看看这个文件是否更新了，已决定是否重新编译php文件。这个是很耗性能的，推荐关掉。
解决方法：
1. 设定apc.stat=0，不必每次请求都访问需要用到的php文件。
需要注意的是：每次发版本改动了php文件的时候，必须调用apc_clear()清除apc缓存，否则你的代码永远也不会生效。


++++php修改hosts文件+++++
//修复google DNS受污染，虽然依然访问不了google，但是为修改本地
文件提供了思路
$ip = gethostbyname('http://www.google.com');

$file = 'C:\Windows\System32\drivers\etc\hosts';
if ($ip) {
    echo $ip."\n";
    $hosts = file($file);
    foreach ( $hosts as $k=>$v) {
        if(strpos($v,'google.com')!==false){
            unset($hosts[$k]);
        }
    }
    array_push($hosts,"\r\n$ip www.google.com google.com encrypted.google.com docs.google.com code.google.com\r\n");
    file_put_contents($file,implode('',$hosts));
}



+++++php随机抽奖程序++++++++
如果说用户去抽某一个固定的奖品,比如说抽抽Q币,这个中奖的概率是1/10000, 
只要计算$ret=rand(1,10000), 如果$ret=1既可以表示中奖了.
但是如果说有很多奖品,奖品分成了一等奖,二等奖,三等奖等,每个奖品中奖的概
率是固定的,比如1等奖是1/1000, 二等奖1/100.
原理：根据每个奖品的中奖概率,计算出最小公倍数,从最小公倍数中,分配每个奖
品的中奖区间,从中奖区间和最小公倍数中,取一个随机数,看是否中奖.
class prize {
    private $minMul ;
    //最小公倍数
    private $prizeGap ;
    //抽奖区间
    public function minMultiple($args ) {
        //$args = func_get_args();
        if (count($args ) < 2 ) {
            return false ;
        }
        $divisor = self::divisor($args[0],$args[1]);
        $multiple = ($args[0]*$args[1])/$divisor;
        for ($i=2; $i<count($args); $i++) {
            $divisor = self::divisor($args[$i],$multiple);
            $multiple = ($multiple*$args[$i])/$divisor;
        }
        return $multiple;   
    }
    public static function divisor($m,$n) {
        if ($n ==0) {
            return $m;
        }
        if ($m%$n==0) {
            return $n;
        } else {return self::divisor($n,$m%$n);
        }
    }
    public function draw(){
        $probability = $this -> getProbability();
        //从1到最小公倍数中取随机数
        $max = max($this -> minMul, $this -> prizeGap);
        $rand = rand(1 , $max );
        //随机数不在中奖区间
        if ($rand>max($probability)) {
            return false;
        }
        //计算中了几等奖
        foreach($probability as $id => $v ){
            if ($rand <= $v ) {
                return $id;
            }
        }
    }
    public function getProbability(){
        $ret = $this -> getPrize();
        $probability = array();
        $minMul = $this -> minMultiple(array_values($ret) );
        foreach($ret as $k => $v ){
            $total += $minMul / $v ;
            $probability [ $k ] = $total ;
        }
        $this -> minMul = $minMul ;
        $this -> prizeGap = $total ;
        return $probability ;
    }
    public function getPrize(){
        $ret = array(1 => '1000' , //一等奖中奖概率1/1000
        2 => '500' , //二等奖中奖概率 1/500
        3 => '50' ,
        4 => '20' ,
        5 => '10'
        );
        return $ret ;
    }
}
$prize = new prize();
$ret = $prize -> draw();
if (false !== $ret ) {
    echo sprintf('恭喜你中了%d等奖',$ret);
} else {
    echo '很遗憾没有中奖' ;
}


++++php写的socket程序模拟发送post数据+++++
<?$domain = "127.0.0.1";
$port = 80;
$uri = "/ly/post.php";
$data="txtName=111&txtEmail=222@1.net&rabSex=%D0%A1%BD%E3&txtFrom=%BD%AD%CE%F7%C1%FA%C4%CF&txtQq=2222&txtUrl=33333333&txtFace=images%2Fface%2Fface05.gif&txtEm=images%2Fem%2Fem01.gif&txtBody=rrr";
$protocolstr ="POST {$uri} HTTP/1.1\r\nHost: {$domain}\r\nContent-type: application/x-www-form-urlencoded\r\nContent-length: " . strlen($data) . "\r\nReferer: http://10.10.10.10/ly/index.php\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322)\r\nAccept: */*\r\n\r\n{$data}\r\n\r\n";

$sock = fsockopen($domain, $port, $errno, $errstr, 30);
if (!$sock) die("$errstr ($errno)\n");
fputs($sock, $protocolstr);

$headers = "";
while ($str = trim(fgets($sock, 4096)))
  $headers .= "$str\n";

$body = "";
while (!feof($sock))
  $body .= fgets($sock, 4096);
fclose($sock);

echo "<h2>Response header:</h2>\n";
echo $headers;
echo "\n";
echo "<h2>Response body:</h2>\n";
echo $body;
?>



+++++PHP中GBK和UTF8编码处理判断截取计算中文字符串+++++++
 一、编码范围1. GBK (GB2312/GB18030)
\x00-\xff GBK双字节编码范围
\x20-\x7f ASCII
\xa1-\xff 中文
\x80-\xff 中文

2. UTF-8 (Unicode)
\u4e00-\u9fa5 (中文)
\x3130-\x318F (韩文
\xAC00-\xD7A3 (韩文)
\u0800-\u4e00 (日文)
ps: 韩文是大于[\u9fa5]的字符
正则例子:
preg_replace("/([\x80-\xff])/","",$str);
preg_replace("/([u4e00-u9fa5])/","",$str);

代码例子：

//判断内容里有没有中文-GBK (PHP)
function check_is_chinese($s){
   return preg_match('/[\x80-\xff]./', $s);
}
 
//获取字符串长度-GBK (PHP)
function gb_strlen($str){
   $count = 0;
   for($i=0; $i<strlen($str); $i++){
       $s = substr($str, $i, 1);
       if (preg_match("/[\x80-\xff]/", $s)) ++$i;
       ++$count;
   }
   return $count;
}
 
//截取字符串字串-GBK (PHP)
function gb_substr($str, $len){
   $count = 0;
   for($i=0; $i<strlen($str); $i++){
       if($count == $len) break;
       if(preg_match("/[\x80-\xff]/", substr($str, $i, 1))) ++$i;
       ++$count;        
   }
   return substr($str, 0, $i);
}
 
//统计字符串长度-UTF8 (PHP)
function utf8_strlen($str){
    $i = 0;
    $count = 0;
    $len = strlen ($str);
    while ($i < $len){
        $chr = ord ($str[$i]);
        $count++;
        $i++;
        if($i >= $len)
            break;

        if($chr & 0x80)    {
            $chr <<= 1;
            while ($chr & 0x80){
                $i++;
                $chr <<= 1;
            }
        }
    }
    return $count;
}
 
 
//截取字符串-UTF8(PHP)
function utf8_substr($str,$position,$length){
   $start_position = strlen($str);
   $start_byte = 0;
   $end_position = strlen($str);
   $count = 0;
   for($i = 0; $i < strlen($str); $i++){
       if($count >= $position && $start_position > $i){
           $start_position = $i;
           $start_byte = $count;
       }
       if(($count-$start_byte)>=$length) {
           $end_position = $i;
           break;
       }    
       $value = ord($str[$i]);
       if($value > 127){
           $count++;
           if($value >= 192 && $value <= 223) $i++;
           elseif($value >= 224 && $value <= 239) $i = $i + 2;
           elseif($value >= 240 && $value <= 247) $i = $i + 3;
           else die('Not a UTF-8 compatible string');
       }
       $count++;
 
   }
   return(substr($str,$start_position,$end_position-$start_position));
}
 
//判断是否是有韩文-UTF-8 (JavaScript)
function checkKoreaChar(str) {
   for(i=0; i<str.length; i++) {
       if(((str.charCodeAt(i) > 0x3130 && str.charCodeAt(i) < 0x318F) || (str.charCodeAt(i) >= 0xAC00 && str.charCodeAt(i) <= 0xD7A3))) {
           return true;
       }
   }
   return false;
}
 
//判断是否有中文字符-GBK (JavaScript)
function check_chinese_char(s){
   return (s.length != s.replace(/[^\x00-\xff]/g,"**").length);
}



+++++字符串截取支持中文和其他编码++++++
/**
+----------------------------------------------------------
* 字符串截取，支持中文和其他编码
+----------------------------------------------------------
* @param string $source 需要转换的字符串
* @param string $start 开始位置
* @param string $length 截取长度
* @param string $charset 编码格式
* @param string $suffix 截断显示字符后缀
+----------------------------------------------------------
* @return string
+----------------------------------------------------------
*/
function xs_substr($source, $start=0, $length, $charset="utf-8", $suffix="")
{
	if(function_exists("mb_substr"))        //采用PHP自带的mb_substr截取字符串
	{
		$string = mb_substr($source, $start, $length, $charset).$suffix;
	}
	elseif(function_exists('iconv_substr')) //采用PHP自带的iconv_substr截取字符串
	{
		$string = iconv_substr($source,$start,$length,$charset).$suffix;
	}
	else
	{
		$pattern['utf-8']   = "/[x01-x7f]|[xc2-xdf][x80-xbf]|[xe0-xef][x80-xbf]{2}|[xf0-xff][x80-xbf]{3}/";
		$pattern['gb2312'] = "/[x01-x7f]|[xb0-xf7][xa0-xfe]/";
		$pattern['gbk']    = "/[x01-x7f]|[x81-xfe][x40-xfe]/";
		$pattern['big5']   = "/[x01-x7f]|[x81-xfe]([x40-x7e]|xa1-xfe])/";
		preg_match_all($pattern[$charset], $source, $match);
		$slice = join("",array_slice($match[0], $start, $length));
		 
		$string = $slice.$suffix;
	}
	return $string;
}


++听说这是无敌的加密，几乎不可能解开+++++
$pass="123456";
echo  md5(crypt($pass,substr($pass,0,2)));


+++++PHP加密专家解密算法可靠性未知，但是思路不错++++++
/*********************************** 
*威盾PHP加密专家解密算法 By：Neeao 
*http://Neeao.com 
*2009-09-10 
***********************************/ 
$filename="play-js.php";//要解密的文件 
$lines = file($filename);//0,1,2行 

//第一次base64解密 
$content=""; 
if(preg_match("/O0O0000O0\('.*'\)/",$lines[1],$y)) 
{ 
    $content=str_replace("O0O0000O0('","",$y[0]); 
    $content=str_replace("')","",$content); 
    $content=base64_decode($content); 
} 
//第一次base64解密后的内容中查找密钥 
$decode_key=""; 
if(preg_match("/\),'.*',/",$content,$k)) 
{ 
    $decode_key=str_replace("),'","",$k[0]); 
    $decode_key=str_replace("',","",$decode_key); 
} 
//查找要截取字符串长度 
$str_length=""; 
if(preg_match("/,\d*\),/",$content,$k)) 
{ 
    $str_length=str_replace("),","",$k[0]); 
    $str_length=str_replace(",","",$str_length); 
} 
//截取文件加密后的密文 
$Secret=substr($lines[2],$str_length); 
//echo $Secret; 

//直接还原密文输出 
echo "<?php\n".base64_decode(strtr($Secret,$decode_key,'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'))."?>"; 


++++++js返回上一页页面过期+++++
js返回上一页，页面过期，往往是由于session保护机制引起的
<input type="button" name="Submit"  onClick="window.location='javascript:history.back(-1)'" value="返回" >
可以在session_start();下面增加：
header("Cache-control: private");



++++PHP附件下载header方式详解+++++++
// 文件目录
define('DL_DIR', 'temp/');
// 常见扩展名所对应的MIME类型
$MIMETypes = array(
    'ez'         => 'application/andrew-inset',    
    'hqx'        => 'application/mac-binhex40',    
    'cpt'        => 'application/mac-compactpro',    
    'doc'        => 'application/msword',    
    'bin'        => 'application/octet-stream',    
    'dms'        => 'application/octet-stream',    
    'lha'        => 'application/octet-stream',    
    'lzh'        => 'application/octet-stream',    
    'exe'        => 'application/octet-stream',    
    'class'      => 'application/octet-stream',    
    'so'         => 'application/octet-stream',    
    'dll'        => 'application/octet-stream',    
    'oda'        => 'application/oda',    
    'pdf'        => 'application/pdf',    
    'ai'         => 'application/postscrīpt',    
    'eps'        => 'application/postscrīpt',    
    'ps'         => 'application/postscrīpt',    
    'smi'        => 'application/smil',    
    'smil'       => 'application/smil',    
    'mif'        => 'application/vnd.mif',    
    'xls'        => 'application/vnd.ms-excel',    
    'ppt'        => 'application/vnd.ms-powerpoint',    
    'wbxml'      => 'application/vnd.wap.wbxml',    
    'wmlc'       => 'application/vnd.wap.wmlc',    
    'wmlsc'      => 'application/vnd.wap.wmlscrīptc',    
    'bcpio'      => 'application/x-bcpio',    
    'vcd'        => 'application/x-cdlink',    
    'pgn'        => 'application/x-chess-pgn',    
    'cpio'       => 'application/x-cpio',    
    'csh'        => 'application/x-csh',    
    'dcr'        => 'application/x-director',    
    'dir'        => 'application/x-director',    
    'dxr'        => 'application/x-director',    
    'dvi'        => 'application/x-dvi',    
    'spl'        => 'application/x-futuresplash',    
    'gtar'       => 'application/x-gtar',    
    'hdf'        => 'application/x-hdf',    
    'js'         => 'application/x-javascrīpt',    
    'skp'        => 'application/x-koan',    
    'skd'        => 'application/x-koan',    
    'skt'        => 'application/x-koan',    
    'skm'        => 'application/x-koan',    
    'latex'      => 'application/x-latex',    
    'nc'         => 'application/x-netcdf',    
    'cdf'        => 'application/x-netcdf',    
    'sh'         => 'application/x-sh',    
    'shar'       => 'application/x-shar',    
    'swf'        => 'application/x-shockwave-flash',    
    'sit'        => 'application/x-stuffit',    
    'sv4cpio'    => 'application/x-sv4cpio',    
    'sv4crc'     => 'application/x-sv4crc',    
    'tar'        => 'application/x-tar',    
    'tcl'        => 'application/x-tcl',    
    'tex'        => 'application/x-tex',    
    'texinfo'    => 'application/x-texinfo',    
    'texi'       => 'application/x-texinfo',    
    't'          => 'application/x-troff',    
    'tr'         => 'application/x-troff',    
    'roff'       => 'application/x-troff',    
    'man'        => 'application/x-troff-man',    
    'me'         => 'application/x-troff-me',    
    'ms'         => 'application/x-troff-ms',    
    'ustar'      => 'application/x-ustar',    
    'src'        => 'application/x-wais-source',    
    'xhtml'      => 'application/xhtml+xml',    
    'xht'        => 'application/xhtml+xml',    
    'zip'        => 'application/zip',    
    'au'         => 'audio/basic',    
    'snd'        => 'audio/basic',    
    'mid'        => 'audio/midi',    
    'midi'       => 'audio/midi',    
    'kar'        => 'audio/midi',    
    'mpga'       => 'audio/mpeg',    
    'mp2'        => 'audio/mpeg',    
    'mp3'        => 'audio/mpeg',    
    'aif'        => 'audio/x-aiff',    
    'aiff'       => 'audio/x-aiff',    
    'aifc'       => 'audio/x-aiff',    
    'm3u'        => 'audio/x-mpegurl',    
    'ram'        => 'audio/x-pn-realaudio',    
    'rm'         => 'audio/x-pn-realaudio',    
    'rpm'        => 'audio/x-pn-realaudio-plugin',    
    'ra'         => 'audio/x-realaudio',    
    'wav'        => 'audio/x-wav',    
    'pdb'        => 'chemical/x-pdb',    
    'xyz'        => 'chemical/x-xyz',    
    'bmp'        => 'image/bmp',    
    'gif'        => 'image/gif',    
    'ief'        => 'image/ief',    
    'jpeg'       => 'image/jpeg',    
    'jpg'        => 'image/jpeg',    
    'jpe'        => 'image/jpeg',    
    'png'        => 'image/png',    
    'tiff'       => 'image/tiff',    
    'tif'        => 'image/tiff',    
    'djvu'       => 'image/vnd.djvu',    
    'djv'        => 'image/vnd.djvu',    
    'wbmp'       => 'image/vnd.wap.wbmp',    
    'ras'        => 'image/x-cmu-raster',    
    'pnm'        => 'image/x-portable-anymap',    
    'pbm'        => 'image/x-portable-bitmap',    
    'pgm'        => 'image/x-portable-graymap',    
    'ppm'        => 'image/x-portable-pixmap',    
    'rgb'        => 'image/x-rgb',    
    'xbm'        => 'image/x-xbitmap',    
    'xpm'        => 'image/x-xpixmap',    
    'xwd'        => 'image/x-xwindowdump',    
    'igs'        => 'model/iges',    
    'iges'       => 'model/iges',    
    'msh'        => 'model/mesh',    
    'mesh'       => 'model/mesh',    
    'silo'       => 'model/mesh',    
    'wrl'        => 'model/vrml',    
    'vrml'       => 'model/vrml',    
    'css'        => 'text/css',    
    'html'       => 'text/html',    
    'htm'        => 'text/html',    
    'asc'        => 'text/plain',    
    'txt'        => 'text/plain',    
    'rtx'        => 'text/richtext',    
    'rtf'        => 'text/rtf',    
    'sgml'       => 'text/sgml',    
    'sgm'        => 'text/sgml',    
    'tsv'        => 'text/tab-separated-values',    
    'wml'        => 'text/vnd.wap.wml',    
    'wmls'       => 'text/vnd.wap.wmlscrīpt',    
    'etx'        => 'text/x-setext',    
    'xsl'        => 'text/xml',    
    'xml'        => 'text/xml',    
    'mpeg'       => 'video/mpeg',    
    'mpg'        => 'video/mpeg',    
    'mpe'        => 'video/mpeg',    
    'qt'         => 'video/quicktime',    
    'mov'        => 'video/quicktime',    
    'mxu'        => 'video/vnd.mpegurl',    
    'avi'        => 'video/x-msvideo',    
    'movie'      => 'video/x-sgi-movie',    
    'ice'        => 'x-conference/x-cooltalk',    
);

// 安全性过滤
$fileName = basename($_SERVER['QUERY_STRING']);
$filePath = dirname(__FILE__) . '/' . DL_DIR . $fileName;
/*
简述: DIRECTORY_SEPARATOR(目录界定符, 目录函数库预定义常量)
来源: Directory 目录函数(PHP手册->函数参考->Directories节点)
说明: windows系统下为反斜杠'\', Linux系统下为'/', 
windows下两个都正常用, linux就不知道了, 为了标准, 显得专业点, 嘿嘿.
*/
$filePath = str_replace(array('/', '\\'), DIRECTORY_SEPARATOR, $filePath);

if(!is_file($filePath)) {
    exit('File: ' . $fileName . ' not exists!');
} else { // 如果是一个有效的文件
    // 文件扩展名
    $fileExt = substr(strrchr($fileName, '.'), 1);
    // 文件类型
    $fileType = $MIMETypes[$fileExt] ? $MIMETypes[$fileExt] : 'application/octet-stream';
    // 是否是图片
    $isImage = False;
    /*
    简述: getimagesize(), 详见手册
    说明: 判定某个文件是否为图片的有效手段, 常用在文件上传验证
    */
    $imgInfo = @getimagesize($filePath);
    if ($imgInfo[2] && $imgInfo['bits']) {
        $isImage = True;
    }
    // 显示方式
    $attachment = $isImage ? 'inline' : 'attachment';

    // 读取文件
    if (is_readable($filePath)) {
        /*
        简述: ob_end_clean() 清空并关闭输出缓冲, 详见手册
        说明: 关闭输出缓冲, 使文件片段内容读取至内存后即被送出, 减少资源消耗
        */
        ob_end_clean();
        /*
         HTTP头信息: 指示客户机可以接收生存期不大于指定时间（秒）的响应
        */
        header('Cache-control: max-age=31536000'); 
        /*
         HTTP头信息: 缓存文件过期时间(格林威治标准时)
        */
        header('Expires: ' . gmdate('D, d M Y H:i:s', time()+31536000) . ' GMT');
        /*
         HTTP头信息: 文件在服务期端最后被修改的时间
         Cache-control,Expires,Last-Modified 都是控制浏览器缓存的头信息
         在一些访问量巨大的门户, 合理的设置缓存能够避免过多的服务器请求, 一定程度下缓解服务器的压力
        */
        header('Last-Modified: ' . gmdate('D, d M Y H:i:s' , filemtime($filePath) . ' GMT'));
        /*
         HTTP头信息: 文档的编码(Encode)方法, 因为附件请求的文件多样化, 改变编码方式有可能损坏文件, 故为none
        */
        header('Content-Encoding: none');
        /*
         HTTP头信息: 告诉浏览器当前请求的文件类型. 
          1.始终指定为application/octet-stream, 就代表文件是二进制流, 始终提示下载.
          2.指定对应的类型, 如请求的是mp3文件, 对应的MIME类型是audio/mpeg, IE就会自动启动Windows Media Player进行播放.
        */
        header('Content-type: ' . $fileType);
        /*
         HTTP头信息: 如果为attachment, 则告诉浏览器, 在访问时弹出"文件下载"对话框, 并指定保存时文件的默认名称(可以与服务器的文件名不同)
         如果要让浏览器直接显示内容, 则要指定为inline, 如图片, 文本
        */
        header('Content-Disposition: ' . $attachment . '; filename=' . $fileName);
        /*
         HTTP头信息: 告诉浏览器文件长度
         (IE下载文件的时候不是有文件大小信息么?)
        */
        header('Content-Length: ' . filesize($filePath));
        // 打开文件(二进制只读模式)
        $fp = fopen($filePath, 'rb');
        // 输出文件
        fpassthru($fp);
        // 关闭文件
        fclose($fp);
        exit();
    } else {
        exit('Read file failed!');
    }
}



++++PHP经典函数方法++++++++
获取IP
   function GetIP() { //获取IP zuolo:由于防火墙的原因 REMOTE_ADDR 就是服务器外网IP
    if ($_SERVER["HTTP_X_FORWARDED_FOR"])
        $ip = $_SERVER["HTTP_X_FORWARDED_FOR"];
    else if ($_SERVER["HTTP_CLIENT_IP"])
        $ip = $_SERVER["HTTP_CLIENT_IP"];
    else if ($_SERVER["REMOTE_ADDR"])
        $ip = $_SERVER["REMOTE_ADDR"];
    else if (getenv("HTTP_X_FORWARDED_FOR"))
        $ip = getenv("HTTP_X_FORWARDED_FOR");
    else if (getenv("HTTP_CLIENT_IP"))
        $ip = getenv("HTTP_CLIENT_IP");
    else if (getenv("REMOTE_ADDR"))
        $ip = getenv("REMOTE_ADDR");
    else
        $ip = "Unknown";
    echo $ip;
}
GetIP();

时间上的增加
function DateAdd($date, $int, $unit = "d") { //时间的增加（还可以改进成时分秒都可以增加，有时间再补上）
    $dateArr = explode("-", $date);
    $value[$unit] = $int;
    echo  date("Y-m-d", mktime(0,0,0, $dateArr[1] + $value['m'], $dateArr[2] + $value['d'], $dateArr[0] + $value['y']));
}
计算出给出的日期是星期几
function GetWeekDay($date) { //计算出给出的日期是星期几
    $dateArr = explode("-", $date);
    echo  date("w", mktime(0,0,0,$dateArr[1],$dateArr[2],$dateArr[0]));
}
GetWeeKDay("2013-10-3");
检查日期是否合法日期
function check_date($date) { //检查日期是否合法日期
    $dateArr = explode("-", $date);
    if (is_numeric($dateArr[0]) && is_numeric($dateArr[1]) && is_numeric($dateArr[2])) {
        return checkdate($dateArr[1],$dateArr[2],$dateArr[0]);
    }
    return false;
}
检查时间是否合法时间
function check_time($time) { //检查时间是否合法时间
    $timeArr = explode(":", $time);
    if (is_numeric($timeArr[0]) && is_numeric($timeArr[1]) && is_numeric($timeArr[2])) {
        if (($timeArr[0] >= 0 && $timeArr[0] <= 23) && ($timeArr[1] >= 0 && $timeArr[1] <= 59) && ($timeArr[2] >= 0 && $timeArr[2] <= 59))
            return true;
        else
            return false;
    }
    return false;
}
时间比较函数，返回两个日期相差几秒、几分钟、几小时或几天
function DateDiff($date1, $date2, $unit = "") { //时间比较函数，返回两个日期相差几秒、几分钟、几小时或几天
    switch ($unit) {
        case 's':
            $dividend = 1;
            break;
        case 'i':
            $dividend = 60;
            break;
        case 'h':
            $dividend = 3600;
            break;
        case 'd':
            $dividend = 86400;
            break;
        default:
            $dividend = 86400;
    }
    $time1 = strtotime($date1);
    $time2 = strtotime($date2);
    if ($time1 && $time2)
        return (float)($time1 - $time2) / $dividend;
    return false;
}
重定向
方法一：header("Location: index.php");
方法二：echo "<scrīpt>window.location ="$PHP_SELF";</scrīpt>";
方法三：echo "<META HTTP-EQUIV="Refresh" CONTENT="0; URL=index.php">";
获取访问者浏览器
function browse_infor()
{
    $browser="";$browserver="";
    $Browsers =array("Lynx","MOSAIC","AOL","Opera","JAVA","MacWeb","WebExplorer","OmniWeb");
    $Agent = $_SERVER["HTTP_USER_AGENT"];
    for ($i=0; $i<=7; $i++)    {
        if (strpos($Agent,$Browsers[$i]))    {
        $browser = $Browsers[$i];
        $browserver ="";
        }
    }
    if (ereg("Mozilla",$Agent) && ereg("Chrome",$Agent))    {
        $browserver=substr($Agent,strripos($Agent, "Chrome"));
        $browserver=substr($browserver,7,(strripos($browserver," ")-7));
        $browser = "Google Chrome";
    }
    if (ereg("Mozilla",$Agent) && ereg("Opera",$Agent))    {
        $temp =explode("(", $Agent); $Part=$temp[1];
        $temp =explode(")", $Part); $browserver=$temp[1];
        $temp =explode(" ",$browserver);$browserver=$temp[2];
        $browserver =preg_replace("/([d.]+)/","1",$browserver);
        $browser = "Opera";
    }
    if (ereg("Mozilla",$Agent) && ereg("MSIE",$Agent))    {
        $temp = explode("(", $Agent); $Part=$temp[1];
        $temp = explode(";",$Part); $Part=$temp[1];
        $temp = explode(" ",$Part);$browserver=$temp[2];
        //$browserver =preg_replace("/([d.]+)/","1",$browserver); bug：在IE7中会把版本号7.0转为710
        $browser = "Internet Explorer";
    }
    if ($browser!="")    {
        $browseinfo = "$browser $browserver";
    }
    else    {
        $browseinfo = "Unknown";
    }
    return $browseinfo;
}
$browser=browse_infor();
echo $browser;
获取访问者操作系统
function osinfo() {
    $os="";
    $Agent = $_SERVER["HTTP_USER_AGENT"];
    if (eregi('win',$Agent) && strpos($Agent, '95')) {
        $os="Windows 95";
    }
    elseif (eregi('win 9x',$Agent) && strpos($Agent, '4.90')) {
        $os="Windows ME";
    }
    elseif (eregi('win',$Agent) && ereg('98',$Agent)) {
        $os="Windows 98";
    }
    elseif (eregi('win',$Agent) && eregi('nt 5.0',$Agent)) {
        $os="Windows 2000";
    }
    elseif (eregi('win',$Agent) && eregi('nt 5.1',$Agent)) {
        $os="Windows XP";
    }
    elseif (eregi('win',$Agent) && eregi('nt 6.0',$Agent)) {
        $os="Windows Vista";
    }
    elseif (eregi('win',$Agent) && eregi('nt',$Agent)) {
        $os="Windows NT";
    }
    elseif (eregi('win',$Agent) && ereg('32',$Agent)) {
        $os="Windows 32";
    }
    elseif (eregi('linux',$Agent)) {
        $os="Linux";
    }
    elseif (eregi('unix',$Agent)) {
        $os="Unix";
    }
    elseif (eregi('sun',$Agent) && eregi('os',$Agent)) {
        $os="SunOS";
    }
    elseif (eregi('ibm',$Agent) && eregi('os',$Agent)) {
        $os="IBM OS/2";
    }
    elseif (eregi('Mac',$Agent) && eregi('PC',$Agent)) {
        $os="Macintosh";
    }
    elseif (eregi('PowerPC',$Agent)) {
        $os="PowerPC";
    }
    elseif (eregi('AIX',$Agent)) {
        $os="AIX";
    }
    elseif (eregi('HPUX',$Agent)) {
        $os="HPUX";
    }
    elseif (eregi('NetBSD',$Agent)) {
        $os="NetBSD";
    }
    elseif (eregi('BSD',$Agent)) {
        $os="BSD";
    }
    elseif (ereg('OSF1',$Agent)) {
        $os="OSF1";
    }
    elseif (ereg('IRIX',$Agent)) {
        $os="IRIX";
    }
    elseif (eregi('FreeBSD',$Agent)) {
        $os="FreeBSD";
    }
    if ($os=='') $os = "Unknown";
    return $os;
}
$os=osinfo();
echo $os;
php生成excel文档
<?php
header("Content-type:application/vnd.ms-excel");
header("Content-Disposition:filename=test.xls");
echo "test1t";
echo "test2tn";
echo "test1t";
echo "test2tn";
echo "test1t";
echo "test2tn";
echo "test1t";
echo "test2tn";
echo "test1t";
echo "test2tn";
echo "test1t";
echo "test2tn";
//改动相应文件头就可以输出.doc .xls等文件格式了
?>
提取页面和浏览器提交的变量，作用相当于使PHP.INI开了全局变量
@extract($_SERVER, EXTR_SKIP);
@extract($_SESSION, EXTR_SKIP);
@extract($_POST, EXTR_SKIP);
@extract($_FILES, EXTR_SKIP);
@extract($_GET, EXTR_SKIP);
@extract($_ENV, EXTR_SKIP);
比较友好的页面跳转等待页
function turntopage($url="index.php",$info = "页面转向中...",$second=2){
print "<html><head><title>页面转向中....</title>";
print "<meta http-equiv='refresh' content='$second;url=$url'>";
print "<style type='text/css'><!--";
print "td { font-family: 'Verdana', 'Arial';font-size: 12px}";
print "A {COLOR: #000000; TEXT-DECORATION: none}";
print "--></style>";
print "</head><body>";
print "<table width='100%' border='0' align='center'>";
print " <tr>";
print " <td height='200'> </td>";
print " </tr>";
print " <tr>";
print " <td align='center'>";
print " <table width='60%' border='0' cellpadding='8' bgcolor='#AA9FFF'>";
print " <tr>";
print " <td height='30' align='center'>页面转向提示信息</td>";
print " </tr>";
print " <tr>";
print " <td align='center'>$info</td>";
print " </tr>";
print " <tr>";
print " <td align='center'>";
print " <a href='$url'>如果你的浏览器不支持自动跳转,请按这里</a></td>";
print " </tr>";
print " </tr>";
print " </table></td>";
print " </tr>";
print " <tr>";
print " <td height='200'> </td>";
print " </tr>";
print "</table>";
print "</body></html>";
exit;
  } 
 turntopage();
获得当前的脚本网址或者说是文件在网络根目录的位置
function get_php_site(){
        if(!empty($_server["REQUEST_URI"])){
                $scriptName = $_SERVER["REQUEST_URI"];
                $nowsite = $scriptName;
        }else{
                $scriptName = $_SERVER["PHP_SELF"];
                if(empty($_SERVER["QUERY_STRING"])) $nowsite = $scriptName;
                else $nowsite = $scriptName."?".$_SERVER["QUERY_STRING"];
        }
        return $nowsite;
}
$site=get_php_site();
echo $site;


++++PHP文本数据库的搜索方法+++++
//PHP文本数据库的搜索方法 
searchstr=("/".preg_quote($searchstr)."/"); 
//$searchstr是查找的关键字 
$records=file($file);//获取所有的记录数 
//$file是查找的数据文件 
$search_reocrds=preg_grep ($searchstr, $records);//开始查找记录 
//$search_reocrds为查找到的记录数 
unset($records); 
if($search_records){ 
//开始显示记录，写下你自己的处理程序******************** 
while (list ($key, $val) = each ( $search_records)) { 
echo "$val"; 
} 
//**************************************************** 
} 


+++++不需要mod_rewrite直接使用php实现伪静态化页面+++++
在程序初始化时使用如下代码：
<?php
$Php2Html_FileUrl = $_SERVER["REQUEST_URI"];
$Php2Html_UrlString = str_replace("/", "", strrchr($Php2Html_FileUrl, "/"));
$Php2Html_UrlQueryStrList = explode("@", $Php2Html_UrlString);
foreach($Php2Html_UrlQueryStrList as $Php2Html_UrlQueryStr)
{
  $Php2Html_TmpArray = explode("|", $Php2Html_UrlQueryStr);
  $_GET[$Php2Html_TmpArray[0]] = $Php2Html_TmpArray[1];
}
echo '假静态：$_GET变量<br />';
print_r($_GET);
?>
然后php中调用$_GET变量就像平常一样。
连接使用方式：
****.php/param1|1234@param2|4321
和****.php?param1=1234¶m2=4321一样。 


++++php禁止网页缓存++++++
header(”Expires: Mon, 26 Jul 1997 05:00:00 GMT”);
header(”Cache-Control: no-cache, must-revalidate”);
header(”Pragma: no-cache”);



++++PHP断点续传 HTTP学习笔记+++++
HTTP断点续传原理是这样的：
1. 客户端需要告诉服务器端从哪里开始。
2.服务端收到请求,返回206状态。并标识续传的起始点及结束点
如下实例
1. 客户端传递请求信息给web服务器，要求从200070字节开始。。
GET /down.zip HTTP/1.1
User-Agent：NetFox
RANGE: bytes = 200070-
Accept：text/html，image/gif，image/jpeg，*；q=.2，*/*；q=.2
2.服务端收到这个请求以后，返回信息
206
Content-Length = 100222222
Content-Range = bytes 200070 – 100222221/100222222
Content-Type=application/octet-stream
注意：服务端状态 206； Content-Range = bytes （客户端请求续传起始点） – （下载文件大小-1）/（下载文件大小）
在PHP中，是利用$_SERVER['HTTP-RANGE']来取得客户端请求的续传起始点。所以其实现代码如下:
view plainprint?
<?php  
/** 
 *  PHP-HTTP断点续传实现 
 *  @param string $path: 文件所在路径 
 *  @param string $file: 文件名 
 *  @return void 
 */  
function download($path,$file) {  
    $real = $path.'/'.$file;  
    if(!file_exists($real)) {  
        return false;  
    }  
    $size = filesize($real);  
    $size2 = $size-1;  
    $range = 0;  
    if(isset($_SERVER['HTTP_RANGE'])) {  
        header('HTTP /1.1 206 Partial Content');  
        $range = str_replace('=','-',$_SERVER['HTTP_RANGE']);  
        $range = explode('-',$range);  
        $range = trim($range[1]);  
       header('Content-Length:'.$size);  
       header('Content-Range: bytes '.$range.'-'.$size2.'/'.$size);  
    } else {  
        header('Content-Length:'.$size);  
        header('Content-Range: bytes 0-'.$size2.'/'.$size);  
    }  
    header('Accenpt-Ranges: bytes');  
    header('application/octet-stream');  
    header("Cache-control: public");  
    header("Pragma: public");  
    $ua = $_SERVER['HTTP_USER_AGENT'];  
    if(preg_match('/MISE/',$ua)) {  
        $ie_filename = str_replace('+','%20',urlencode($file));  
        header('Content-Dispositon:attachment; filename='.$ie_filename);  
    }  else {  
        header('Content-Dispositon:attachment; filename='.$file);  
    }  
    $fp = fopen($real,'rb+'); 
    fseek($fp,$range);   
    while(!feof($fp)) {  
        set_time_limit(0);  
        print(fread($fp,1024));  
        flush();  
        ob_flush();  
    }  
    fclose($fp);  
}  
?> 


++++PHP长网址生成短网址的方法+++++
test.php :
<?php
header("Content-Type:text/html;charset=UTF-8");
function base62($x){
$show = '';
while($x>0){
$s = $x % 62;
if ($s > 35){
$s = chr($s + 61);
}else if ($s > 5 && $S<=35){
$s = chr($s + 55);
} 
$show .= $s;
$x = floor($x/62);
}
return $show;
}
//生成短网址
function url_short($url){
$url = crc32($url);
$result = sprintf("%u",$url);
return base62($result);
}
echo ("生成短网址为：<a href='http://$_POST[url]'>".url_short($_POST['url'])."</a>");
 ?>

 <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>urlShort</title>
</head>
<body>
<form action="test.php" method="post">
<input type="text" size="16" name="url" value="输入网址" onfocus="if(this.value=='输入网址')
          {this.value='';}" onblur="if(this.value==''){this.value='输入网址'};">
<input type="submit" value=" 生成 " />
</form>
</body>
</html>


+++++php生成网站rss的方法++++++
<?php 
if (defined('_class_rss_php')) return; 
define('_class_rss_php教程',1); 
/** 

 *  使用说明： 

 *  $rss = new rss('redfox','http://jb51.net/',"redfox's blog"); 

 *  $rss->additem('rss class',"http://www.jb51.net","xxx",date()); 

 *  $rss->additem(...); 

 *  $rss->savetofile(...); 

 */ 
class rss { 
   //public 
   $rss_ver = "2.0"; 

   $channel_title = ''; 

   $channel_link = ''; 

   $channel_description = ''; 

   $language = 'zh_cn'; 

   $copyright = ''; 

   $webmaster = ''; 

   $pubdate = ''; 

   $lastbuilddate = ''; 

   $generator = 'redfox rss generator'; 
   $content = ''; 
   $items = array(); 
   function rss($title, $link, $description) { 

       $this->channel_title = $title; 

       $this->channel_link = $link; 

       $this->channel_description = $description; 

       $this->pubdate = date('y-m-d h:i:s',time()); 

       $this->lastbuilddate = date('y-m-d h:i:s',time()); 
   } 
   function additem($title, $link, $description ,$pubdate) { 
       $this->items[] = array('titile' => $title , 
                        'link' => $link, 
                        'description' => $description, 
                        'pubdate' => $pubdate); 
   } 
   function buildrss() { 
       $s = "<!--l version="1.0" encoding="gb2312"--> "; 
       // start channel 
       $s .= " ";
       $s .= "<link />{$this->channel_link} "; 
       $s .= "{$this->channel_description} "; 
       $s .= "{$this->language} "; 
       if (!emptyempty($this->copyright)) { 
       $s .= "{$this->copyright} "; 
       } 
       if (!emptyempty($this->webmaster)) { 
          $s .= "{$this->webmaster} "; 
       } 
       if (!emptyempty($this->pubdate)) { 
          $s .= "{$this->pubdate} "; 
       } 
       if (!emptyempty($this->lastbuilddate)) { 
          $s .= "{$this->lastbuilddate} "; 
       } 
       if (!emptyempty($this->generator)) { 
          $s .= "{$this->generator} "; 
       } 
       // start items 
       for ($i=0;$iitems),$i++) { 
           $s .= " "; 
           $s .= " "; 
           $s .= "<link />{$this->items[$i]['link']} "; 
           $s .= "<!--data[{$thi-->items[$i]['description']}]]> "; 
           $s .= "{$this->items[$i]['pubdate']} ";           
           $s .= " "; 
       } 
      // close channel 
      $s .= " "; 
      $this->content = $s; 
   } 
   function show() { 
       if (emptyempty($this->content)) $this->buildrss(); 
       header('content-type:text/xml'); 
       echo($this->content); 
   } 
   function savetofile($fname) { 
       if (emptyempty($this->content)) $this->buildrss(); 
       $handle = fopen($fname, 'wb'); 
       if ($handle === false)  return false; 
       fwrite($handle, $this->content); 
       fclose($handle); 
   } 
} 
?>


++++PHP命中算法（其实就是概率的东西，无限接近于平均数）++++
function hitted($rate,&$num){
    if (is_string($rate))
        $rate = ( float ) $rate;
    if ($rate > 1)
        throw new ArgumentException('传入的概率值 $rate 必须是 0~1 之间的浮点数或整数(0|1)。', -1);
    $r = 100 * $rate;
    $v = mt_rand(1, 100);
    $num = $v;
    if ($v <= $r)
        return true;
    return false;
}
$i = 0;
$ratio = 0.5;
$_hitted = 0;
for($i=1 ; $i < 101 ; $i++ ){
    $num = 0;
    if(hitted($ratio,$num)){
        print "第 $i 次 随机数 $num 已命中".chr(10);
        $_hitted++;
    }else{
        print "第 $i 次 随机数 $num 未命中".chr(10);
    }
}
print "100次 总共命中 $_hitted 次".chr(10);



++++热血拳皇留存率算法及源码 +++++
热血拳皇之1.涉及的统计表
| dgs_remain | CREATE TABLE `dgs_remain` (
  `auto_id` int(11) NOT NULL AUTO_INCREMENT,
  `reg_num` int(11) NOT NULL DEFAULT '0' COMMENT '每日新注册用户',
  `statistics_time` int(11) NOT NULL DEFAULT '0' COMMENT '统计时间',
  `statistics_date` int(11) NOT NULL DEFAULT '0' COMMENT '统计日期',
  `second_day_num` smallint(6) DEFAULT NULL COMMENT '次日留存原数据(当前日期次日还在登录的人数)',
  `third_day_num` smallint(6) DEFAULT NULL COMMENT '三日留存原数据,当前日期后三日还在登录的人数',
  `seven_day_num` smallint(6) DEFAULT NULL COMMENT '七日留存原数据,当前日期后七日还在登录的人数',
  `thirty_day_num` smallint(6) DEFAULT NULL COMMENT '三十日留存原数据,当前日期后三十日还在登录的人数',
  `platform_id` int(11) NOT NULL COMMENT '平台ID',
  `dist_id` int(11) NOT NULL COMMENT '服务器ID',
  `fifty_day_num` smallint(6) DEFAULT NULL COMMENT '15日留存,当前日期后15日还在登录的人数',
  PRIMARY KEY (`auto_id`),
  UNIQUE KEY `UIndex_1` (`statistics_date`,`platform_id`,`dist_id`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 |

热血拳皇之2.放在游戏服务端的守护进程：
<?php
/**
 * Created by PhpStorm.
 * User: buhuan
 * Date: 14-4-11
 * Time: 下午1:46
 * 给GM端推留存率的数据
 */
namespace Application\Process;
use Application\Core\ProcessBase;
use Application\Core\Pusher;
use Application\Interfaces\IProcess;

class Retention extends ProcessBase implements IProcess{

    private $diff = 60;//时间间隔 分钟
    private $push_hour = 0;//推送的小时  0就是0点推送

    /**
     * 开始执行命令。
     */
    function execute()
    {
        print '留存统计守护进程启动[pid:'.getmypid().']@'.date('Y-m-d H:i:s').'|检测间隔为'.$this->diff.'分钟,推送间隔为1天'.chr(10);
        $timediff = $this->diff * 60;
        // TODO: Implement execute() method.
        while(1){
            $hour = intval(date('H'));
            if($hour == $this->push_hour){//如果是$push_hour点 则开始发送数据
                $time = time();
                $current_time = $time-24*60*60;//计算的基准时间
                $start_datetime = date('Y-m-d',$current_time).' 00:00:00';
                $end_datetime = date('Y-m-d',$current_time).' 23:59:59';
                //查询当前前一天的注册人数
                $sql = "SELECT COUNT(user_id) as reg_num FROM user_info_ext WHERE user_active_time > '$start_datetime' AND user_active_time < '$end_datetime'";
                $d = $this->scope->db->fetch($sql);
                $reg_num = $d['reg_num'];

                //查询当前前一天登录的用户
                $sql = "SELECT user_id FROM user_info_ext WHERE user_last_login_time > '$start_datetime' AND user_last_login_time < '$end_datetime' ";
                $d = $this->scope->db->fetchAll($sql);
                $login_users = $d;

                $reg_nums = array();
                $reg_nums['day1'] = $this->nDayUsers(1,$current_time);
                $reg_nums['day3'] = $this->nDayUsers(3,$current_time);
                $reg_nums['day7'] = $this->nDayUsers(7,$current_time);
                $reg_nums['day15'] = $this->nDayUsers(15,$current_time);
                $reg_nums['day30'] = $this->nDayUsers(30,$current_time);

                $data = array(
                    'currentTime' => $time,
                    'reg_num' => $reg_num,
                    'reg_nums' => $reg_nums,
                    'login_users' => $login_users
                );

                Pusher::instance($this->scope)->doPushStat(106,$data);
            }
            sleep($timediff);
        }
    }


    /**
     * @param int $n 1=1日 3=3日。。。
     * @param int $current_time 基准时间
     * @return array
     */
    private function nDayDate($n,$current_time){
        $diff = 24*60*60;
        $start_datetime = date('Y-m-d',$current_time-$n*$diff).' 00:00:00';
        $end_datetime = date('Y-m-d',$current_time-$n*$diff).' 23:59:59';
        $date = array();
        $date[0] = $start_datetime;
        $date[1] = $end_datetime;
        return $date;
    }

    /**
     * 得到基准日期前第n日的注册用户集合
     * @param $n
     * @param $current_time
     * @return array
     */
    private function nDayUsers($n,$current_time){
        $dates = $this->nDayDate($n,$current_time);
        //查询次日注册用户
        $sql = "SELECT user_id FROM user_info_ext WHERE user_active_time > '{$dates[0]}' AND user_active_time < '{$dates[1]}'";
        return $this->scope->db->fetchAll($sql);
    }
}

热血拳皇之3.综合服务端的接口 用来接收游戏端发送过来的数据如下面的&$data ：
<?php
/**
 * Created by PhpStorm.
 * User: buhuan
 * Date: 14-4-11
 * Time: 上午11:31
 * 留存
 */
namespace Apps\Process\GearmanWorker;
use Apps\Common\Retention;
use Apps\Interfaces\IGearmanWorker;
use Apps\Process\GearmanWorkerBase;

class RetentionStatistics extends GearmanWorkerBase implements IGearmanWorker{
    /**
     * 释放资源。
     */
    function dispose()
    {
        // TODO: Implement dispose() method.
    }

    /**
     * 处理任务数据。
     *
     * @param string $data 指定任务数据对象引用。
     * @param int $p 指定平台ID。
     * @param int $s 指定服务器ID。
     */
    function execute(&$data, $p, $s)
    {
        $currentTime = intval($data['currentTime'])-24*60*60;
        $reg_num = $data['reg_num'];
        $reg_nums = $data['reg_nums'];
        $login_users = $data['login_users'];

        // TODO: Implement execute() method.
        Retention::instance($this->scope)
                    ->setCurrentTime($currentTime)
                    ->setDist_id($s)
                    ->setPlatform_id($p)
                    ->setRegNum($reg_num)
                    ->setRegNums($reg_nums)
                    ->setLoginUsers($login_users)
                    ->createData()
                    ->setRetentionData(1)
                    ->setRetentionData(3)
                    ->setRetentionData(7)
                    ->setRetentionData(15)
                    ->setRetentionData(30);
    }

}
热血拳皇之4.以上需要用到的留存率的统计类：
<?php
namespace Apps\Common;
use Application\Base\Base;
use Application\Core\Console;
use Application\Core\DbPdo;

/**
 * Created by PhpStorm.
 * User: buhuan
 * Date: 14-4-11
 * Time: 上午10:12
 * 留存率
 */

class Retention extends Base{

    /**
     * @var 当前基准日期时间戳
     */
    private $current_time = 0;

    /**
     * @var array(array('user_id'=>1),array('user_id'=>2)) 当前基准日期时间戳登录的用户（包括user_id）
     */
    private $login_users = NULL;

    private $platform_id = 0;

    private $dist_id = 0;

    /**
     * @var int 当前基准日期的注册数
     */
    private $reg_num = 0;

    /**
     * @var array 统计其他天数的注册用户数组
     * @struct array(
     *      'day1' => array(array('user_id'=>1),array('user_id'=>2)) //前一日
     *      'day3' => array(array('user_id'=>1),array('user_id'=>2)), //前三日
     *      'day7' => array(array('user_id'=>1),array('user_id'=>2)), //前七日
     *      'day15' => array(array('user_id'=>1),array('user_id'=>2)), //前15日
     *      'day30' => array(array('user_id'=>1),array('user_id'=>2))  //前三十日
     *      ...
     * )
     */
    private $reg_nums = NULL;

    public static function instance($scope){
        static $_instance;
        if($_instance == NULL){
            $_instance = new Retention($scope);
        }
        return $_instance;
    }


    function __construct($scope){
       parent::__construct($scope);
    }


    public function setCurrentTime($param){
        $this->current_time = $param;
        return $this;
    }


    public function setLoginUsers($param){
        $this->login_users = $param;
        return $this;
    }


    public  function setPlatform_id($param){
        $this->platform_id = $param;
        return $this;
    }


    public function setDist_id($param){
        $this->dist_id = $param;
        return $this;
    }

    public function setRegNum($param){
        $this->reg_num = $param;
        return $this;
    }

    public function setRegNums($param){
        $this->reg_nums = $param;
        return $this;
    }

    /**
     * 创建当天的统计数据
     */
    public function createData(){
        $this->checkProperties();
        $current_date = strtotime(date('Y-m-d',$this->current_time));
        $sql = "INSERT INTO dgs_remain (reg_num,statistics_time,statistics_date,dist_id,platform_id)
                VALUES ($this->reg_num,$this->current_time,$current_date,$this->dist_id,$this->platform_id)";
        if($this->scope->db->execute($sql,NULL,DbPdo::SQL_TYPE_INSERT))
            Console::debug('当前基准时间'.date('Y-m-d',$this->current_time).'统计数据写入成功');
        return $this;
    }


    /**
     * @param $nDay int N日留存  1日=1 3日=3 ....
     */
    public function setRetentionData($nDay){
            $this->checkProperties();
            $daytime = 24*60*60;
            //===================================================N日留存
            $ratio_day = 0;
            $date = date('Y-m-d',$this->current_time-$daytime*$nDay);//N日的日期
            $time = strtotime($date);//$nDay日的时间戳
            //查找当前日期前$nDay日的新增注册
            $sql = "SELECT reg_num FROM dgs_remain WHERE statistics_date = $time";
            $d = $this->scope->db->fetch($sql);
            $login_users_again = 0;//$nDay日还在登录的用户数
            if(isset($d['reg_num'])){//如果dgs_remain中有当前日期前$nDay日的数据的话 则进行前$nDay日的$nDay日留存更新
                //查找当前日期前$nDay日注册的用户数组
                if(!empty($this->login_users) && !empty($this->reg_nums)){
                    $active_users = $this->reg_nums['day'.$nDay];

                    foreach($this->login_users as $login){
                        foreach($active_users as $active){
                            if($login['user_id'] == $active['user_id']){
                                $login_users_again++;
                                break 1;
                            }
                        }
                    }
                }
            }

            switch($nDay){
                    case 1: $sql = "UPDATE dgs_remain SET second_day_num = $login_users_again
                            WHERE statistics_date = $time and platform_id = $this->platform_id and dist_id = $this->dist_id";
                            break;

                    case 3: $sql = "UPDATE dgs_remain SET third_day_num = $login_users_again
                            WHERE statistics_date = $time and platform_id = $this->platform_id and dist_id = $this->dist_id";
                            break;

                    case 7: $sql = "UPDATE dgs_remain SET seven_day_num = $login_users_again
                            WHERE statistics_date = $time and platform_id = $this->platform_id and dist_id = $this->dist_id";
                            break;

                    case 15: $sql = "UPDATE dgs_remain SET fifty_day_num = $login_users_again
                            WHERE statistics_date = $time and platform_id = $this->platform_id and dist_id = $this->dist_id";
                            break;

                    case 30: $sql = "UPDATE dgs_remain SET thirty_day_num = $login_users_again
                            WHERE statistics_date = $time and platform_id = $this->platform_id and dist_id = $this->dist_id";
                            break;
            }

            $this->scope->db->execute($sql,NULL,DbPdo::SQL_TYPE_UPDATE);
            Console::debug("当前日期".date('Y-m-d',$this->current_time)." 的前 $nDay 日[".$date."]留存率更新成功");
            return $this;
    }


    private function checkProperties(){
        if($this->current_time == 0){
            Console::debug("请设置基准时间戳");
            exit;
        }

        if($this->platform_id == 0){
            Console::debug("请设置平台ID");
            exit;
        }

        if($this->dist_id == 0){
            Console::debug("请设置服务器ID");
            exit;
        }
    }

}




++++php+jquery实现推送数据很6啊++++++++++
<?php
set_time_limit(0);
$timeout = 30;
$starttime = time();
$randnum = 30;
while(true){
 $curtime = time();
 if(  ($curtime - $starttime) > $timeout   ){
  echo 'system is timeout!';
  break;
 }else{
  $n = mt_rand(0, 100);
  if($n < $randnum){
   /*
    * code here 请求数据库或者memcached
    */
   echo '数据更新,推送成功-'.date('Y-m-d H:i:s',strtotime('+7 Hour'));
   break;
  }
 }
 sleep(1);
}
 ?>
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<head>
 <meta http-equiv="content-type" content="text/html;charset=gbk"/>
<script src ="http://code.jquery.com/jquery-1.4.1.js">
</script>
<script>
var comnet = {
 send:function(){
    var t = Date.parse(new Date());
    $.ajax({
     url:"test.php",
     data:"t="+t,
     dataType:"html",
     type:"POST",
     success:function(data){
      $('body').append(data+'<br/>');
     },
     complete:function(){
      setTimeout("comnet.send()",30000);
     }
    });
 }
}
$(function(){
 comnet.send();
})
</script>
</head>
<body>
</body>
</html>


+++++php之ticks+++
我们常用tick来进行调试，性能测试，实现简单的多任务，或者做一些后台的I/O操作等等。
function doTicks ()
{
    echo 'Ticks';
}
register_tick_function('doTicks');
declare(ticks = 1) {
    for ($x = 1; $x < 10; ++ $x) {
        echo $x * $x . '<br />';
    }
}
首先完整的for循环算一个语句，但必须要等循环结束才算，因此在编译时for循环里面的echo 算
第一个语句。所以第一个doTicks是在第一个echo后执行的，也就是1输出后才发生第一个tick事件。
在$x 从1到9的循环中，每个循环包括两个语句，一个echo, 一个for循环。在81输出后，因为echo是
一条语句，因此输出第一个ticks. 同时$x=9的这个for循环也结束了，这又是一条语句,输出第二个
ticks；开始$x=10的循环，但这时已不满足循环条件，for循环执行结束，这个循环又是一个语句，
这时输出第三个ticks。最后declare本身也算一条语句，所以又输出第四个ticks。



+++PHP画出一片叶子++++++++
// 定义 PI 一分的角度的值
define("PII", M_PI/180);
// 新建图像资源，并定义其背景为 白色，前景色为 黑色
$im    = imagecreate(670,500);
$white = imagecolorallocate($im, 0xFF, 0xFF, 0xFF);
$g     = imagecolorallocate($im, 0x00, 0x00, 0x00);
// 从下面实例化的代码可以得知，初始值 $x, $y, $L, $a 别分为 300, 500, 100, 270
function drawLeaf($g, $x, $y, $L, $a) {
    global $im;
    $B = 50;
    $C = 9;
    $s1 = 2;
    $s2 = 3 ;
    $s3 = 1.2;
    if($L > $s1) {
        // 计算叶子的定位 上面
        $x2  = $x + $L * cos($a * PII);
        $y2  = $y + $L * sin($a * PII);
        $x2R = $x2 + $L / $s2 * cos(($a + $B) * PII);
        $y2R = $y2 + $L / $s2 * sin(($a + $B) * PII);
        $x2L = $x2 + $L / $s2 * cos(($a - $B) * PII);
        $y2L = $y2 + $L / $s2 * sin(($a - $B) * PII);

        // 计算叶子的定位 下面
        $x1  = $x + $L / $s2 * cos($a * PII);
        $y1  = $y + $L / $s2 * sin($a * PII);
        $x1L = $x1 + $L / $s2 * cos(($a - $B) * PII);
        $y1L = $y1 + $L / $s2 * sin(($a - $B) * PII);
        $x1R = $x1 + $L / $s2 * cos(($a + $B) * PII);
        $y1R = $y1 + $L / $s2 * sin(($a + $B) * PII);

        // 别分画叶子的主干以及叶面
        ImageLine($im, (int)$x,  (int)$y,  (int)$x2,  (int)$y2,  $g);
        ImageLine($im, (int)$x2, (int)$y2, (int)$x2R, (int)$y2R, $g);
        ImageLine($im, (int)$x2, (int)$y2, (int)$x2L, (int)$y2L, $g);
        ImageLine($im, (int)$x1, (int)$y1, (int)$x1L, (int)$y1L, $g);
        ImageLine($im, (int)$x1, (int)$y1, (int)$x1R, (int)$y1R, $g);

        // 再次递归调用本身
        drawLeaf($g, $x2,  $y2,  $L / $s3, $a + $C);
        drawLeaf($g, $x2R, $y2R, $L / $s2, $a + $B);
        drawLeaf($g, $x2L, $y2L, $L / $s2, $a - $B);
        drawLeaf($g, $x1L, $y1L, $L / $s2, $a - $B);
        drawLeaf($g, $x1R, $y1R, $L / $s2, $a + $B);
    }
}
// 实例化
drawLeaf($g, 300, 500, 100, 270);
header("Content-type: image/png");
imagepng($im);


++++转换字符串至NCR++++++
同个页面呈现不同语言字符的编码使用 UTF-8 是目前主流的应用方案。但是在一些极端的情况下，
我们不得不在某些西方字符编码的页面上显示中文。
原理很简单，就是把除了 ISO-8859-1 编码中前 128 个字符以外的所
有其他的编码都用 NCR(Numeric character reference) 来表示。比如
「汉字」这两个字，如果我们写成「&#27721;&#23383;」这种形式，
那么它在任意字符集下都可以正确显示。
/**
 * nochaoscode - 转换字符串至 NCR
 *
 * @param  string $str     原字符串
 * @param  string $encode  原字符串的编码，默认 UTF-8
 * @return string 原字符串的 NCR 字符
 * @see http://en.wikipedia.org/wiki/Numeric_character_reference
 */
function nochaoscode($str, $encode = "utf-8")
{
    if (!function_exists("iconv") || !function_exists("mb_strlen")) {
        return $str;
    }

    $str = iconv($encode, "utf-16", $str); 
    for ($i = 0; $i < mb_strlen($str); $i+=2) { 
        $code = ord($str{$i}) * 256 + ord($str{$i + 1}); 
        if ($code < 128) {
            $output .= chr($code); 
        } else if ($code != 65279) {
            $output .= "&#" . $code . ";"; 
        }
    }
    return $output; 



+++++计算数组的差集，不使用array_diff++++++
function array_diff($array_1, $array_2) {
    foreach ($array_1 as $key => $item) {
        if (in_array($item, $array_2, true)) {
            unset($array_1[$key]);
        }
    }
    return $array_1;
}
这个效率跟array_diff差不多，优化版在下面：
function array_diff($array_1, $array_2) {
    $array_2 = array_flip($array_2);
    foreach ($array_1 as $key => $item) {
        if (isset($array_2[$item])) {
            unset($array_1[$key]);
        }
     }
    return $array_1;
}
这个效率更高，因为键是进行 HASH 组织的，查找很快；
而 Value 只是由 Key 组织存放，本身没有索引，每次查找都是遍历。


++++二维数组排序++++
function array_sort($arr,$row,$type='asc'){
	$arr_temp=array();
	foreach($arr as $v ){
		$arr-temp[$v[$row]] =$v;
	}
	if($type == 'asc'){
		ksort($arr_temp);
	}
	elseif($type =='desc'){
		krsort($arr_temp);
	}
	else{
	  
	}
        return $arr_temp;
}
$person=array(
array('id'=>2,'name'=>'zhangsan','age'=>23),
array('id'=>5,'name'=>'lisi','age'=>28),
array('id'=>3,'name'=>'wangwu','age'=>17),
);
$person=array_sort($person,'name');
var_dump($person);

+++++5种获取文件全路径的函数++++
1.
$path=str_replace('\\','/',__FILE__);
2.
function ext_name1($path){
	return strrchr($path,'.');
}
3.function ext_name2($path){
	return substr($path,strpos($path,'.'));
}
4. function ext_name3($path){
	$path_parts=pathinfo($path);
	return $path_parts['extension'];
}
5.function ext_name4($path){
	$arr=explode('.',$path);
	return $arr[count($arr)-1];
}
6.function ext_name5($path){
	$pattern = '/^[^\.]+\.([\w]+)$/';
	return preg_replace($pattern,'${1}',basename($path));
}


+++用单态设计模式方法设计类++++++
用php5代码编写类实现在每次对数据库连接的访问中都只能获得唯一的一个数据库连接，具体连接数据库的代码可忽略。
class mysql{
	private static instance = null;
	private function __construct (){
		mysql_connect('host','root','pwd');
	}
	public function getInstance(){
		if(!self::$instance instanceof self){
			self::$instance = new self;
		}
		return self::$instance;
	}
}

++++++能够创建多级目录的php函数+++++
function create_dir($path,$mode=0777){
	if(is_dir($path)){
		echo "该目录已经存在";
	}
	else{
		if(mkdir($path,$mode,true)){
			echo "创建目录成功";
		}
		else{
			echo "创建目录失败";
		}
	}
}

++++++php确保多个进程同时写入同一个文件成功++++
关键点：加锁
$fp=fopen("lock.txt","w+");
if(flock($fp,LOCK_EX)){
	fwrite($fp,"write something");
	flock($fp,LOCK_IN);
}
else{
	echo "file is locking";
}
fclose($fp);

++++编写一个函数，递归遍历，实现无限分类++++
function tree($arr,$pid=0,$level=0){
	foreach($arr ad $v){
	//如果是顶级分类，则将其存到$list中
	//并以此节点作为根节点，遍历找其他节点
		if($v['parent_id'] == $pid){
			$v['level'] =$level;
			$list[] = $v;
			tree($arr,$v['cat_id'],$level+1);
		}
	}
	return $list;
}

+++++计算两个文件的相对路径+++++
function relative_path($path1,$path2){
	$arr1=explode('/',dirname($path1));
        $arr2=explode('/',dirname($path2));
	for($i=0;$len=count($arr2);$i<$len;$i++){
		if($arr[$i]!=$arr2[$i]){
			break;
		}
	}
	if($i<$len){
		$return_path=array_fill(0,$len-$i,'..');
	}
	$return_path=array_merge($return_path,array_slice($arr1,$i));
	return implode('/',$return_path);
}
$a="/a/b/c/de.php";
$b="/a/b/12/34/c.php";
echo relative_path($a,$b);

$res=fopen('http://www.qq.com','rb');
$contents=stream_get_contents($res);
fclose($res);
echo $res;
上面的就等于：
echo file_get_contents("http://www.qq.com");

+++++去除<、/、/、>标签+++++
function strip_html_tags($str)
{ 
	$pattern ="/<(.+?)[\s]*\/?[\s]*>/";
	return preg_replace($pattern,'',$str);
}
$html=file_get_contents("http://www.qq.com");
echo strip_html_tags($html);

+++验证一个字符串是否是合法的日期格式+++++
function checkDateTime($data){
	if(date('Y-m-d H:i:s',strtotime($data)) == $data){
		return true;
	}
	else{
		return false;
	}
}

++++++使对象可以像数组一样进行foreach循环，属性是私有+++++
class Test implements Iterator{
private $item=array(
	$id=>1,'name'=>'php'
);
public function rewind(){
	reset($this->item);
}
public function current(){
	return current($this-<item);
}
public function key(){
	return key($this->item);
}
public function next(){
	return next($this->item);
}
public function valid(){
	return($this->current() !== false);
}
}
$t=new Test;
foreach($t as $k=>$v){
echo $k.'--->'.$v.'<br>';
}



+++++PHP实现一个双向队列+++++++
class Deque{
	private $queue=array();
public function addFirst($item){
	return array_unshift($this->queue,$item);
}
public function addLast($item){
	return array_push($this->queue,$item);
}
public function removeFirst(){
	return array_shift($this->queue);
}
public function removeLast(){
	return array_pop($this->queue);
}
}


++++通用二维数组排序算法+++++++++
function diy_sort($arr,$keys,$order=0){
	if(!is_array($arr)){
		return false;
	}
        $keyvalue=array();
	foreach($arr as $key=>$val){
 		$keyvalue[$key]=$val[$keys];
	}
	if($order==0){
		asort($keyvalue);
	}
	else{
		arsort($keyvalue);
	}
	reset($keyvalue);

	foreach($keyvalue as $key=>$vals){
		$keysort[$key]=$key;
	}
	$new_array=array();
	foreach($keysort as $key=>$val){
		$new_array[$key]=$arr[$val];
	}
	return $new_array;
}


+++++洗牌算法+++++++
$card_num=54;
function wash_card($card_num){
	$cards=$tmp=array();
	for($i=0;$i<$card_num;$i++){
		$tmp[$i]=$i;
	}
	for($i=0;$i<$card_num;$i++){
	$index=rand(0,$card_num-$i-1);
	$cards[$i]=$tmp[$index];
	unset($tmp[$index]);
	$tmp=array_values($tmp);
	}
	return $cards;
}



+++转变文件内容+++++
$fif=file_get_contents('online.txt');
$fif=ucwords($fif);
file_put_contents('online.txt',$fif);



++++防止外部页面提交表单+++++++
<?php
session_start();
if(isset($_POST['name'])&&!empty($_POST['name'])){
	if($_POST['check']==$_SESSION['check']){
		echo "success";
	}
	else{
		echo "failed";
	}
}
$token=md5(uniqid(rand(),true));
$_SESSION['check']=$token;
?>
<form action="" method="post">
	<input type="text" name="name" /><br>
	<input type="text" name="check" value="<?php 
	echo  $token;
	?>"/><br>
	<input type="submit" value="submit" />
</form>


+++++要求每隔5分钟执行一次脚本five.php，关闭浏览器亦可+++++
ignore_user_abort();//关闭浏览器，PHP也能执行
set_time_limit(0); //无限执行下去
$inteval=60*5;
do{
sleep($inteval);
}
while(true);



++++PHP隐藏IP后一位或者两位的方法++++++++
    $ip = '255.255.255.255';
　　$reg1 = '/((?:\d+\.){3})\d+/';
　　$reg2 = '~(\d+)\.(\d+)\.(\d+)\.(\d+)~';
　　echo preg_replace($reg1, "\\1*", $ip);//以上输出结果为：255.255.255.*
　　echo "<br>";
　　echo preg_replace($reg2, "$1.$2.*.*", $ip);//以上输出结果为：255.255.*.*


+++++PHP生成XML直接生成字符串++++++
<?PHP
$data_array = array(
    array(
    'title' => 'title1',
    'content' => 'content1',
        'pubdate' => '2009-10-11',
    ),
    array(
    'title' => 'title2',
    'content' => 'content2',
    'pubdate' => '2009-11-11',
    )
);
$title_size = 1;

$xml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
$xml .= "<article>\n";

foreach ($data_array as $data) {
$xml .= create_item($data['title'], $title_size, $data['content'], $data['pubdate']);
}
$xml .= "</article>\n";
echo $xml;


+++++php获取上个月的今天是星期几++++++
function last_month_day($time){
	$strtime=mktime(date('h',$time),date('i',$time),date('s',$time),date('m',$time)-1,date('d',$time),date('Y',$time));
	echo date('Y-m-d',$strtime);
}
$t=last_month_day(strtotime('2007-3-30'));
echo date('w',$t);


++++贝叶斯过滤垃圾评论++++++
<?php
namespace Lib;
class BayesFilter
{
  const SPAMSCALE = 0.5;
	const HEALTHYSCALE = 0.5;
    private $totalWordNum;
	private $sphinx;
	private $db;
	private $redis;
	private static $instance;
	
	public static function getInstance()
    {
		$class = get_called_class();
        if(!self::$instance) self::$instance = new $class();
        return self::$instance;
	}
	
	private function __construct()
    {
		$this->sphinx       = \Utility_SphinxClient::Connection('filter_comment');
		$this->db           = new \JMDbMysqlReadWriteSplit();
		$this->redis        = \JMRedis::getConnectionByName ('filter_comment');
        $this->totalWordNum = $this->redis->get(COMMENT_WORDS_COUNTER);
	}
	
	public function bayes($sentence)
    {
		$list  = $this->splitWords($sentence);
		$count = count($list);
		$pn1   = 1.0;
		$pn2   = 1.0;
		
		for ($i = 0; $i < $count; $i++)
        {
			$probability = $this->getProbability($list[$i]['tokenized']);
			$spam        = $probability['spam'];
			$healthy     = $probability['healthy'];
			$temp        = ($spam * self::SPAMSCALE) / (($spam * self::SPAMSCALE) + ($healthy * self::HEALTHYSCALE));
			$pn1        *= $temp;
			$pn2        *= (1 - $temp);
		}
		@$p = $pn1 / ($pn1 + $pn2);
		return $p * 100;
	}
	
	private function getProbability($word)
    {
		$result = $this->redis->get(COMMENT_WORDS_PREFIX . $word);
		if (empty($result)) {
			$data["spam"]    = 0.4;
			$data["healthy"] = 0.6;
			return $data;
		} else {
			$temp = explode("_", $result);
			$data['spam_num']    = $temp[1];
			$data['healthy_num'] = $temp[0];
		}
		$data["spam"]    = $data['spam_num'] / $this->totalWordNum;
		$data["healthy"] = $data['healthy_num'] / $this->totalWordNum;
		if (($data["spam"] + $data['healthy']) < 0.005) {
			$data["spam"]    = 0.4;
			$data["healthy"] = 0.6;
		}
		$data["spam"]    = ($data["spam"] < 0.001) ? 0.001 : $data["spam"];
		$data["healthy"] = ($data["healthy"] < 0.001) ? 0.001 : $data["healthy"];
		return $data;
	}
	
	public function splitWords($sentence)
    {
		$pattern = '/[\x{4e00}-\x{9fa5}]+/u';
		$matches = "";
		preg_match_all($pattern, $sentence, $matches);
		$sentence = "";
		foreach ($matches[0] as $row) {
			$sentence = $sentence.$row." ";
		}
		$result = $this->sphinx->buildKeywords($sentence, $index = INDEX, false);
		return $result;
	}
}


+++检测图片的主要颜色++++++++
<?php
 /*
 *图片主要（三通道）颜色判断
 *author cuitengwei
 *2014/1/16
 */
 function imgColor($imgUrl) {
    $imageInfo = getimagesize($imgUrl);
    //图片类型
    $imgType = strtolower(substr(image_type_to_extension($imageInfo[2]), 1));
    //对应函数
    $imageFun = 'imagecreatefrom' . ($imgType == 'jpg' ? 'jpeg' : $imgType);
    $i = $imageFun($imgUrl);
    //循环色值
    $rColorNum=$gColorNum=$bColorNum=$total=0;
    for ($x=0;$x<imagesx($i);$x++) {
        for ($y=0;$y<imagesy($i);$y++) {
            $rgb = imagecolorat($i,$x,$y);
            //三通道
            $r = ($rgb >> 16) & 0xFF;
            $g = ($rgb >> 8) & 0xFF;
            $b = $rgb & 0xFF;
            $rColorNum += $r;
            $gColorNum += $g;
            $bColorNum += $b;
            $total++;
        }
    }
    $rgb = array();
    $rgb['r'] = round($rColorNum/$total);
    $rgb['g'] = round($gColorNum/$total);
    $rgb['b'] = round($bColorNum/$total);
    return $rgb;
 }
 /*
 *RGB TO HEX
 *author cuitengwei
 *2014/1/16
 */
 function rgb2html($r, $g=-1, $b=-1)
 {
    if (is_array($r) && sizeof($r) == 3)
        list($r, $g, $b) = $r;
    $r = intval($r); $g = intval($g);
    $b = intval($b);
    $r = dechex($r<0?0:($r>255?255:$r));
    $g = dechex($g<0?0:($g>255?255:$g));
    $b = dechex($b<0?0:($b>255?255:$b));
    $color = (strlen($r) < 2?'0':'').$r;
    $color .= (strlen($g) < 2?'0':'').$g;
    $color .= (strlen($b) < 2?'0':'').$b;
    return '#'.$color;
 }
 /*
 *HEX TO RGB
 *author cuitengwei
 *2014/1/16
 */
 function html2rgb($color)
 {
    if ($color[0] == '#')
        $color = substr($color, 1);
    if (strlen($color) == 6)
        list($r, $g, $b) = array($color[0].$color[1],
                                 $color[2].$color[3],
                                 $color[4].$color[5]);
    elseif (strlen($color) == 3)
        list($r, $g, $b) = array($color[0].$color[0], $color[1].$color[1], $color[2].$color[2]);
    else
        return false;
    $r = hexdec($r); $g = hexdec($g); $b = hexdec($b);
    return array($r, $g, $b);
 }
 //使用示例
$imgUrl = "a.jpeg";//图片地址
var_dump(imgColor($imgUrl));
var_dump(rgb2html(245,255,244));
var_dump(html2rgb('#F08098'));

++++php实时输出++++
ob_end_clean();
ob_implicit_flush(1);
while(1){
    //部分浏览器需要内容达到一定长度了才输出
    echo str_repeat("<div></div>", 200).'hello sjolzy.cn<br />';
    sleep(1);
    //ob_end_flush();
    //ob_flush();
    //flush();
}


++++php迅雷链路算法+++++
其实也就是迅雷的加密算法而已。
$thunder = ("Thunder://QUFodHRwOi8vNjAuMTkxLjYwLjEwODo4MDgwL3hweGlhemFpL0RlZXBpbl9HaG9zdF9YUF9WMTguMC5pc29aWg==");
 
//解密它
$thunder = trim($thunder,'Thunder://');
$c_thunder = base64_decode($thunder);
$c_thunder = ltrim(rtrim($c_thunder,'ZZ'),'AA');
//out [url]http://60.191.60.108:8080/xpxiazai/Deepin_Ghost_XP_V18.0.iso[/url];
 
//加密它
$a_link = 'http://60.191.60.108:8080/xpxiazai/Deepin_Ghost_XP_V18.0.iso';
$a_link = sprintf('AA%sZZ',$a_link);
$a_link = sprintf('Thunder://%s',base64_encode($a_link));
//out Thunder://QUFodHRwOi8vNjAuMTkxLjYwLjEwODo4MDgwL3hweGlhemFpL0RlZXBpbl9HaG9zdF9YUF9WMTguMC5pc29aWg==
?>


+++php简单批量生成不重复的虚拟充值卡号密码 ++++++
$numLen=16;
$pwdLen=10;
$c=100;//生成100组卡号密码
$sNumArr=range(0,9);
$sPwdArr=array_merge($sNumArr,range('A','Z'));
$cards=array();
for($x=0;$x< $c;$x++){
$tempNumStr=array();
for($i=0;$i< $numLen;$i++){
$tempNumStr[]=array_rand($sNumArr);
}
$tempPwdStr=array();
for($i=0;$i< $pwdLen;$i++){
$tempPwdStr[]=$sPwdArr[array_rand($sPwdArr)];
}
$cards[$x]['no']=implode('',$tempNumStr);
$cards[$x]['pwd']=implode('',$tempPwdStr);
}
array_unique($cards);
print_r($cards);


+++++PHP抓取百度阅读实测好用++++
class BaiduYuedu {
    protected $bookId;
    protected $bookToken;
    protected $cookie;
    protected $result;
    public function __construct($bookId, $bookToken, $cookie){
        $this->bookId = $bookId;
        $this->bookToken = $bookToken;
        $this->cookie = $cookie;
    }
    public static function parseNode($node){
        $str = '';
        if(is_string($node['c'])){
            $str .= $node['c'];
        }else if(is_array($node['c'])){
            foreach($node['c'] as $d){
                $str .= self::parseNode($d);
            }
        }
        switch($node['t']){
            case 'h2':
                $str .= "\n\n";
                break;
            case 'br':
            case 'div':
            case 'p':
                $str .= "\n";
                break;
            case 'img':
            case 'span':
                break;
            case 'obj':
                $tmp = '(' . self::parseNode($node['data'][0]) . ')';
                $str .= str_replace("\n", '', $tmp);
                break;
            default:
                trigger_error('Unkown type:'.$node['t'], E_USER_WARNING);
                break;
        }
        return $str;
    }
    public function get($page = 1){
        echo "getting page {$page}...\n";
        $ch = curl_init();
        $url = sprintf('http://wenku.baidu.com/content/%s/?m=%s&type=json&cn=%d', $this->bookId, $this->token, $page);
        curl_setopt_array($ch, array(
            CURLOPT_URL            => $url,
            CURLOPT_RETURNTRANSFER => 1,
            CURLOPT_HEADER         => 0,
            CURLOPT_HTTPHEADER     => array('Cookie: '. $this->cookie)
        ));
        $ret = json_decode(curl_exec($ch), true);
        curl_close($ch);
        $str = '';
        if(!empty($ret)){
            $str .= self::parseNode($ret);
            $str .= $this->get($page + 1);
        }
        return $str;
    }
    public function start(){
        $this->result = $this->get();
    }
    public function getResult(){
        return $this->result;
    }
    public function saveTo($path){
        if(empty($this->result)){
            trigger_error('Result is empty', E_USER_ERROR);
            return;
        }
        file_put_contents($path, $this->result);
        echo "save to {$path}\n";
    }
}
//使用示例
$yuedu = new BaiduYuedu('49422a3769eae009581becba', '8ed1dedb240b11bf0731336eff95093f', '你的百度域cookie');
$yuedu->start();
$yuedu->saveTo('result.txt');


+++++php测试eval()性能+++++
class Ext_View extends Yaf_View_Simple {
    private $tmpPath;
    private $tmpData = array();
    private $include;
    //用于保存模板内容的静态变量
    protected static $_fileArr = array();

    public function display($tplFile, $data = array()) {
        $this->tmpPath = $this->getScriptPath() . '/' . $tplFile;
        if (is_array($data)) {
            $this->tmpData = array_merge($this->tmpData, $data);
        }
        unset($tplFile);
        unset($data);
        extract($this->tmpData, EXTR_OVERWRITE);
        //判断模板文件是否已经在变量中，不存在就读取
        if (!isset(self::$_fileArr[$this->tmpPath])) {
            self::$_fileArr[$this->tmpPath] = file_get_contents($this->tmpPath);
        }
        eval('?>'.self::$_fileArr[$this->tmpPath]);
    }
    //其他代码略
}


+++++PHP生成长微博++++++
仅支持纯文字的长微博生成，而且输入的html只能包含p标签

/**
 * @name cwb
 * php生成长微博
 * @param 
 *       $str 格式化后的html，仅支持p标签
 *       $size 字体大小
 *       $font_path字体路径
 *       $save_path 图片保存路径
 * @todo  增加图片支持
 * @author  leo108 root@leo108.com
 */
function cwb($str,$size,$font_path,$save_path){
    $str = strip_tags($str,'<p>');
    $matches = array();
    preg_match_all("/<p[\s\S]+?<\/p>/", $str, $matches);
    foreach ($matches[0] as $key => $value) {
        $matches[0][$key] = preg_replace("/<p[^>]*>/", "", $matches[0][$key]);
        $matches[0][$key] = str_replace('</p>', '', $matches[0][$key]);
        $matches[0][$key] = trim($matches[0][$key]);
    }
    $newrows = array();
    foreach ($matches[0] as $key => $str) {
        $strlen = mb_strlen($str,'utf-8');
        if ($strlen == 0) {
            continue;
        }
        $text = '';
        for($i = 0; $i < $strlen; $i++) {
            $char = mb_substr($str,$i,1,'utf-8');
            $text . $char;
            $bbox = imagettfbbox($size,0,$font_path,$text.$char);
            if($bbox[2] > 320){
                $newrows[] = $text;
                $text = $char;
            }else{
                $text .= $char;
            }
        }
        $newrows[] = $text;
        $newrows[] = '';
    }
    $height = count($newrows) * 16 + 30;
    $im = imagecreatetruecolor(360, $height);
    $white = imagecolorallocate($im, 255, 255, 255);
    $black = imagecolorallocate($im, 0, 0, 0);
    imagefill($im, 0, 0, $white);
    imagecopyresampled($im,$thumb_im,20,10,0,0,$pic_width,$pic_height,$pic_width,$pic_height);
    $curheight = $pic_height + 30;
    foreach ($newrows as $key => $value) {
        imagettftext($im , $size, 0, 20, $curheight, $black, $font_path, $value);
        $curheight += 16;
    }
    imagepng($im,$save_path);
}



+++PHP计算后序表达式（逆波兰式）++++++++
/**
 * rpn2value
 * 计算逆波兰式
 * @author   leo108 root@leo108.com
 */
function rpn2value($str){
    $arr = explode(',',$str);
    $stack = array();
    $len = count($arr);
    for($i=0;$i<$len;$i++){
        if(is_numeric($arr[$i])){
            array_push($stack,$arr[$i]);
        }else{
            $op = $arr[$i];
            $right = array_pop($stack);
            $left = array_pop($stack);
            eval("\$re = $left $op $right;");
            array_push($stack,$re);
        }   
    }
    return $stack[0];
}
使用方法：
$str = "1,2,3,+,*,4,-,5,+,7,*";
echo rpn2value($str);


+++++PHP实现图片转ASCII图+++++
<?php
function asciifyImage($img,$asciiscale,$asciicolor,$asciialpha,$asciiblock,$asciiinvert,$asciiresolution,$asciichars){
	$strChars = "";
	$strFont = "courier new";
	$aDefaultCharList = str_split(" .,:;i1tfLCG08@");
	$aDefaultColorCharList = str_split(" CGO08@");
	$iScale = $asciiscale?$asciiscale:1;
	$bColor = $asciicolor;
	$bAlpha = $asciialpha;
	$bBlock = $asciiblock;
	$bInvert = $asciiinvert;
	$strResolution = $asciiresolution?$asciiresolution:"medium";
	$aCharList = $asciichars?$asciichars:($bColor ? $aDefaultColorCharList : $aDefaultCharList);
	$fResolution = 0.5;
	switch ($strResolution) {
		case "low" : 	$fResolution = 0.25; break;
		case "medium" : $fResolution = 0.5; break;
		case "high" : 	$fResolution = 1; break;
	}
	$im = imagecreatefrompng($img);
 	$iWidth = ceil(imagesx($im) * $fResolution);
	$iHeight = ceil(imagesy($im) * $fResolution);
	for($y=0;$y<$iHeight;$y+=2){
		for($x=0;$x<$iWidth;$x++){
			$color_index = imagecolorsforindex($im,imagecolorat($im, ceil($x/$fResolution), ceil($y/$fResolution)));
			$iRed = $color_index['red'];
			$iGreen = $color_index['green'];
			$iBlue = $color_index['blue'];
			$iAlpha = $color_index['alpha'];
			if ($iAlpha == 100) {
				$iCharIdx = 0;
			} else {
				$fBrightness = (0.3*$iRed + 0.59*$iGreen + 0.11*$iBlue) / 255;
				$iCharIdx = (count($aCharList)-1) - ceil($fBrightness * (count($aCharList)-1));
			}

			if ($bInvert) {
				$iCharIdx = (count($aCharList)-1) - $iCharIdx;
			}
			$strThisChar = $aCharList[$iCharIdx];

			if ($strThisChar == " ") 
				$strThisChar = "&nbsp;";

			if ($bColor) {
				$strChars .= "<span style='"
					. "color:rgb($iRed,$iGreen,$iBlue);"
					. ($bBlock ? "background-color:rgb($iRed,$iGreen,$iBlue);" : "")
					. ($bAlpha ? "opacity:" . ($iAlpha/255) . ";" : "")
					. "'>" . $strThisChar . "</span>";
			} else {
				$strChars .= $strThisChar;
			}
		}
		$strChars .= "<br/>";
	}
	$fFontSize = (2/$fResolution)*$iScale;
	$fLineHeight = (2/$fResolution)*$iScale;

	$fLetterSpacing = 0;
	if ($strResolution == "low") {
		switch ($iScale) {
			case 1 : $fLetterSpacing = -1; break;
			case 2 : 
			case 3 : $fLetterSpacing = -2.1; break;
			case 4 : $fLetterSpacing = -3.1; break;
			case 5 : $fLetterSpacing = -4.15; break;
		}
	}
	if ($strResolution == "medium") {
		switch ($iScale) {
			case 1 : $fLetterSpacing = 0; break;
			case 2 : $fLetterSpacing = -1; break;
			case 3 : $fLetterSpacing = -1.04; break;
			case 4 : 
			case 5 : $fLetterSpacing = -2.1; break;
		}
	}
	if ($strResolution == "high") {
		switch ($iScale) {
			case 1 : 
			case 2 : $fLetterSpacing = 0; break;
			case 3 : 
			case 4 : 
			case 5 : $fLetterSpacing = -1; break;
		}
	}
	$width = ceil($iWidth/$fResolution)*$iScale;
	$height = ceil($iHeight/$fResolution)*$iScale;
	$style = "display:inline;width:$width px;height:$height px;white-space:pre;margin:0px;padding:0px;font:$strFont";
	$style .= "letter-spacing:$fLetterSpacing px;font-size:$fFontSize px;text-align:left;text-decoration:none";
	echo  "<table style=\"$style\"><tr><td> $strChars</td></tr></table>";
}
asciifyImage('microbe.png',3,false,0,false,false,"medium",null);
?>


++++PHP发送内网广播++++++
$sock = socket_create(AF_INET,SOCK_DGRAM,SOL_UDP);
//使用IPV4格式地址，数据报形式，UDP方式传输数据
socket_set_option($sock,65535,SO_BROADCAST,1);//设置为广播方式
$str = 'hello world';//要发送的字符串
socket_sendto($sock,$str,strlen($str),0,"10.20.132.255",60000);
//发送，10.20.132.255是广播地址，60000是端口
socket_close($sock);//关闭


+++++PHP实现汉字转数字+++++
<?php
class HashTable {
 var $H_table;
 function __construct() {
  $this->H_table = array ();
 }
 function put($key, $value) {
  if (!array_key_exists($key, $this->H_table)) {
   $this->H_table[$key] = $value;
   return null;
  } else {
   $tempValue = $this->H_table[$key];
   $this->H_table[$key] = $value;
   return $tempValue;
  }
 }
 function clear() {
  $this->H_table = null;
  $this->H_table = array ();
 }
 function containsValue($value) {
  while ($curValue = current($this->H_table)) {
   if ($curValue == $value) {
    return true;
   }
   next($this->H_table);
  }
  return false;
 }
 function containsKey($key) {
  if (array_key_exists($key, $this->H_table)) {
   return true;
  } else {
   return false;
  }
 }
 function get($key) {
  if (array_key_exists($key, $this->H_table))
   return $this->H_table[$key];
  else
   return null;
 }
 function isEmpty() {
  return (count($this->H_table) == 0);
 }
 function size() {
  return count($this->H_table);
 }
 function remove($key) {
  $temp_table = array ();
  if (array_key_exists($key, $this->H_table)) {
   $tempValue = $this->H_table[$key];
   while ($curValue = current($this->H_table)) {
    if (!(key($this->H_table) == $key))
     $temp_table[key($this->H_table)] = $curValue;

    next($this->H_table);
   }
   $this->H_table = null;
   $this->H_table = $temp_table;
   return $tempValue;
  } else
   return null;
 }

 function toString() {
  print_r($this->H_table);
 }
}
class hz2sz
{
	private $hz;
	private $hzsz;
	private $hzradix;
	function __construct()
	{
		$this->hz = array("零","一","二","三","四","五","六","七","八","九");
		$this->hzradix = new HashTable();
		$this->hzsz = new HashTable();
		for($i=0;$i<count($this->hz);$i++)
		{
			$this->hzsz->put($this->hz[$i],$i);
		}
		$this->hzradix->put("十",10);
		$this->hzradix->put("百",100);
		$this->hzradix->put("千",1000);
		$this->hzradix->put("万",10000);
		$this->hzradix->put("亿",100000000);
	}
	public function transform($src)
	{
		$tmp1 = explode('亿',$src);
		if(count($tmp1)==2)
		{
			return $this->exchange2($tmp1[0]) * $this->hzradix->get("亿") + $this->exchange2($tmp1[1]);
		}
		else
		{
			return $this->exchange2($tmp1[0]);
		}
	}
	private function exchange2($src)
	{
		$tmp1 = explode('万',$src);
		if(count($tmp1)==2)
		{
			return $this->exchange($tmp1[0]) * $this->hzradix->get("万") + $this->exchange($tmp1[1]);
		}
		else
		{
			return $this->exchange($tmp1[0]);
		}
	}
	private function exchange($src)
	{
		$bg = 0;
		for($i=0;$i<mstrlen($src);$i++)
		{
			$c1 = mb_substr($src,$i,1,'utf-8');
			if($this->hzsz->containsKey($c1))
			{
				if($c1 == "零")
				{
					continue;
				}
				if($i + 1 < mstrlen($src))
				{
					$c2 = mb_substr($src,$i+1,1,'utf-8');
					if($this->hzradix->containsKey($c2))
					{
						$bg += $this->hzsz->get($c1) * $this->hzradix->get($c2);
					}
				}
				else
				{
					$bg += $this->hzsz->get($c1);
				}
			}
			else if($i == 0 && $c1=="十" ¦¦ $i>0 && $c1=="十" && mb_substr($src,$i-1,1,'utf-8')=="零")
			{
				$bg += 10;
			}
		}
		return $bg;
	}
}
function mstrlen($string) {
preg_match_all("/./us", $string, $match);
return count($match[0]);
}
//==========使用方法==============
$hz2sz = new hz2sz();
echo $hz2sz->transform("十三亿零十五万零三百一十二");
?>



+++PHP定时执行代码，带停止功能++++++
定时处理任务
<?php
ignore_user_abort();           // 即使关掉浏览器，PHP也可以继续执行
set_time_limit(0);             // 执行时间为无限制
$i = 1;               // 时间间隔 单位 秒
do
{
	$flag = file_get_contents("f.txt"); //此文件用于控制任务是否执行
	if ($flag == "1")          // 定时执行代码
	{
		$time = date("Y-m-d H:i:s"); 
		$fp = fopen('result.txt','a');
		fwrite($fp,$time."\n");
		fclose($fp);
	}
	elseif ($flag == "0")        // 停止
	{
		die("Die");
	}
	sleep($i);           // 延时$i秒
}while(true);
?>



+++求最大公约数算法+++++
/*
  求最大公约数算法
  1:求两个自然数的最大公约数 设两个变量M和N
  2:如果M < N，则交换M和N
  3:M被N除，得到余数R
  4:判断R＝0，正确则N即为“最大公约数”，否则下一步
  5:将N赋值给M，将R赋值给N，重做第一步。
 */

function Yanggcd($m, $n) {
    if (!is_numeric($m) || !is_numeric($n) || ($m == 0 && $n == 0)) {
        return false;
    }
    if ($n == 0) {
        return 0;
    }
    $r = ''; 
    while ($n != 0) {
        $r = $m % $n;
        $m = $n;
        $n = $r;
    }
    return $m;
}

print_r(Yanggcd(30, 20)."\n");
echo "#################\n";




+++多线程并发抓取函数mfetch+++++
error_reporting(1024);
//多线程并发抓取函数mfetch：
function mfetch(array $params, $method) {
    $mh = curl_multi_init(); //初始化一个curl_multi句柄
    $handles = array();
    foreach ($params as $key => $param) {
        $ch = curl_init(); //初始化一个curl句柄
        $url = $param["url"];
        $data = $param["params"];
        if (strtolower($method) === "get") {
            $url = "$url?" . http_build_query($data); //get方式
        } else {
            curl_setopt($ch, CURLOPT_POSTFIELDS, $data); //post方式
        }
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30);
        curl_setopt($ch, CURLOPT_TIMEOUT, 30);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt($ch, CURLOPT_USERAGENT, $_SERVER["HTTP_USER_AGENT"]);
        curl_multi_add_handle($mh, $ch);
        $handles[$ch] = $key;
        //handles数组用来记录curl句柄对应的key,供后面使用，以保证返回的数据不乱序。
    }
    $running = null;
    $curls = array(); //curl数组用来记录各个curl句柄的返回值
    do { //发起curl请求，并循环等等1/100秒，直到引用参数"$running"为0
        usleep(10000);
        curl_multi_exec($mh, $running);
        while (( $ret = curl_multi_info_read($mh) ) !== false) {
            $curls[$handles[$ret["handle"]]] = $ret; //循环读取curl返回，并根据其句柄对应的key一起记录到$curls数组中,保证返回的数据不乱序
        }
    } while ($running > 0);
    foreach ($curls as $key => &$val) {
        $val["content"] = baidukey(curl_multi_getcontent($val["handle"]));
        curl_multi_remove_handle($mh, $val["handle"]); //移除curl句柄
    }
    curl_multi_close($mh); //关闭curl_multi句柄
    ksort($curls);
    return $curls;
}

function baidukey($result) {
    $pattern = '#class="result.*?class="t".*?<a.*?href="(.*?)".*?>(.*?)</a>#si';
    preg_match_all($pattern, $result, $matches);
    return $matches[2];
}

//测试百度
$keyword = "phper.yang";
$params = array();
for ($i = 0; $i < 10; $i++) {
    $params[$i] = array(
        "url" => "http://www.baidu.com/s",
        "params" => array('wd' => $keyword, 'ie' => "utf-8", 'pn' => $i * 10)
    );
}
$ret = mfetch($params, 'GET');
echo "<pre>";
print_r($params);
print_r($ret);




+++php采集常用函数+++++++
//获得当前的脚本网址
function get_php_url(){
        if(!empty($_SERVER["REQUEST_URI"])){
                $scriptName = $_SERVER["REQUEST_URI"];
                $nowurl = $scriptName;
        }else{
                $scriptName = $_SERVER["PHP_SELF"];
                if(empty($_SERVER["QUERY_STRING"])) $nowurl = $scriptName;
                else $nowurl = $scriptName."?".$_SERVER["QUERY_STRING"];
        }
        return $nowurl;
}
//把全角数字转为半角数字
function GetAlabNum($fnum){
        $nums = array("０","１","２","３","４","５","６","７","８","９");
        $fnums = "0123456789";
        for($i=0;$i<=9;$i++) $fnum = str_replace($nums[$i],$fnums[$i],$fnum);
        $fnum = ereg_replace("[^0-9\.]|^0{1,}","",$fnum);
        if($fnum=="") $fnum=0;
        return $fnum;
}
//去除HTML标记
function Text2Html($txt){
        $txt = str_replace("  ","　",$txt);
        $txt = str_replace("<","&lt;",$txt);
        $txt = str_replace(">","&gt;",$txt);
        $txt = PReg_replace("/[\r\n]{1,}/isU","<br/>\r\n",$txt);
        return $txt;
}


//清除HTML标记
function ClearHtml($str){
        $str = str_replace('<','&lt;',$str);
        $str = str_replace('>','&gt;',$str);
        return $str;
}
//相对路径转化成绝对路径
function relative_to_absolute($content, $feed_url) {
    preg_match('/(http|https|ftp):\/\//', $feed_url, $protocol);
    $server_url = preg_replace("/(http|https|ftp|news):\/\//", "", $feed_url);
    $server_url = preg_replace("/\/.*/", "", $server_url);


    if ($server_url == '') {
        return $content;
    }


    if (isset($protocol[0])) {
        $new_content = preg_replace('/href="\//', 'href="'.$protocol[0].$server_url.'/', $content);
        $new_content = preg_replace('/src="\//', 'src="'.$protocol[0].$server_url.'/', $new_content);
    } else {
        $new_content = $content;
    }
    return $new_content;
}
//取得所有链接
function get_all_url($code){
        preg_match_all('/<a\s+href=["|\']?([^>"\' ]+)["|\']?\s*[^>]*>([^>]+)<\/a>/i',$code,$arr);
        return array('name'=>$arr[2],'url'=>$arr[1]);
}


//获取指定标记中的内容
function get_tag_data($str, $start, $end){
        if ( $start == '' || $end == '' ){
               return;
        }
        $str = explode($start, $str);
        $str = explode($end, $str[1]);
        return $str[0];
}
//HTML表格的每行转为CSV格式数组
function get_tr_array($table) {
        $table = preg_replace("'<td[^>]*?>'si",'"',$table);
        $table = str_replace("</td>",'",',$table);
        $table = str_replace("</tr>","{tr}",$table);
        //去掉 HTML 标记
        $table = preg_replace("'<[\/\!]*?[^<>]*?>'si","",$table);
        //去掉空白字符 
        $table = preg_replace("'([\r\n])[\s]+'","",$table);
        $table = str_replace(" ","",$table);
        $table = str_replace(" ","",$table);


        $table = explode(",{tr}",$table);
        array_pop($table);
        return $table;
}


//将HTML表格的每行每列转为数组，采集表格数据
function get_td_array($table) {
        $table = preg_replace("'<table[^>]*?>'si","",$table);
        $table = preg_replace("'<tr[^>]*?>'si","",$table);
        $table = preg_replace("'<td[^>]*?>'si","",$table);
        $table = str_replace("</tr>","{tr}",$table);
        $table = str_replace("</td>","{td}",$table);
        //去掉 HTML 标记
        $table = preg_replace("'<[\/\!]*?[^<>]*?>'si","",$table);
        //去掉空白字符 
        $table = preg_replace("'([\r\n])[\s]+'","",$table);
        $table = str_replace(" ","",$table);
        $table = str_replace(" ","",$table);
       
        $table = explode('{tr}', $table);
        array_pop($table);
        foreach ($table as $key=>$tr) {
                $td = explode('{td}', $tr);
                array_pop($td);
            $td_array[] = $td;
        }
        return $td_array;
}


//返回字符串中的所有单词 $distinct=true 去除重复
function split_en_str($str,$distinct=true) {
        preg_match_all('/([a-zA-Z]+)/',$str,$match);
        if ($distinct == true) {
                $match[1] = array_unique($match[1]);
        }
        sort($match[1]);
        return $match[1];
}



+++thinkphp中分页类++++++
/*
*   分页
*   $pamap 分页带入参数
*/
function Paging($mod,$map,$field=true,$limit='10',$order='id desc',$pamap) {
		$model=M($mod);
		$count = $model->where($map)->count();
		$Page = new \Think\Page($count,$limit);
                $Page->setConfig('next', '下一页');
                $Page->setConfig('prev', '上一页');
        //分页跳转的时候保证查询条件
        if(empty($pamap)) {$pamap =  $map ;}
        foreach($pamap as $key=>$val){
            $Page->parameter[$key] = urlencode($val); //urlencode 将字符串以URL编码 不支持数组
        }
		$show = $Page->show();// 分页显示输出
		
		// 进行分页数据查询 注意limit方法的参数要使用Page类的属性
		$list = $model->where($map)->order($order)->limit($Page->firstRow.','.$Page->listRows)->select();
		$arr=array();
		$arr['list']=$list;
		$arr['show']=$show;
                $arr['tolnum'] = $count;
		return $arr;
		 
 }


++++php邮件方法（未测试）++++++
$server = "smtp.163.com";
$port = 25;//默认25
$username = "@163.com" ;
$password = "";//密码
$sendto = "";//邮件接收者地址
$subject = "test title2";
$content = "test content2";

$header = "MIME-Version:1.0\r\n";  
$header .= "To: ".$sendto."\r\n";  
$header .= "From: $username<$username>\r\n";  
$header .= "Subject: ".$subject."\r\n";  

$data = $header."\r\n".$content;//邮件内容

$sock = socket_create(AF_INET,SOCK_STREAM,SOL_TCP);
if(socket_connect($sock,$server,$port)===false)socket_strerror(socket_last_error());
echo socket_read($sock,100)."";
socket_write($sock,"HELO lyz810\r\n");
echo socket_read($sock,100)."";
socket_write($sock,"AUTH LOGIN\r\n");
echo socket_read($sock,100)."";
socket_write($sock,base64_encode($username)."\r\n");
echo socket_read($sock,100)."";
socket_write($sock,base64_encode($password)."\r\n");
echo socket_read($sock,100)."";
socket_write($sock,"MAIL FROM:<".$username.">\r\n");
echo socket_read($sock,100)."";
socket_write($sock,"RCPT TO:<".$sendto.">\r\n");
echo socket_read($sock,100)."";
socket_write($sock,"DATA\r\n");
echo socket_read($sock,100)."";
socket_write($sock,$data."\r\n.\r\n");
socket_write($sock,"QUIT");
echo socket_read($sock,100)."";




+++PHP猜数字游戏，写法不错++++++
@session_start();
echo <<<EOT
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Language" content="UTF-8" />
EOT;

class guess{
 var $num=0;
 var $step=0;
 var $newgame=false;
 var $message="";
 function guess(){
   if(!isset($_SESSION['num'])){
     $_SESSION['num']=rand(0,100);
     $_SESSION['step']=0;
     $this->newgame=true;
   }
   $this->num=$_SESSION['num'];
   $this->step=$_SESSION['step'];
   //echo $this->num;
 }
 function add_step(){
   $this->step++;
   $_SESSION['step']=$this->step;
 }
 function check(){
   if($this->newgame==true){
     $this->message="游戏开始";
     $this->show_form();
   }else{
     if(isset($_POST['mynum'])){
       $this->add_step();
       $this->message="你猜了".$this->step."次，";
       if($_POST['mynum']==$this->num){
         $this->show_ok();
       }else{
         if($_POST['mynum']>$this->num)
           $this->message.="你猜的数过大";
         else
           $this->message.="你猜的数过小";

         $this->show_form();
       }
     }else{
       $this->show_form();
     }
   }
 }
 function show_form(){
   $form=$this->message.'<form method=post action="">
     <input type="text" name="mynum"><input type="submit">
   </form>';
   echo $form;
 }

 function show_ok(){
   unset($_SESSION['num']);
   unset($_SESSION['step']);
   $form=$this->message.'你猜对了！<a href="?">重新开始</a>';
   echo $form;
 }
}
$a=new guess;
$a->check();



+++++PHP日历高效写法++++
@date_default_timezone_set('RPC');
function show_calender(){
  //code by hqlulu
  //date:2007-12-12
  //web: http://www.aslibra.com

  $starttime=microtime();

  //处理请求日期
  $y=  isset($_GET["y"]) ? intval($_GET["y"]) : date("Y");
  $m=  isset($_GET["m"]) ? intval($_GET["m"]) : date("m");
  if($m<1 || $m>12)$m=date("m");
  if($y<=0)$y=date("Y");

  //下个月
  $nm=$m+1;
  if($nm>12){
    $nm=1;
    $ny=$y+1;
  }else{
    $ny=$y;
  }

  //前一月
  $pm=$m-1;
  if($pm<1){
    $pm=12;
    $py=$y-1;
  }else{
    $py=$y;
  }

  //获取本月名称
  $month = date("M",mktime(0, 0, 0, $m, 1, $y));

  //获取本月最后一天
  $lastday = date("d",mktime(0, 0, 0, $nm, 0, $ny));

  //获取开始一天的星期几
  $index = date("w",mktime(0, 0, 0, $m, 1, $y));

  //生成日历头
  echo "<table>\n<thead><tr><th colspan='1'><a href='?y={$py}&m={$pm}'>-</a></th><th colspan='5'> {$y} {$month} </th><th colspan='1'><a href='?y={$ny}&m={$nm}'>+</a></th></tr><thead>\n<tbody><tr><td>日</td><td>一</td><td>二</td><td>三</td><td>四</td><td>五</td><td>六</td></tr>";

  //处理日历
  $row=0;
  $day=1;
  while(1){
    echo "<tr>";
    if($row==0){
      for($i=0;$i<=6;$i++)
        if($i<$index)
          echo "<td>&nbsp;</td>";
        else
          echo "<td>".$day++."</td>";
    }else{
      for($i=0;$i<=6;$i++)
        if($day>$lastday)
          echo "<td>&nbsp;</td>";
        else
          echo "<td>".$day++."</td>";
    }
    echo "</tr>";
    $row++;
    if($day>$lastday)break;
  }
  echo "</table>";

  $endtime=microtime();
  $usedtime=$endtime-$starttime;
  return $usedtime;
}
$run_info=array();
for($i=0;$i<10;$i++)
$run_info[]=show_calender();
print_r($run_info);


+++PHP实现静态缓存++++++
利用ob_start()生成一个缓冲文件。
<?php
ob_start();
?>   
<html>  
<meta charset="utf-8">
<head>PHP实现静态缓存</head>  
<body>  
<table>  
<?php  
for($i = 0; $i < 10; $i++){  
?>    
<tr><td><?php echo $i;?></td></tr>  
<?php  
}  
?>  
</table>  
</body>  
</html>  
  
<?php  
$contents = ob_get_contents();  
file_put_contents('cache.html',$contents);
//生存一个cache.html文件 
?>


+++PHP中array++++++
$arr = array('a','b','c');
    foreach($arr as $key=>$val){
            $val=&$arr[$key];
            print_r($arr);
}
Array 第一次循环，使$val是$arr[0]的引用
(
[0] => a
[1] => b
[2] => c
)
Array 第二次循环，因为$arr[1]赋值给$val,而$val是$arr[0]的引用，因此数组被改变。 同样第二次循环使$val是$arr[1]的引用
(
[0] => b
[1] => b
[2] => c
)
Array 同理
(
[0] => b
[1] => c
[2] => c
)


+++nginx下的php安全隔离++++++
方法1）在Nginx配置文件中加入
fastcgi_param PHP_VALUE "open_basedir=$document_root:/tmp/:/proc/:$document_root/../";

or

fastcgi_param PHP_ADMIN_VALUE "open_basedir=$document_root:/tmp/:/proc/:$document_root/../";

不同的地方是：php_admin_value(php_admin_flag)命令只能用在apache的httpd.conf文件中，而 php_value(php_flag)则是用在.htaccess文件中的,nginx下相同。

因为使用FastCGI，php不是每次都重新启动，所以每个主机sever都需要加入配置，以便每次访问都设置php的open_basedir。

适用 nginx + php5.3以上，php5.2 此方法不生效。

方法2）在php.ini中加入：
open_basedir=./:/tmp/:/proc/
这种方式的设置需要重启php-fpm后生效

方法3）在网站根目录下创建.user.ini并写入：
open_basedir=./:/tmp/:/proc/

这种方式不需要重启nginx或php-fpm服务。安全起见应当取消掉.user.ini文件的写权限。

关于.user.ini文件的详细说明：
http://php.net/manual/zh/configuration.file.per-user.php

方法4）nginx的chroot
完全隔离php和系统，如果需要系统功能的自己创建系统环境，路径也要配成相对隔离的环境。
http://www.baidu.com/s?wd=nginx%20chroot

目前最好的是适用第一种方法。

设置open_basedir的同时最好禁止下执行命令的函数，比如：
shell_exec('ls /etc')仍然查看到/etc目录的文件列表
shell_exec('cat /etc/passwd')仍可查看到/etc/passwd文件的内容

建议禁止的函数如下：
disable_functions = pcntl_alarm, pcntl_fork, pcntl_waitpid, pcntl_wait, pcntl_wifexited, pcntl_wifstopped,
 pcntl_wifsignaled, pcntl_wexitstatus, pcntl_wtermsig, pcntl_wstopsig, pcntl_signal, pcntl_signal_dispatch,
 pcntl_get_last_error, pcntl_strerror, pcntl_sigprocmask, pcntl_sigwaitinfo, pcntl_sigtimedwait, pcntl_exec, 
pcntl_getpriority, pcntl_setpriority, eval, popen, passthru, exec, system, shell_exec, proc_open, proc_get_status, 
chroot, chgrp, chown, ini_alter, ini_restore, dl, pfsockopen, openlog, syslog, readlink, symlink, 
popepassthru, stream_socket_server, fsocket, chdir


++PHP+MYSQL事务机制++++
支持事务的表必须是InnoDB类型
一段事务中只能出现一次:
mysql_query('START TRANSACTION');//开始事务
mysql_query(' ROLLBACK ');//回滚事务
mysql_query('COMMIT');//提交事务
mysql_query('START TRANSACTION');
$dele=mysql_query("delete from ks_zhiding where id = 3 limit 1");
if(!dele){
	mysql_query('ROLLBACK');
	return false;
}
$change=mysql_query("update ks_zhiding set name='change' where id = 5 limit 1 ");
if(!$change){
	mysql_query('ROLLBACK');
	return flase;
}
mysql_query('COMMIT');
亲测通过。


+++php socket客户端代码+++++
class SendDevAction{
    //log日志文件
    private $logDevFile = "";
    //日志字符串
    private $logStr = "";
    //用于发送接收的socket对象
    private $socket;
    //socket连接对象
    private $connect;
    //对方服务器ip
    private $host = "211.155.82.229";
    //服务器端口
    private $port = 14527;
    //接收回传字符串长度
    private $getStrLength = 16384;

    function __construct(){
        //确定日志文件路径，（自定义）
        $this->logDevFile =  date("Y-m-d H:i:s") . "Dev.log";

        //创建一个socket，定义相关属性。AF_INET 在socket中定义为常量值为2，SOCK_STREAM常量值为1，SOL_TCP值为6
        $this->socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP );
        //连接对方机器
        $this->connect = socket_connect ( $this->socket, $this->host, $this->port );

        //第一次握手，如果失败则返回不再执行
        $this->firstHandshake();
    }
    
    //socket第一次握手
    function firstHandshake(){
        //日志写入本次握手时间，和远程服务器(发送+接收)一次算一次握手
        $this->logStr .= "\r\n\r\n".date("Y-m-d H:i:s")."\r\n";
        
        //要发送的字符串
        $sendStr = "hello world";
        //日志写入发送的字符串
        $this->logStr .= $sendStr."\r\n";
        //发送字符串
        socket_write ( $this->socket, $sendStr, strlen ( $sendStr ) );
        
        //接收
        $getStr = socket_read ( $this->socket, $this->getStrLength );
        /*
        //如果接收字符串过大，可循环多次接收直到接收完整
        $getStr = "";
        while(true){
            $getStr .= socket_read( $this->socket,$this->getStrLength,PHP_BINARY_READ);
            //根据回传字符串内容格式判断已接收完全字符串，这里回传字符串以 }] 结尾，并且全文只包含一次 }] 字符串
            if(substr_count($getStr, "}]") > 0){
                break;
            }
        }
        */
        //日志写入接收完成时间
        $this->logStr .= date("Y-m-d H:i:s")."\r\n";
        //日志写入接收字符串
        $this->logStr .= $getStr."\r\n\r\n";
        
        //将日志内容补充写入日志文件文本的最下面，如无日志文件则生成新日志文件
        file_put_contents($this->logDevFile, $this->logStr,FILE_APPEND);
        //关闭socket连接
        socket_close ( $this->connect );
        //关闭socket对象
        socket_close ( $this->socket );
    }
}
//此socket代码只是发送消息的客户端，不是接收的服务器端，服务器端以后补充
$sendDevAction = new SendDevAction();

亲测通过。


++++PHP汉字转拼音++++
class Chs_to_En {
    function Pinyin($_String, $_Code = 'GBK') {
        $_DataKey = "a|ai|an|ang|ao|ba|bai|ban|bang|bao|bei|ben|beng|bi|bian|biao|bie|bin|bing|bo|bu|ca|cai|can|cang|cao|ce|ceng|cha" . "|chai|chan|chang|chao|che|chen|cheng|chi|chong|chou|chu|chuai|chuan|chuang|chui|chun|chuo|ci|cong|cou|cu|" . "cuan|cui|cun|cuo|da|dai|dan|dang|dao|de|deng|di|dian|diao|die|ding|diu|dong|dou|du|duan|dui|dun|duo|e|en|er" . "|fa|fan|fang|fei|fen|feng|fo|fou|fu|ga|gai|gan|gang|gao|ge|gei|gen|geng|gong|gou|gu|gua|guai|guan|guang|gui" . "|gun|guo|ha|hai|han|hang|hao|he|hei|hen|heng|hong|hou|hu|hua|huai|huan|huang|hui|hun|huo|ji|jia|jian|jiang" . "|jiao|jie|jin|jing|jiong|jiu|ju|juan|jue|jun|ka|kai|kan|kang|kao|ke|ken|keng|kong|kou|ku|kua|kuai|kuan|kuang" . "|kui|kun|kuo|la|lai|lan|lang|lao|le|lei|leng|li|lia|lian|liang|liao|lie|lin|ling|liu|long|lou|lu|lv|luan|lue" . "|lun|luo|ma|mai|man|mang|mao|me|mei|men|meng|mi|mian|miao|mie|min|ming|miu|mo|mou|mu|na|nai|nan|nang|nao|ne" . "|nei|nen|neng|ni|nian|niang|niao|nie|nin|ning|niu|nong|nu|nv|nuan|nue|nuo|o|ou|pa|pai|pan|pang|pao|pei|pen" . "|peng|pi|pian|piao|pie|pin|ping|po|pu|qi|qia|qian|qiang|qiao|qie|qin|qing|qiong|qiu|qu|quan|que|qun|ran|rang" . "|rao|re|ren|reng|ri|rong|rou|ru|ruan|rui|run|ruo|sa|sai|san|sang|sao|se|sen|seng|sha|shai|shan|shang|shao|" . "she|shen|sheng|shi|shou|shu|shua|shuai|shuan|shuang|shui|shun|shuo|si|song|sou|su|suan|sui|sun|suo|ta|tai|" . "tan|tang|tao|te|teng|ti|tian|tiao|tie|ting|tong|tou|tu|tuan|tui|tun|tuo|wa|wai|wan|wang|wei|wen|weng|wo|wu" . "|xi|xia|xian|xiang|xiao|xie|xin|xing|xiong|xiu|xu|xuan|xue|xun|ya|yan|yang|yao|ye|yi|yin|ying|yo|yong|you" . "|yu|yuan|yue|yun|za|zai|zan|zang|zao|ze|zei|zen|zeng|zha|zhai|zhan|zhang|zhao|zhe|zhen|zheng|zhi|zhong|" . "zhou|zhu|zhua|zhuai|zhuan|zhuang|zhui|zhun|zhuo|zi|zong|zou|zu|zuan|zui|zun|zuo";
        $_DataValue = "-20319|-20317|-20304|-20295|-20292|-20283|-20265|-20257|-20242|-20230|-20051|-20036|-20032|-20026|-20002|-19990" . "|-19986|-19982|-19976|-19805|-19784|-19775|-19774|-19763|-19756|-19751|-19746|-19741|-19739|-19728|-19725" . "|-19715|-19540|-19531|-19525|-19515|-19500|-19484|-19479|-19467|-19289|-19288|-19281|-19275|-19270|-19263" . "|-19261|-19249|-19243|-19242|-19238|-19235|-19227|-19224|-19218|-19212|-19038|-19023|-19018|-19006|-19003" . "|-18996|-18977|-18961|-18952|-18783|-18774|-18773|-18763|-18756|-18741|-18735|-18731|-18722|-18710|-18697" . "|-18696|-18526|-18518|-18501|-18490|-18478|-18463|-18448|-18447|-18446|-18239|-18237|-18231|-18220|-18211" . "|-18201|-18184|-18183|-18181|-18012|-17997|-17988|-17970|-17964|-17961|-17950|-17947|-17931|-17928|-17922" . "|-17759|-17752|-17733|-17730|-17721|-17703|-17701|-17697|-17692|-17683|-17676|-17496|-17487|-17482|-17468" . "|-17454|-17433|-17427|-17417|-17202|-17185|-16983|-16970|-16942|-16915|-16733|-16708|-16706|-16689|-16664" . "|-16657|-16647|-16474|-16470|-16465|-16459|-16452|-16448|-16433|-16429|-16427|-16423|-16419|-16412|-16407" . "|-16403|-16401|-16393|-16220|-16216|-16212|-16205|-16202|-16187|-16180|-16171|-16169|-16158|-16155|-15959" . "|-15958|-15944|-15933|-15920|-15915|-15903|-15889|-15878|-15707|-15701|-15681|-15667|-15661|-15659|-15652" . "|-15640|-15631|-15625|-15454|-15448|-15436|-15435|-15419|-15416|-15408|-15394|-15385|-15377|-15375|-15369" . "|-15363|-15362|-15183|-15180|-15165|-15158|-15153|-15150|-15149|-15144|-15143|-15141|-15140|-15139|-15128" . "|-15121|-15119|-15117|-15110|-15109|-14941|-14937|-14933|-14930|-14929|-14928|-14926|-14922|-14921|-14914" . "|-14908|-14902|-14894|-14889|-14882|-14873|-14871|-14857|-14678|-14674|-14670|-14668|-14663|-14654|-14645" . "|-14630|-14594|-14429|-14407|-14399|-14384|-14379|-14368|-14355|-14353|-14345|-14170|-14159|-14151|-14149" . "|-14145|-14140|-14137|-14135|-14125|-14123|-14122|-14112|-14109|-14099|-14097|-14094|-14092|-14090|-14087" . "|-14083|-13917|-13914|-13910|-13907|-13906|-13905|-13896|-13894|-13878|-13870|-13859|-13847|-13831|-13658" . "|-13611|-13601|-13406|-13404|-13400|-13398|-13395|-13391|-13387|-13383|-13367|-13359|-13356|-13343|-13340" . "|-13329|-13326|-13318|-13147|-13138|-13120|-13107|-13096|-13095|-13091|-13076|-13068|-13063|-13060|-12888" . "|-12875|-12871|-12860|-12858|-12852|-12849|-12838|-12831|-12829|-12812|-12802|-12607|-12597|-12594|-12585" . "|-12556|-12359|-12346|-12320|-12300|-12120|-12099|-12089|-12074|-12067|-12058|-12039|-11867|-11861|-11847" . "|-11831|-11798|-11781|-11604|-11589|-11536|-11358|-11340|-11339|-11324|-11303|-11097|-11077|-11067|-11055" . "|-11052|-11045|-11041|-11038|-11024|-11020|-11019|-11018|-11014|-10838|-10832|-10815|-10800|-10790|-10780" . "|-10764|-10587|-10544|-10533|-10519|-10331|-10329|-10328|-10322|-10315|-10309|-10307|-10296|-10281|-10274" . "|-10270|-10262|-10260|-10256|-10254";
        $_TDataKey = explode ( '|', $_DataKey );
        $_TDataValue = explode ( '|', $_DataValue );
        $_Data = (PHP_VERSION >= '5.0') ? array_combine ( $_TDataKey, $_TDataValue ) : $this->_Array_Combine ( $_TDataKey, $_TDataValue );
        arsort ( $_Data );
        reset ( $_Data );
        if ($_Code != 'GBK')
            $_String = $this->_U2_Utf8_Gb ( $_String );
        $_Res = '';
        for($i = 0; $i < strlen ( $_String ); $i ++) {
            $_P = ord ( substr ( $_String, $i, 1 ) );
            if ($_P > 160) {
                $_Q = ord ( substr ( $_String, ++ $i, 1 ) );
                $_P = $_P * 256 + $_Q - 65536;
            }
            $_Res .= $this->_Pinyin ( $_P, $_Data ) . ' ';
        }
        // return preg_replace ( "/[^a-z0-9]*/", '', $_Res ); // 排除过滤除小写英文和数字以为的字符
        return $_Res;
    }
    function _Pinyin($_Num, $_Data) {
        if ($_Num > 0 && $_Num < 160)
            return chr ( $_Num );
        elseif ($_Num < - 20319 || $_Num > - 10247)
            return '';
        else {
            foreach ( $_Data as $k => $v ) {
                if ($v <= $_Num)
                    break;
            }
            return $k;
        }
    }
    function _U2_Utf8_Gb($_C) {
        $_String = '';
        if ($_C < 0x80)
            $_String .= $_C;
        elseif ($_C < 0x800) {
            $_String .= chr ( 0xC0 | $_C >> 6 );
            $_String .= chr ( 0x80 | $_C & 0x3F );
        } elseif ($_C < 0x10000) {
            $_String .= chr ( 0xE0 | $_C >> 12 );
            $_String .= chr ( 0x80 | $_C >> 6 & 0x3F );
            $_String .= chr ( 0x80 | $_C & 0x3F );
        } elseif ($_C < 0x200000) {
            $_String .= chr ( 0xF0 | $_C >> 18 );
            $_String .= chr ( 0x80 | $_C >> 12 & 0x3F );
            $_String .= chr ( 0x80 | $_C >> 6 & 0x3F );
            $_String .= chr ( 0x80 | $_C & 0x3F );
        }
        return iconv ( 'UTF-8', 'GBK', $_String ); // 如果当前php页面编码格式是 UTF-8 ，需要将 UTF-8 格式转换成 GBK 格式
    }
    function _Array_Combine($_Arr1, $_Arr2) {
        for($i = 0; $i < count ( $_Arr1 ); $i ++)
            $_Res [$_Arr1 [$i]] = $_Arr2 [$i];
        return $_Res;
    }
}
$chs_to_En = new Chs_to_En ();
// 用法：
// 第二个参数留空则为GBK编码
echo $chs_to_En->Pinyin ( '很丰富' ); // 根据当前php页面编码格式，当前页面编码格式是 GBK 则不用传参数，默认GBK,显然不通过
// 第二个参数随意设置则为UTF-8编码
echo $chs_to_En->Pinyin ( '很丰富', "UTF-8" ); // 当前php页面编码格式是 UTF-8 则添加第二参数 "UTF-8"

亲测通过。


+++php实现ftok函数++++
function ftok($pathname, $proj_id) { 
   $st = @stat($pathname); 
   if (!$st) { 
       return -1; 
   } 
    
   $key = sprintf("%u", (($st['ino'] & 0xffff) | (($st['dev'] & 0xff) << 16) | (($proj_id & 0xff) << 24)));
   return $key; 
}
echo ftok($_SERVER["SCRIPT_FILENAME"], 250);



++++func_get_args()与func_num_args()++++
//func_get_args是获取方法中参数的数组，返回的是一个数组， 
//func_num_args一般写在方法中，用于计数，就是数组的数组长度 
function foo($name, $uid) 
{ 
     $count = func_num_args(); 
     if($count >=1){ 
         echo "函数数组的数量为:{$count}<BR>"; 
     } 
     $list = func_get_args(); 
     for($i=0; $i<count($list); $i++){ 
         echo "{$i}:{$list[$i]}<BR><BR>"; 
     } 
} 
foo("xlc",22); 



+++PHP反射机制++++
reflection.它是指在PHP运行状态中，扩展分析PHP程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。
这种动态获取的信息以及动态调用对象的方法的功能称为反射API。反射是操纵面向对象范型中元模型的API，其功能十分强大，
可帮助我们构建复杂，可扩展的应用。
其用途如：自动加载插件，自动生成文档，甚至可用来扩充PHP语言。
通过ReflectionClass，我们可以得到Person类的以下信息：
     1）常量 Contants
     2）属性 Property Names
     3）方法 Method Names静态
     4）属性 Static Properties
     5）命名空间 Namespace
     6)Person类是否为final或者abstract
class Person {      
    private $_allowDynamicAttributes = false;  
   
    /** type=primary_autoincrement */  
    protected $id = 0;  
   
    /** type=varchar length=255 null */  
    protected $name;  
   
    /** type=text null */  
    protected $biography;  
   
        public function getId()  
        {  
            return $this->id;  
        }  
        public function setId($v)  
        {  
            $this->id = $v;  
        }  
        public function getName()  
        {  
            return $this->name;  
        }  
        public function setName($v)  
        {  
            $this->name = $v;  
        }  
        public function getBiography()  
        {  
            return $this->biography;  
        }  
        public function setBiography($v)  
        {  
            $this->biography = $v;  
        }  
}  
$class = new ReflectionClass('Person');//建立 Person这个类的反射类  
$properties = $class->getProperties();  
foreach($properties as $property) {  
    echo $property->getName()."\n";  
}   
echo "<br>";
foreach($properties as $property) {  
    if($property->isProtected()) {  
        $docblock = $property->getDocComment();  
        preg_match('/ type\=([a-z_]*) /', $property->getDocComment(), $matches);  
        echo $matches[1]."\n";  
    }  
}  


++PHPemail发送配合phpmailer使用+++++
function SendMail($address,$title,$message,$cc,$send='',$loginame='',$passwd='') 
{ 
    vendor('phpMail.mailer'); 
 // Vendor('phpRPC.phprpc_server');
    //import("Org.Util.PHPMailer");
 //Vendor('Zend.Filter.Dir');
  /*
    $mail=new PHPMailer();          // 设置PHPMailer使用SMTP服务器发送Email 
    //$mail->IsSMTP();                // 设置邮件的字符编码，若不指定，则为'UTF-8' 
    $mail->CharSet='UTF-8';         // 添加收件人地址，可以多次使用来添加多个收件人 
    $mail->AddAddress($address);    // 设置邮件正文 
    $mail->Body=$message;           // 设置邮件头的From字段。 
    $mail->From=C('MAIL_ADDRESS');  // 设置发件人名字 
    $mail->FromName='XXX网团队';  // 设置邮件标题 
    $mail->Subject=$title;          // 设置SMTP服务器。 
    $mail->Host=C('MAIL_SMTP');     // 设置为"需要验证" ThinkPHP 的C方法读取配置文件 
    $mail->SMTPAuth=true;           // 设置用户名和密码。 
    $mail->Username=C('MAIL_LOGINNAME'); 
    $mail->Password=C('MAIL_PASSWORD'); // 发送邮件。 */
    $mail = new Mailer();
    $mail->mailServer = C('MAIL_SERVER');
    $mail->mailPort = C('MAIL_PORT');
	if(empty($send))$send=C('MAIL_ADDRESS');
    $mail->mailSender = $send; 
	if(empty($loginame))$loginame=C('MAIL_LOGINNAME');
    $mail->mailUser = $loginame;
	if(empty($passwd))$passwd=C('MAIL_PASSWORD');
    $mail->mailPwd = $passwd;
	$title = iconv('utf-8','gb2312',$title);
	$message = iconv('utf-8','gb2312',$message);
    if($mail->connect()){
		// $address = explode(',',$address); 
		//$cc = explode(',',$cc);  
		$dd = date('Y-m-d H:i:s');
		error_log($dd.'---'.$message.$address."\n",3,WEB_PATH.'/cc.log');
        return ($mail->send($address,$title,$message,'',$cc)); 
    } 
    return false;   
}

+++PHP转换数字为大写汉字+++++
 function _cny_map_unit($list,$units) { 
    $ul=count($units); 
    $xs=array(); 
    foreach (array_reverse($list) as $x) { 
        $l=count($xs); 
        if ($x!="0" || !($l%4)) $n=($x=='0'?'':$x).($units[($l-1)%$ul]); 
        else $n=is_numeric($xs[0][0])?$x:''; 
        array_unshift($xs,$n); 
    } 
    return $xs; 
}
function cny($ns) { 
    static $cnums=array("零","壹","贰","叁","肆","伍","陆","柒","捌","玖"), 
        $cnyunits=array("圆","角","分"), 
        $grees=array("拾","佰","仟","万","拾","佰","仟","亿"); 
    list($ns1,$ns2)=explode(".",$ns,2); 
    $ns2=array_filter(array($ns2[1],$ns2[0])); 
    $ret=array_merge($ns2,array(implode("",_cny_map_unit(str_split($ns1),$grees)),"")); 
    $ret=implode("",array_reverse(_cny_map_unit($ret,$cnyunits))); 
    return str_replace(array_keys($cnums),$cnums,$ret); 
}
$ff= cny('12');
var_dump($ff);



++++用程序过滤大文本数据里面的邮箱++++++
批量过滤邮箱，批量取出邮箱地址。
<?php
    /**
     *过滤用户邮箱的脚本
     *argv[1]  获取用户输入文件的路径
     *Author komiles
     *Date   2013-09-17
     */
    $filePath = $argv[1];
    $newFile  = $argv[2];

    if(file_exists($newFile)){
        exit("该文件已存在，请重新命名\n");
    }else{
        $result = file_get_contents($filePath);
        $pattern = '/([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)/';
        preg_match_all($pattern, $result, $emailList);
        $handle = fopen($newFile,a);
        foreach($emailList[0] as $value){        
            fwrite($handle , $value."\n");
        }
        echo "一共".count(file($filePath))."条数据,本次处理".count($emailList[0])."条数据\n";
    }
?>


+++把一个一维数组转换为in()++++
便于sql操作。
$arr=array(1,5,6,7,8,5);
function dbcreatein($itemlist){
	if(empty($itemlist)){
		return " IN ('')";
	}else{
		return " IN ('" .join ("','",$itemlist) ."')";
	}
}
$arr=dbcreatein($arr);
var_dump($arr);