php正则表达式的学习首要的是要记住它常用的
1》》》》元字符；
.     匹配换行符以外任意字符
\w    匹配字母或数字或下划线
\s    匹配任意的空白符
\d    匹配数字
\b    匹配单词的开始或结束
^     匹配字符串的开始
$     匹配字符串的结束
\W    \w的反义，匹配除字母数字或下划线的任意字符
\S    \s的反义，匹配除空白符的任意字符
\D    \d的反义，匹配除数字的任意字符
\B    \b的反义，匹配不是单词的开头或者结束的位置
[x]   匹配x字符，类似的[abc]匹配abc字符
[^x]  [x]的反义，匹配除x的任意字符，类似的[^abc]匹配除abc的任意字符
{5,}  匹配5位及5位以上
{5}   匹配5位
2》》》》选择与循环：
*     重复0次或无数次
+     重复1次或无数次
?     重复0次或1次
{n}   重复n次
{n,}  重复n次或无数次
{n,m} 重复n到m次
3》》》》分支（前面的匹配成功则不对后面的进行匹配）
|  或者
\d{5}-\d{4}|\d{5}
//错误写法
\d{5}|\d{5}-\d{4}

4》》》》模式修正符
i   匹配不区分大小写
U   匹配最近的字符串
贪婪匹配 （竟可能多的重复）
.*
懒惰匹配 （竟可能少的重复）
*?

preg_match() （只要匹配成功一次就会结束，可能不会执行完）
 函数用于进行正则表达式匹配，成功返回 1 ，否则返回 0 。例如：
<?php
if(preg_match("/php/i", "PHP is the web scripting language of choice.", $matches)){
    print "A match was found:". $matches[0];
} else {
    print "A match was not found.";
}
?>
preg_match_all()   (强制执行到结尾，一定会执行完)

5》》》》》
[\w-]  匹配数字或字母或下划线或汉字或短横杠
比如（^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$） 匹配邮箱地址
()     可以把小括号里的东西作为一个元字符


正则表达式常用整理：
验证账号，字母开头，允许 5-16 字节，允许字母数字下划线：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
验证账号，不能有空格，只能是英文字母：^[a-zA-Z]{1,}$
验证账号，不能有空格，不能非数字：^\d+$
验证用户密码，以字母开头，长度在 6-18 之间：^[a-zA-Z]\w{5,17}$
验证是否含有 ^%&',;=?$\ 等字符，并且以他们为节点分割：[^%&',;=?$]+
匹配Email地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
匹配腾讯QQ号：[1-9][0-9]{4,}
匹配日期，只能是 2004-10-22 格式：^\d{4}\-\d{1,2}-\d{1,2}$
匹配国内电话号码：^\d{3}-\d{8}|\d{4}-\d{7,8}$
评注：匹配形式如 010-12345678 或 0571-12345678 或 0831-1234567
匹配中国邮政编码：^[1-9]\d{5}(?!\d)$
匹配身份证：\d{14}(\d{4}|(\d{3}[xX])|\d{1})
评注：中国的身份证为 15 位或 18 位
不能为空且二十字节以上：^[\s|\S]{20,}

匹配由 26 个英文字母组成的字符串：^[A-Za-z]+$
匹配由 26 个大写英文字母组成的字符串：^[A-Z]+$
匹配由 26 个小写英文字母组成的字符串：^[a-z]+$
匹配由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$
匹配由数字、26个英文字母或者下划线组成的字符串：^\w+$
匹配空行：\n[\s| ]*\r
匹配任何内容：[\s\S]*
匹配中文字符：[\x80-\xff]+ 或者 [\xa1-\xff]+
只能输入汉字：^[\x80-\xff],{0,}$
匹配双字节字符(包括汉字在内)：[^\x00-\xff]

只能输入数字：^[0-9]*$
只能输入n位的数字：^\d{n}$
只能输入至少n位数字：^\d{n,}$
只能输入m-n位的数字：^\d{m,n}$
匹配正整数：^[1-9]\d*$
匹配负整数：^-[1-9]\d*$
匹配整数：^-?[1-9]\d*$
匹配非负整数（正整数 + 0）：^[1-9]\d*|0$
匹配非正整数（负整数 + 0）：^-[1-9]\d*|0$
匹配正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$
匹配负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$
匹配浮点数：^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
匹配非负浮点数（正浮点数 + 0）：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
匹配非正浮点数（负浮点数 + 0）：^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

匹配HTML标记的正则表达式（无法匹配嵌套标签）：<(\S*?)[^>]*>.*?</\1>|<.*? />
匹配网址 URL ：[a-zA-z]+://[^\s]*
匹配 IP 地址：((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)
匹配完整域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?

[\w-] ==》》 字母和符号-
\.    ==》》 符号.

PHP正则表达式修饰符的种类及介绍：
◆i ：如果在修饰符中加上"i"，则正则将会取消大小写敏感性，即"a"和"A" 是一样的。
◆m：默认的正则开始"^"和结束"$"只是对于正则字符串如果在修饰符中加上"m"，那么开始和结束将会指字符串的每一行：每一行的开头就是"^"，结尾就是"$"。
◆s：如果在修饰符中加入"s"，那么默认的"."代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！
◆x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。
◆e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。
◆A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说"/a/A"匹配"abcd"。
◆E：与"m"相反，如果使用这个修饰符，那么"$"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。
◆U：和问号的作用差不多，用于设置"贪婪模式"。

php正则表达式匹配汉字 
preg_match("/^[\x{4e00}-\x{9fa5}]{1,4}/u",$str);


++++++正则修饰符++++++++
i (PCRE_CASELESS) 
 如果设置了这个修饰符, 模式中的字母会进行大小写不敏感匹配. 
m (PCRE_MULTILINE) 
 默认情况下, PCRE认为目标字符串是由单行字符组成的(然而实际上它可能会包含多行), "行首"元字符(^)仅匹配字符串的开始位置,
 而"行末"元字符($)仅匹配字符串末尾, 或者最后的换行符(除非设置了D修饰符). 这个行为和perl相同.  当这个修饰符设置之后, 
"行首"和"行末"就会匹配目标字符串中任意换行符之前或之后, 另外, 还分别匹配目标字符串的最开始和最末尾位置. 这等同于perl的/m修饰符.
 如果目标字符串 中没有"\n"字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响. 
s (PCRE_DOTALL) 
 如果设置了这个修饰符, 模式中的点号元字符匹配所有字符, 包含换行符. 如果没有这个 修饰符, 
点号不匹配换行符. 这个修饰符等同于perl中的/s修饰符. 一个取反字符类比如 [^a]总是匹配换行符, 而不依赖于这个修饰符的设置. 
x (PCRE_EXTENDED) 
 如果设置了这个修饰符, 模式中的没有经过转义的或不在字符类中的空白数据字符总会被忽略, 并且位于一个未转义的
字符类外部的#字符和下一个换行符之间的字符也被忽略. 这个修饰符 等同于perl中的/x修饰符, 使被编译模式中可以包含注释. 
注意: 这仅用于数据字符. 空白字符 还是不能在模式的特殊字符序列中出现, 比如序列(?(引入了一个条件子组(译注: 这种语法定义的
特殊字符序列中如果出现空白字符会导致编译错误. 比如( ?(就会导致错误.). 
e (PREG_REPLACE_EVAL) 
 如果这个修饰符设置了, preg_replace()在进行了对替换字符串的 后向引用替换之后,
 将替换后的字符串作为php代码评估执行(eval函数方式), 并使用执行结果 作为实际参与替换的字符串.
 单引号, 双引号, 反斜线(\)和NULL字符在 后向引用替换时会被用反斜线转义.
A (PCRE_ANCHORED)
如果设置了这个修饰符, 模式被强制为"锚定"模式, 也就是说约束匹配使其仅从
 目标字符串的开始位置搜索. 这个效果同样可以使用适当的模式构造出来, 并且 这也是perl种实现这种模式的唯一途径.
D (PCRE_DOLLAR_ENDONLY)
如果这个修饰符被设置, 模式中的元字符美元符号仅仅匹配目标字符串的末尾. 如果这个修饰符 
没有设置, 当字符串以一个换行符结尾时, 美元符号还会匹配该换行符(但不会匹配之前的任何换行符). 
如果设置了修饰符m, 这个修饰符被忽略. 在perl中没有与此修饰符等同的修饰符.
S
当一个模式需要多次使用的时候, 为了得到匹配速度的提升, 值得花费一些时间 
对其进行一些额外的分析. 如果设置了这个修饰符, 这个额外的分析就会执行. 
当前, 这种对一个模式的分析仅仅适用于非锚定模式的匹配(即没有单独的固定开始字符).
U (PCRE_UNGREEDY)
这个修饰符逆转了量词的"贪婪"模式. 使量词默认为非贪婪的, 通过量词后紧跟? 的方式
可以使其成为贪婪的. 这和perl是不兼容的. 它同样可以使用 模式内修饰符设置(?U)进行设置, 或者在量词后以问号标记其非贪婪(比如.*?).
Note:
在非贪婪模式, 通常不能匹配超过 pcre.backtrack_limit的字符.
X (PCRE_EXTRA)
这个修饰符打开了PCRE与perl不兼容的附件功能. 模式中的任意反斜线后就ingen一个 
没有特殊含义的字符都会导致一个错误, 以此保留这些字符以保证向后兼容性. 默认 
情况下, 在perl中, 反斜线紧跟一个没有特殊含义的字符被认为是该字符的原文. 当前没有其他特性由这个修饰符控制.
J (PCRE_INFO_JCHANGED)
内部选项设置(?J)修改本地的PCRE_DUPNAMES选项. 允许子组重名. (译注:只能通过内部选项设置, 外部的/J设置会产生错误.)
u (PCRE8)
此修正符打开一个与perl不兼容的附加功能. 模式字符串被认为是utf-8的. 这个修饰符 
从unix版php 4.1.0或更高, win32版php 4.2.3开始可用. php 4.3.5开始检查模式的utf-8合法性.



