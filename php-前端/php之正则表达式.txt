php正则表达式的学习首要的是要记住它常用的
1》》》》元字符；
.     匹配换行符以外任意字符
\w    匹配字母或数字或下划线
\s    匹配任意的空白符
\d    匹配数字
\b    匹配单词的开始或结束
^     匹配字符串的开始
$     匹配字符串的结束
\W    \w的反义，匹配除字母数字或下划线的任意字符
\S    \s的反义，匹配除空白符的任意字符
\D    \d的反义，匹配除数字的任意字符
\B    \b的反义，匹配不是单词的开头或者结束的位置
[x]   匹配x字符，类似的[abc]匹配abc字符
[^x]  [x]的反义，匹配除x的任意字符，类似的[^abc]匹配除abc的任意字符
{5,}  匹配5位及5位以上
{5}   匹配5位
2》》》》选择与循环：
*     重复0次或无数次
+     重复1次或无数次
?     重复0次或1次
{n}   重复n次
{n,}  重复n次或无数次
{n,m} 重复n到m次
3》》》》分支（前面的匹配成功则不对后面的进行匹配）
|  或者
\d{5}-\d{4}|\d{5}
//错误写法
\d{5}|\d{5}-\d{4}

4》》》》模式修正符
i   匹配不区分大小写
U   匹配最近的字符串
贪婪匹配 （竟可能多的重复）
.*
懒惰匹配 （竟可能少的重复）
*?

preg_match() （只要匹配成功一次就会结束，可能不会执行完）
 函数用于进行正则表达式匹配，成功返回 1 ，否则返回 0 。例如：
<?php
if(preg_match("/php/i", "PHP is the web scripting language of choice.", $matches)){
    print "A match was found:". $matches[0];
} else {
    print "A match was not found.";
}
?>
preg_match_all()   (强制执行到结尾，一定会执行完)

5》》》》》
[\w-]  匹配数字或字母或下划线或汉字或短横杠
比如（^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$） 匹配邮箱地址
()     可以把小括号里的东西作为一个元字符


正则表达式常用整理：
验证账号，字母开头，允许 5-16 字节，允许字母数字下划线：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
验证账号，不能有空格，只能是英文字母：^[a-zA-Z]{1,}$
验证账号，不能有空格，不能非数字：^\d+$
验证用户密码，以字母开头，长度在 6-18 之间：^[a-zA-Z]\w{5,17}$
验证是否含有 ^%&',;=?$\ 等字符，并且以他们为节点分割：[^%&',;=?$]+
匹配Email地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
匹配腾讯QQ号：[1-9][0-9]{4,}
匹配日期，只能是 2004-10-22 格式：^\d{4}\-\d{1,2}-\d{1,2}$
匹配国内电话号码：^\d{3}-\d{8}|\d{4}-\d{7,8}$
评注：匹配形式如 010-12345678 或 0571-12345678 或 0831-1234567
匹配中国邮政编码：^[1-9]\d{5}(?!\d)$
匹配身份证：\d{14}(\d{4}|(\d{3}[xX])|\d{1})
评注：中国的身份证为 15 位或 18 位
不能为空且二十字节以上：^[\s|\S]{20,}

匹配由 26 个英文字母组成的字符串：^[A-Za-z]+$
匹配由 26 个大写英文字母组成的字符串：^[A-Z]+$
匹配由 26 个小写英文字母组成的字符串：^[a-z]+$
匹配由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$
匹配由数字、26个英文字母或者下划线组成的字符串：^\w+$
匹配空行：\n[\s| ]*\r
匹配任何内容：[\s\S]*
匹配中文字符：[\x80-\xff]+ 或者 [\xa1-\xff]+
只能输入汉字：^[\x80-\xff],{0,}$
匹配双字节字符(包括汉字在内)：[^\x00-\xff]

只能输入数字：^[0-9]*$
只能输入n位的数字：^\d{n}$
只能输入至少n位数字：^\d{n,}$
只能输入m-n位的数字：^\d{m,n}$
匹配正整数：^[1-9]\d*$
匹配负整数：^-[1-9]\d*$
匹配整数：^-?[1-9]\d*$
匹配非负整数（正整数 + 0）：^[1-9]\d*|0$
匹配非正整数（负整数 + 0）：^-[1-9]\d*|0$
匹配正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$
匹配负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$
匹配浮点数：^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
匹配非负浮点数（正浮点数 + 0）：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
匹配非正浮点数（负浮点数 + 0）：^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

匹配HTML标记的正则表达式（无法匹配嵌套标签）：<(\S*?)[^>]*>.*?</\1>|<.*? />
匹配网址 URL ：[a-zA-z]+://[^\s]*
匹配 IP 地址：((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)
匹配完整域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?

[\w-] ==》》 字母和符号-
\.    ==》》 符号.

PHP正则表达式修饰符的种类及介绍：
◆i ：如果在修饰符中加上"i"，则正则将会取消大小写敏感性，即"a"和"A" 是一样的。
◆m：默认的正则开始"^"和结束"$"只是对于正则字符串如果在修饰符中加上"m"，那么开始和结束将会指字符串的每一行：每一行的开头就是"^"，结尾就是"$"。
◆s：如果在修饰符中加入"s"，那么默认的"."代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！
◆x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。
◆e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。
◆A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说"/a/A"匹配"abcd"。
◆E：与"m"相反，如果使用这个修饰符，那么"$"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。
◆U：和问号的作用差不多，用于设置"贪婪模式"。

php正则表达式匹配汉字 
preg_match("/^[\x{4e00}-\x{9fa5}]{1,4}/u",$str);


++++++正则修饰符++++++++
i (PCRE_CASELESS) 
 如果设置了这个修饰符, 模式中的字母会进行大小写不敏感匹配. 
m (PCRE_MULTILINE) 
 默认情况下, PCRE认为目标字符串是由单行字符组成的(然而实际上它可能会包含多行), "行首"元字符(^)仅匹配字符串的开始位置,
 而"行末"元字符($)仅匹配字符串末尾, 或者最后的换行符(除非设置了D修饰符). 这个行为和perl相同.  当这个修饰符设置之后, 
"行首"和"行末"就会匹配目标字符串中任意换行符之前或之后, 另外, 还分别匹配目标字符串的最开始和最末尾位置. 这等同于perl的/m修饰符.
 如果目标字符串 中没有"\n"字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响. 
s (PCRE_DOTALL) 
 如果设置了这个修饰符, 模式中的点号元字符匹配所有字符, 包含换行符. 如果没有这个 修饰符, 
点号不匹配换行符. 这个修饰符等同于perl中的/s修饰符. 一个取反字符类比如 [^a]总是匹配换行符, 而不依赖于这个修饰符的设置. 
x (PCRE_EXTENDED) 
 如果设置了这个修饰符, 模式中的没有经过转义的或不在字符类中的空白数据字符总会被忽略, 并且位于一个未转义的
字符类外部的#字符和下一个换行符之间的字符也被忽略. 这个修饰符 等同于perl中的/x修饰符, 使被编译模式中可以包含注释. 
注意: 这仅用于数据字符. 空白字符 还是不能在模式的特殊字符序列中出现, 比如序列(?(引入了一个条件子组(译注: 这种语法定义的
特殊字符序列中如果出现空白字符会导致编译错误. 比如( ?(就会导致错误.). 
e (PREG_REPLACE_EVAL) 
 如果这个修饰符设置了, preg_replace()在进行了对替换字符串的 后向引用替换之后,
 将替换后的字符串作为php代码评估执行(eval函数方式), 并使用执行结果 作为实际参与替换的字符串.
 单引号, 双引号, 反斜线(\)和NULL字符在 后向引用替换时会被用反斜线转义.
A (PCRE_ANCHORED)
如果设置了这个修饰符, 模式被强制为"锚定"模式, 也就是说约束匹配使其仅从
 目标字符串的开始位置搜索. 这个效果同样可以使用适当的模式构造出来, 并且 这也是perl种实现这种模式的唯一途径.
D (PCRE_DOLLAR_ENDONLY)
如果这个修饰符被设置, 模式中的元字符美元符号仅仅匹配目标字符串的末尾. 如果这个修饰符 
没有设置, 当字符串以一个换行符结尾时, 美元符号还会匹配该换行符(但不会匹配之前的任何换行符). 
如果设置了修饰符m, 这个修饰符被忽略. 在perl中没有与此修饰符等同的修饰符.
S
当一个模式需要多次使用的时候, 为了得到匹配速度的提升, 值得花费一些时间 
对其进行一些额外的分析. 如果设置了这个修饰符, 这个额外的分析就会执行. 
当前, 这种对一个模式的分析仅仅适用于非锚定模式的匹配(即没有单独的固定开始字符).
U (PCRE_UNGREEDY)
这个修饰符逆转了量词的"贪婪"模式. 使量词默认为非贪婪的, 通过量词后紧跟? 的方式
可以使其成为贪婪的. 这和perl是不兼容的. 它同样可以使用 模式内修饰符设置(?U)进行设置, 或者在量词后以问号标记其非贪婪(比如.*?).
Note:
在非贪婪模式, 通常不能匹配超过 pcre.backtrack_limit的字符.
X (PCRE_EXTRA)
这个修饰符打开了PCRE与perl不兼容的附件功能. 模式中的任意反斜线后就ingen一个 
没有特殊含义的字符都会导致一个错误, 以此保留这些字符以保证向后兼容性. 默认 
情况下, 在perl中, 反斜线紧跟一个没有特殊含义的字符被认为是该字符的原文. 当前没有其他特性由这个修饰符控制.
J (PCRE_INFO_JCHANGED)
内部选项设置(?J)修改本地的PCRE_DUPNAMES选项. 允许子组重名. (译注:只能通过内部选项设置, 外部的/J设置会产生错误.)
u (PCRE8)
此修正符打开一个与perl不兼容的附加功能. 模式字符串被认为是utf-8的. 这个修饰符 
从unix版php 4.1.0或更高, win32版php 4.2.3开始可用. php 4.3.5开始检查模式的utf-8合法性.

++utf8下匹配中文++
function pregCh($test){  
//utf8下匹配中文  
    $rule ='/([\x{4e00}-\x{9fa5}]){1}/u';  
    preg_match_all($rule,$test,$result);  
    return $result;  
}  

++匹配时间++
function pregTI($test){  
        /** 
        匹配时间 
            规则： 
                形式可以为： 
                年-月-日 小时:分钟:秒 
                年-月-日 小时:分钟 
                年-月-日 
                年：1或2开头的四位数 
                月：1位1到9的数；0或1开头的两位数，0开头的时候个位数是1到9的数，1开头的时候个位数是1到2的数 
                日：1位1到9的数；0或1或2或3开头的两位数，0开头的时候个位数是1到9的数，1或2开头的时候个位数是0到9的数，3开头的时候个位数是0或1 
                小时：0到9的一位数；0或1开头的两位数，个位是0到9；2开头的两位数，个位是0-3 
                分钟：0到9的一位数；0到5开头的两位数，个位是0到9； 
                分钟：0到9的一位数；0到5开头的两位数，各位是0到9 
        */  
        $rule ='/^(([1-2][0-9]{3}-)((([1-9])|(0[1-9])|(1[0-2]))-)((([1-9])|(0[1-9])|([1-2][0-9])|(3[0-1]))))( ((([0-9])|(([0-1][0-9])|(2[0-3]))):(([0-9])|([0-5][0-9]))(:(([0-9])|([0-5][0-9])))?))?$/';  
        preg_match($rule,$test,$result);  
        return $result;  
    }  


++匹配ip++
function pregIP($test){  
        /** 
        匹配ip 
        规则： 
            **1.**2.**3.**4 
            **1可以是一位的 1-9，两位的01-99，三位的001-255 
            **2和**3可以是一位的0-9，两位的00-99,三位的000-255 
            **4可以是一位的 1-9，两位的01-99，三位的001-255 
            四个参数必须存在 
        */  
        $rule = '/^((([1-9])|((0[1-9])|([1-9][0-9]))|((00[1-9])|(0[1-9][0-9])|((1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))))\.)((([0-9]{1,2})|(([0-1][0-9]{2})|(2[0-4][0-9])|(25[0-5])))\.){2}(([1-9])|((0[1-9])|([1-9][0-9]))|(00[1-9])|(0[1-9][0-9])|((1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))$/';  
        preg_match($rule,$test,$result);  
        return $result;  
    }  

++匹配邮编++
function pregPOS($test){  
    /** 
        匹配邮编 
            规则：六位数字，第一位不能为0 
    */  
        $rule ='/^[1-9]\d{5}$/';  
        preg_match($rule,$test,$result);  
        return $result;  
    }  

++匹配身份证号++
function pregIC($test){  
        /** 
        匹配身份证号 
        规则： 
            15位纯数字或者18位纯数字或者17位数字加一位x 
        */  
        $rule = '/^(([0-9]{15})|([0-9]{18})|([0-9]{17}x))$/';         
        preg_match($rule,$test,$result);  
        return $result;  
    }  

++匹配url++
function pregURL($test){  
        /** 
            匹配url 
            url规则： 
                例 
                协议://域名（www/tieba/baike...）.名称.后缀/文件路径/文件名 
                http://zhidao.baidu.com/question/535596723.html 
                协议://域名（www/tieba/baike...）.名称.后缀/文件路径/文件名?参数 
                www.lhrb.com.cn/portal.php?mod=view&aid=7412 
                协议://域名（www/tieba/baike...）.名称.后缀/文件路径/文件名/参数 
                http://www.xugou.com.cn/yiji/erji/index.php/canshu/11 
                 
                协议：可有可无，由大小写字母组成；不写协议则不应存在://，否则必须存在:// 
                域名：必须存在，由大小写字母组成 
                名称：必须存在，字母数字汉字 
                后缀：必须存在，大小写字母和.组成 
                文件路径：可有可无，由大小写字母和数字组成 
                文件名：可有可无，由大小写字母和数字组成 
                参数:可有可无，存在则必须由?开头，即存在?开头就必须有相应的参数信息 
        */  
        $rule = '/^(([a-zA-Z]+)(:\/\/))?([a-zA-Z]+)\.(\w+)\.([\w.]+)(\/([\w]+)\/?)*(\/[a-zA-Z0-9]+\.(\w+))*(\/([\w]+)\/?)*(\?(\w+=?[\w]*))*((&?\w+=?[\w]*))*$/';  
        preg_match($rule,$test,$result);  
        return $result;  
    }  

++电话号码匹配++
function pregTP($test){  
    /** 
    电话号码匹配 
    电话号码规则： 
        区号：3到5位，大部分都是四位，北京(010)和上海市(021)三位，西藏有部分五位，可以包裹在括号内也可以没有 
        如果有区号由括号包裹，则在区号和号码之间可以有0到1个空格，如果区号没有由括号包裹，则区号和号码之间可以有两位长度的 或者- 
        号码：7到8位的数字 
        例如：(010) 12345678  或者 (010)12345678 或者 010  12345678 或者 010--12345678  
    */  
    $rule = '/^(((010)|(021)|(0\d3,4))( ?)([0-9]{7,8}))|((010|021|0\d{3,4}))([- ]{1,2})([0-9]{7,8})$/A';  
    preg_match($rule,$test,$result);  
    return $result;  
}  

++匹配邮箱++
function pregE($test){  
        /** 
        匹配邮箱 
        规则： 
            邮箱基本格式是  *****@**.** 
            @以前是一个 大小写的字母或者数字开头，紧跟0到多个大小写字母或者数字或 . _ - 的字符串 
            @之后到.之前是 1到多个大小写字母或者数字的字符串 
            .之后是 1到多个 大小写字母或者数字或者.的字符串 
        */  
        $zhengze = '/^[a-zA-Z0-9][a-zA-Z0-9._-]*\@[a-zA-Z0-9]+\.[a-zA-Z0-9\.]+$/A';  
        preg_match($zhengze,$test,$result);  
        return $result;  
    }  

++匹配手机号码++
function pregPN($test){  
        /** 
            匹配手机号码 
            规则： 
                手机号码基本格式： 
                前面三位为： 
                移动：134-139 147 150-152 157-159 182 187 188 
                联通：130-132 155-156 185 186 
                电信：133 153 180 189 
                后面八位为： 
                0-9位的数字 
        */  
          
        $rule  = "/^((13[0-9])|147|(15[0-35-9])|180|182|(18[5-9]))[0-9]{8}$/A";  
        preg_match($rule,$test,$result);  
        return $result;  
    }  





+++++++PHP正则表达式使用详解++++++
\ 转义符

(), (?:), (?=), [] 圆括号和方括号

*, +, ?, {n}, {n,}, {n,m} 限定符

^, $, \anymetacharacter 位置和顺序

| “或”操作

\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。

^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。

$ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。

* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。

+ 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。

? 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。

{n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。

{n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。

{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。

. 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。

(pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。

(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。

(?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

(?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始

x|y 匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。

[xyz] 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。

[^xyz] 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。

[a-z] 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。

[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。

\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。

\B 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

\cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。

\d 匹配一个数字字符。等价于 [0-9]。

\D 匹配一个非数字字符。等价于 [^0-9]。

\f 匹配一个换页符。等价于 \x0c 和 \cL。

\n 匹配一个换行符。等价于 \x0a 和 \cJ。

\r 匹配一个回车符。等价于 \x0d 和 \cM。

\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。

\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。

\t 匹配一个制表符。等价于 \x09 和 \cI。

\v 匹配一个垂直制表符。等价于 \x0b 和 \cK。

\w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。

\W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。

\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。.

\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。

\n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。

\nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。

\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。

\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。


常用的正则表达式

1、非负整数："^\d+$"

2、正整数："^[0-9]*[1-9][0-9]*$"

3、非正整数："^((-\d+)|(0+))$"

4、负整数："^-[0-9]*[1-9][0-9]*$"

5、整数："^-?\d+$"

6、非负浮点数："^\d+(\.\d+)?$"

7、正浮点数："^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"

8、非正浮点数："^((-\d+\.\d+)?)|(0+(\.0+)?))$"

9、负浮点数："^(-((正浮点数正则式)))$"

10、英文字符串："^[A-Za-z]+$"

11、英文大写串："^[A-Z]+$"

12、英文小写串："^[a-z]+$"

13、英文字符数字串："^[A-Za-z0-9]+$"

14、英数字加下划线串："^\w+$"

15、E-mail地址："^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"

16、URL："^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$"

