++++++网站全页变灰css代码++++++++++
html{   
    filter: grayscale(100%);    
    -webkit-filter: grayscale(100%);    
    -moz-filter: grayscale(100%);   
    -ms-filter: grayscale(100%);    
    -o-filter: grayscale(100%); 
    filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale");  
    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);   -webkit-filter: grayscale(1);
}
将上述代码放入head中的style即可。


这篇日志主要是写  javascript、DOM 的一些 属性 和 方法 。
DOM
document.createElement(li);   创建一个元素
document.createTextNode();    创建一个文本
.appendChild();   在父DOM里面插入一个子节点
.insertBefore(子节点，在谁之前)
removeChild()    删除子元素
cloneNode      复制节点
replaceChild    替换节点
hasChildNodes   判断给定元素节点是否有子元素
parentNode     上级元素节点
childNodes     子节点集合
nodeName   属性含有某个节点的名称。
nodeType    3 文本节点  1 元素节点
children     取元素
offsetParent    此元素的上级定位元素    
firstChild     第一个子节点    FF 下面 是  firstElementChild
lastChild     最后一个子节点   FF  下面是    lastElementChild
nextSibling    下面的兄弟元素  FF下面是   nextElementSibling
previousSibling   上面的兄弟元素   FF下面是     previousElementSibling
a.value ==  a['value']
nodeValue     元素内容
setAttribute(名称，值)    设置元素属性
getAttribute(名称)    获取元素属性
removeAttribute(名称)    删除元素属性
.style.proprtype   设置元素的css
className    改变元素的class 


js获取一个页面中的所有a元素和title元素，然后创造新的P元素，并把a的title和内容附加到p元素中。
<script type="text/javascript">  
window.onload = function(){  
 var mya = document.getElementsByTagName('a');  
 var tmp = Array();  
 for(var i = 0; i<mya.length; i++){  
    var mytit = mya[i].getAttribute('title');  
tmp[mytit] = mya[i].lastChild.nodeValue;  
 }  
 var myBody = document.getElementsByTagName('body')[0];  
 for (key in tmp){  
     var myP = document.createElement('p');  
myP.title = key;  
var myTxt = document.createTextNode(tmp[key]);  
myP.appendChild(myTxt);  
myBody.appendChild(myP);  
 }  
}  
</script>  

++++++++jquery中attr()使用++++++++
<script>                                  //用attr设置属性值
$("ul li:eq(1)").attr("title","不吃橘子");
alert($("ul li:eq(1)").attr("title"));
</script>
                                          //用attr删除属性值
<script>
$("ul li:eq(1)").removeAttr ("title");
</script>

++++需要掌握的前端,HTML,JS知识点++++++++
css盒模型。
javascript中的prototype。
javascript中this对象的作用域。
IE和firefox事件冒泡的不同。
什么是怪异模式,标准模式，近标准模式。
DTD的定义
IE/firefox常用hack.
firefox,IE下的前端js/css调试工具。

+++++手机触摸屏的JS事件++++++++
作者 管理员  发布时间 2013-06-13 17:38  文章分类 JavaScript  文章评论 1条评论  阅读次数 
处理Touch事件能让你跟踪用户的每一根手指的位置。你可以绑定以下四种Touch事件：
一、
touchstart:// 手指放到屏幕上的时候触发
touchmove:// 手指在屏幕上移动的时候触发
touchend:// 手指从屏幕上拿起的时候触发
touchcancel:// 系统取消touch事件的时候触发。至于系统什么时候会取消，不详
二、
client / clientY：// 触摸点相对于浏览器窗口viewport的位置
pageX / pageY：// 触摸点相对于页面的位置
screenX /screenY：// 触摸点相对于屏幕的位置
identifier：>// touch对象的unique ID


++++++js判断浏览器版本+++++
var Sys = {};
var ua = navigator.userAgent.toLowerCase();
if (window.ActiveXObject)
Sys.ie = ua.match(/msie ([\d.]+)/)[1]
else if (document.getBoxObjectFor)
Sys.firefox = ua.match(/firefox\/([\d.]+)/)[1]
else if (window.MessageEvent && !document.getBoxObjectFor)
Sys.chrome = ua.match(/chrome\/([\d.]+)/)[1]
else if (window.opera)
Sys.opera = ua.match(/opera.([\d.]+)/)[1]
else if (window.openDatabase)
Sys.safari = ua.match(/version\/([\d.]+)/)[1];
//以下进行测试
if(Sys.ie) document.write('IE: '+Sys.ie);
if(Sys.firefox) document.write('Firefox: '+Sys.firefox);
if(Sys.chrome) document.write('Chrome: '+Sys.chrome);
if(Sys.opera) document.write('Opera: '+Sys.opera);
if(Sys.safari) document.write('Safari: '+Sys.safari);
还可以写成下面这种：
var Sys = {};
var ua = navigator.userAgent.toLowerCase();
window.ActiveXObject ? Sys.ie = ua.match(/msie ([\d.]+)/)[1] :
document.getBoxObjectFor ? Sys.firefox = ua.match(/firefox\/([\d.]+)/)[1] :
window.MessageEvent && !document.getBoxObjectFor ? Sys.chrome = ua.match(/chrome\/([\d.]+)/)[1] :
window.opera ? Sys.opera = ua.match(/opera.([\d.]+)/)[1] :
window.openDatabase ? Sys.safari = ua.match(/version\/([\d.]+)/)[1] : 0;
//以下进行测试
if(Sys.ie) document.write('IE: '+Sys.ie);
if(Sys.firefox) document.write('Firefox: '+Sys.firefox);
if(Sys.chrome) document.write('Chrome: '+Sys.chrome);
if(Sys.opera) document.write('Opera: '+Sys.opera);
if(Sys.safari) document.write('Safari: '+Sys.safari);

JS各种弹窗效果：
http://www.web92.net/dom/2012-06-04-XY_Tips/

++++++对于input输入框+++++
readonly说明此域的值不可修改，只可与 type="text" 配合使用，可复制，
可选择,可接收焦点，后台会接收到传值。
<input type="text" name="www.xxx" readonly="readonly" />
disabled表示禁用input元素，不可编辑，不可复制，不可选择，
不能接收焦点,后台也不会接收到传值
<input type="text" name="www.xxx.com" disabled="disabled" />
最后介绍一个标签，浏览器通常会记录input输入框的记录，所以你在输入的时候，经常会下拉很多内容，
如果你想去掉的话，最好加上autocomplete="off"，使用方法如下：autocomplete="off"
<input type="text" autocomplete="off" id="number"/>



++++js在手机上的表现+++++
一、手机上的触摸事件
基本事件：
touchstart   //手指刚接触屏幕时触发
touchmove    //手指在屏幕上移动时触发
touchend     //手指从屏幕上移开时触发
下面这个比较少用：
touchcancel  //触摸过程被系统取消时触发
每个事件都有以下列表，比如touchend的targetTouches当然是 0 咯：
touches         //位于屏幕上的所有手指的列表
targetTouches   //位于该元素上的所有手指的列表
changedTouches  //涉及当前事件的所有手指的列表
每个事件有列表，每个列表还有以下属性：
复制代码
其中坐标常用pageX,pageY：
pageX    //相对于页面的 X 坐标
pageY    //相对于页面的 Y 坐标
clientX  //相对于视区的 X 坐标
clientY  //相对于视区的 Y 坐标
screenX  //相对于屏幕的 X 坐标
screenY  //相对于屏幕的 Y 坐标
identifier // 当前触摸点的惟一编号
target   //手指所触摸的 DOM 元素
复制代码
其他相关事件：
event.preventDefault（）   //阻止触摸时浏览器的缩放、滚动条滚动
var supportTouch = "createTouch" in document  //判断是否支持触摸事件
二、示例
以下是获取不同类型滑动的代码具体做法，结合前人的思想，封装好了，可以借鉴学习：
复制代码
var touchFunc = function(obj,type,func) {
    //滑动范围在5x5内则做点击处理，s是开始，e是结束
    var init = {x:5,y:5,sx:0,sy:0,ex:0,ey:0};
    var sTime = 0, eTime = 0;
    type = type.toLowerCase();
 
    obj.addEventListener("touchstart",function(){
        sTime = new Date().getTime();
        init.sx = event.targetTouches[0].pageX;
        init.sy = event.targetTouches[0].pageY;
        init.ex = init.sx;
        init.ey = init.sy;
        if(type.indexOf("start") != -1) func();
    }, false);
 
    obj.addEventListener("touchmove",function() {
        event.preventDefault();//阻止触摸时浏览器的缩放、滚动条滚动
        init.ex = event.targetTouches[0].pageX;
        init.ey = event.targetTouches[0].pageY;
        if(type.indexOf("move")!=-1) func();
    }, false);
 
    obj.addEventListener("touchend",function() {
        var changeX = init.sx - init.ex;
        var changeY = init.sy - init.ey;
        if(Math.abs(changeX)>Math.abs(changeY)&&Math.abs(changeY)>init.y) {
            //左右事件
            if(changeX > 0) {
                if(type.indexOf("left")!=-1) func();
            }else{
                if(type.indexOf("right")!=-1) func();
            }
        }
        else if(Math.abs(changeY)>Math.abs(changeX)&&Math.abs(changeX)>init.x){
            //上下事件
            if(changeY > 0) {
                if(type.indexOf("top")!=-1) func();
            }else{
                if(type.indexOf("down")!=-1) func();
            }
        }
        else if(Math.abs(changeX)<init.x && Math.abs(changeY)<init.y){
            eTime = new Date().getTime();
            //点击事件，此处根据时间差细分下
            if((eTime - sTime) > 300) {
                if(type.indexOf("long")!=-1) func(); //长按
            }
            else {
                if(type.indexOf("click")!=-1) func(); //当点击处理
            }
        }
        if(type.indexOf("end")!=-1) func();
    }, false);
};


++++++手机触摸屏的JS事件 +++++++
处理Touch事件能让你跟踪用户的每一根手指的位置。你可以绑定以下四种Touch事件：
    1.touchstart:  // 手指放到屏幕上的时候触发 
    2.touchmove:  // 手指在屏幕上移动的时候触发 
    3.touchend:  // 手指从屏幕上拿起的时候触发 
    4touchcancel:  // 系统取消touch事件的时候触发。至于系统什么时候会取消，不详
属性
    1.client / clientY：// 触摸点相对于浏览器窗口viewport的位置 
    2.pageX / pageY：// 触摸点相对于页面的位置 
    3.screenX /screenY：// 触摸点相对于屏幕的位置 
    4.identifier： // touch对象的unique ID 
//touchstart事件  
function touchSatrtFunc(e) {  
    //evt.preventDefault(); //阻止触摸时浏览器的缩放、滚动条滚动等  
    var touch = e.touches[0]; //获取第一个触点  
    var x = Number(touch.pageX); //页面触点X坐标  
    var y = Number(touch.pageY); //页面触点Y坐标  
    //记录触点初始位置  
    startX = x;  
    startY = y;  
}  
//touchmove事件 
function touchMoveFunc(e) {  
    //evt.preventDefault(); //阻止触摸时浏览器的缩放、滚动条滚动等  
    var touch = evt.touches[0]; //获取第一个触点  
    var x = Number(touch.pageX); //页面触点X坐标  
    var y = Number(touch.pageY); //页面触点Y坐标  
    var text = 'TouchMove事件触发：（' + x + ', ' + y + '）';  
    //判断滑动方向  
    if (x - startX != 0) {  
        //左右滑动  
    }  
    if (y - startY != 0) {  
        //上下滑动  
    }  
}  

++++++++Mobile Web前端开发系列:事件处理（二）++++++++  
上篇文章我们讲了html的基本事件，这篇文章我们着重讲解下触摸事件，触摸事件触发的条件是手指接触屏幕、手指在屏幕上移动或者从屏幕上离开。 事件是触摸的集合，它起始于手指初次放置在屏幕上，终止于最后一个手指离开屏幕。事件从开始到结束过程中的所有触摸操作都存储在相同事件的记录中。
touch事件
touch事件可以分为单点触摸和多点触摸两种，单点触摸高端机一般都支持，Safari2.0、Android3.0以上的版本支持多点触摸，支持最多5个手指同时触摸屏幕，ipad最多支持11个手指同时触摸屏幕， 我们可以采用以下的事件模型捕获这些事件，
ontouchstart ontouchmove ontouchend ontouchcancel
当用户按下手指在屏幕上，ontouchstart会被触发，当用户移动一个或多个手指的时候，ontouchmove会被触发，当用户移走手指， ontouchend被触发。那什么时候触发ontouchcancel呢？当一些更高级别的事件发生的时候，例如，alert，有电话打来或者有 推送的消息提示的时候会取消当前的touch操作，即触发ontouchcancel。当你在开发一个web game的时候，ontouchcancel 对你很重要，你可以在ontouchcancel触发的时候暂停游戏或者保存游戏。
gesture事件
gesture事件的运行原理与touch事件相同，只是gesture事件仅当屏幕上存在至少两个手指时触发，所以Safari2.0、Android3.0以上版本支持， 手势具备诸多优势，可以帮助我们测量两指放缩和旋转操作，事件模型如下，
ongesturestart ongesturechange ongestureend
事件属性
无论使用触摸还是手势事件，你都需要将这些事件转换为单独的触摸来使用它们。为此，你需要访问事件对象的一系列的属性。
targetTouches 目标元素的所有当前触摸 changedTouches 页面上最新更改的所有触摸 touches 页面上的所有触摸
changedTouches、targetTouches和touches分别包含稍微不同的触摸列表。targetTouches和touches分别包含当前位于 屏幕上的手指列表，但changedTouches仅列出最后发生的触摸。如果你在使用touchend或者gestureend事件，那么这个属性 非常重要。在这两种情况下，屏幕上都不会再出现手指，因此targetTouches和touches应该为空，但你仍然可以通过查看 changedTouches数组来了解最后发生的事情。
由于触摸属性都会生成数组，因此你可以使用JavaScript数组函数来访问它们。这意味着，event.touches[0]将返回第一次 触摸，并且可以使用event.touches.length来计算当前存储的触摸数量。
查看单独触摸时，通过使用event.targetTouches[0],你也可以访问其它触摸，每个触摸会包含一些具体信息，
clientX、clientY 相对于当前屏幕的X或Y位置 pageX、pageY 相对于整体页面的X或Y位置 screenX、screenY 相对于用户计算机屏幕的X或Y位置 identifier 事件的唯一标识符 target 生成触摸的目标对象
手势事件的事件对象会比普通触摸事件多两个属性，
rotation 手指的旋转角度 scale 放缩的值

underfined、null、0、false、NaN、空字符串的逻辑结果均为false。

从数组中随机获取成员
var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];
var  randomItem = items[Math.floor(Math.random() * items.length)];

获取指定范围内的随机数
var x = Math.floor(Math.random() * (max - min + 1)) + min;

生成从0到指定值的数字数组
var numbersArray = [] , max = 100;
for( var i=1; numbersArray.push(i++) < max;);  // numbers = [1,2,3 ... 100]

生成随机的字母数字字符串
function generateRandomAlphaNum(len) {
    var rdmString = "";
    for( ; rdmString.length < len; rdmString  += Math.random().toString(36).substr(2));
    return  rdmString.substr(0, len);
}

打乱数字数组的顺序
var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];
numbers = numbers.sort(function(){ return Math.random() - 0.5});
/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205]  */


字符串去空格
Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，
可以通过下面的代码来为String对象函数一个trim函数：
String.prototype.trim = function(){return this.replace(/^\s+|\s+$/g, "");};
新的JavaScript引擎已经有了trim()的原生实现。

数组之间追加
var array1 = [12 , "foo" , {name "Joe"} , -2458];
var array2 = ["Doe" , 555 , 100];
Array.prototype.push.apply(array1, array2);
/* array1 值为  [12 , "foo" , {name "Joe"} , -2458 , "Doe" , 555 , 100] */

对象转换为数组
var argArray = Array.prototype.slice.call(arguments);

验证是否是数组
function isArray(obj){
    return Object.prototype.toString.call(obj) === '[object Array]' ;
}
但如果toString()方法被重写过得话，就行不通了。也可以使用下面的方法：
Array.isArray(obj); // its a new Array method

获取数组中的最大值和最小值
var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; 
var maxInNumbers = Math.max.apply(Math, numbers); 
var minInNumbers = Math.min.apply(Math, numbers);


清空数组
var myArray = [12 , 222 , 1000 ];  
myArray.length = 0; // myArray will be equal to [].

使用length属性截断数组
var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];  
myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].
与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性。
myArray.length = 10; // the new array length is 10 
myArray[myArray.length - 1] ; // undefined

使得map()函数方法对数据循环
var squares = [1,2,3,4].map(function (val) {  
    return val * val;  
}); 
// squares will be equal to [1, 4, 9, 16]

保留指定小数位数
var num =2.443242342;
num = num.toFixed(4);  // num will be equal to 2.4432
注意，toFixec()返回的是字符串，不是数字。

浮点计算的问题
0.1 + 0.2 === 0.3 // is false 
9007199254740992 + 1 // is equal to 9007199254740992
9007199254740992 + 2 // is equal to 9007199254740994
为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，
在内部都是64位浮点小数表示.
可以通过使用toFixed()和toPrecision()来解决这个问题。


通过for-in循环检查对象的属性
for (var name in object) {  
    if (object.hasOwnProperty(name)) { 
        // do something with name
    }  
}

逗号操作符
var a = 0; 
var b = ( a++, 99 ); 
console.log(a);  // a will be equal to 1 
console.log(b);  // b is equal to 99

提前检查传入isFinite()的参数
isFinite(0/0) ; // false
isFinite("foo"); // false
isFinite("10"); // true
isFinite(10);   // true
isFinite(undefined);  // false
isFinite();   // false
isFinite(null);  // true，这点当特别注意

用JSON来序列化与反序列化
var person = {name :'Saad', age : 26, department : {ID : 15, name : "R&D"} };
var stringFromPerson = JSON.stringify(person);
/* stringFromPerson 结果为 "{"name":"Saad","age":26,"department":{"ID":15,"name":"R&D"}}"   */
var personFromString = JSON.parse(stringFromPerson);
/* personFromString 的值与 person 对象相同  */

不要使用eval()或者函数构造器
eval()和函数构造器（Function consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。
var func1 = new Function(functionCode);
var func2 = eval(functionCode);

不要对数组使用for-in
避免：
var sum = 0;  
for (var i in arrayNumbers) {  
    sum += arrayNumbers[i];  
}
而是：
var sum = 0;  
for (var i = 0, len = arrayNumbers.length; i < len; i++) {  
    sum += arrayNumbers[i];  
}


使用XMLHttpRequests时注意设置超时
XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过setTimeout()来完成这个工作：
var xhr = new XMLHttpRequest (); 
xhr.onreadystatechange = function () {  
    if (this.readyState == 4) {  
        clearTimeout(timeout);  
        // do something with response data 
    }  
}  
var timeout = setTimeout( function () {  
    xhr.abort(); // call error callback  
}, 60*1000 /* timeout after a minute */ ); 
xhr.open('GET', url, true);  
xhr.send();
同时需要注意的是，不要同时发起多个XMLHttpRequests请求。


