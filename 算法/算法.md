##算法基本知识和静态表 
一、算法的基本知识

1.编写程序的基本规则

①尽量少使用内存空间。②尽量少的代码量解决问题。

2.数据的特点

①必须能够输入到计算机。②必须能够被程序处理。

3.数据的几个概念

①数据元素：组成数据的基本单位。②数据项：一个元素由若干个数据组成。③数据对象：性质相同的数据元素的集合。
<pre>
struct Student{           //一种数据类型
	char *name;
	int age;
};
struct Student s;         //数据元素
struct Student stu[100];  //数据对象
s.name="Jason";           //数据项
s.age=21;                 //数据项
</pre>
4.数据的结构的组成

（1）逻辑结构：集合结构、线性结构、树形结构、图形结构

（2）物理结构：

①顺序存储结构：将数据存储在连续的存储单元里。（例如数组）
②链式存储结构：将数据存储在任意的存储单元里，通过保存地址的方式找到相关联的数据。

5.数据结构静态描述了数据元素之间的关系。高效的程序需要在数据结构的基础上设计合理的算法。

算法的概念：是特定的问题的求解步骤的描述。在计算机中表现为指令的有序序列。

6.算法的特性：（1）输入（2）输出（3）有穷性（4）确定性（5）可行性

7.程序 = 数据结构 + 算法。

8.算法的效率表示方法采用大O表示法。

概念：大O的表示法（O()），也就是查看最高次项的表示法。分析的算法的时间复杂度，指的都是算法的最坏时间复杂度。
算法的空间复杂度：
S(n) = O(f(n))

大O表示方法：

- 算法效率严重依赖于操作(Operation)数量
- 在判断时首先关注操作数量的最高次项
- 操作数量的估算可以作为时间复杂度的估算
<pre>
O(5) = O(1)
O(2n+1) =O(2n)=O(n)
O(n^2+n+1)=O(n^2)
O(3n^3+1)=O(3n^3)=O(n^3)
</pre>
二、线性表的基本概念

1.定义：

（1）线性表是由0个或者多个数据元素组成的集合。
（2）线性表中数据元素之间是有顺序的。
（3）线性表中的数据元素的个数必须有限。
（4）线性表中的数据元素类型必须相同。

线性表是具有相同类型的n个数据元素的有限序列。

2.特性：

（1）第一个元素只有一个后继
（2）线性表的最后一个元素只有一个前驱
（3）除了a0和an以外其他的元素都应该既有前驱又有后继
（4）线性表能够逐项访问和顺序存取

3.线性表的相关操作：

（1）创建
（2）销毁
（3）得到长度
（4）从线性表删除一个元素
（5）从线性表添加一个元素
（6）在线性表的特定位置添加元素

三、线性表的操作和具体实现

1.线性表的顺序存储定义：用一段地址连续的内存单元依次存储线性表的数据元素。

2.线性表的具体操作：
<pre>
#ifndef _1_H_  
#define _1_H_  
  
//这里是一个类型封装，对外接口都是void*。  
typedef void SeqList;  
typedef void SeqListNode;  
  
//定义一个线性表的最大容量  
SeqList* SeqList_Create(int capacity);  
  
void SeqList_Destroy(SeqList* list);  
  
void SeqList_Clear(SeqList* list);  
  
int SeqList_Length(SeqList* list);  
  
//返回顺序表的最大容量  
int SeqList_Capacity(SeqList* list);  
  
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos);  
  
SeqListNode* SeqList_Get(SeqList* list, int pos);  
  
SeqListNode* SeqList_Delete(SeqList* list, int pos);  
  
#endif 
</pre>
###总结
1. 本节的代码是一个可以适合各种类型的顺序表，之所以能够适合各种类型，是因为它在顺序表中保存的是元素的地址(其实就是一个指针数组)。
2. 代码中的描述顺序表的结构体中的元素介绍：length是顺序表中有元素的个数、capacity是顺序表的容量、node是顺序表的头地址(也是这个指针数组的头地址)、还有一个就是pos，pos是在删除和插入的时候使用的一个参数，它代表的是插入到顺序表位置的下标(数组的下标 是从0开始的 这个很要注意)。顺序表中有length个元素 下标是从0到length-1的。要注意的是 操作顺序表不同功能函数的pos的允许范围是不一样的。
3. 本节代码对于函数参数的合法性判断是极其重视的，这个规范是值得学习的。
4. 本节代码中对于顺序表的操作函数，凡是外界输入的，和输出到外界的，都是void *类型的，这样就保证了只有在这些操作函数中才能去改变   描述顺序表的结构体里面的值，在其他文件的函数中接受到的都是void *类型，无法直接给这个结构体中的值进行改变，这样的封装，保证了代码的安全性。
5. 对于本节代码最值得思考的地方，常见的顺序表是typedef一个A类型，然后在顺序表中定义一个这个A类型的数组和length顺序表元素个数，这个顺序表中是好多个A类型的顺序集合，占用空间的大小是sizeof(A)*capacity。而本节的顺序表中是好多个unsigned int *地址类型的顺序集合，表中只有地址，第一节省了顺序表的空间，第二这样可以变相的保存不同类型的数据，第三它实现了 顺序表(即数据结构) 和 我们打算利用的数据(即元素)的分离。例如：linux内核链表(一个双向循环链表)就是一套单独的链表体制，这个链表用在很多机制上面，它就是变相的存储了好多类型的数据，并且实现了链表和数据的分离。



##缓存淘汰算法|LRU算法
LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。<br>
内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。
###实现
1. 新数据插入到链表头部；
2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3. 当链表满的时候，将链表尾部的数据丢弃。
###分析
【命中率】

当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。

【复杂度】

实现简单

【代价】

命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。
<pre>
package main  
  
  
/*LRU Cache  
1.key记录在map
2.对于set/get添加或命中的元素移到链表头
3.如总个数大于Cache容量(cap),则将最末的元素移除.
*/
  
import (  
    "fmt"   
	"container/list"  
    "errors" 
)  
  
type CacheNode struct {  
    Key,Value interface{}     
}  
  
func (cnode *CacheNode)NewCacheNode(k,v interface{})*CacheNode{  
    return &CacheNode{k,v}  
}  
  
type LRUCache struct {  
    Capacity int      
    dlist *list.List  
    cacheMap map[interface{}]*list.Element  
}  
  
func NewLRUCache(cap int)(*LRUCache){  
    return &LRUCache{  
                Capacity:cap,  
                dlist: list.New(),  
                cacheMap: make(map[interface{}]*list.Element)}  
}  
  
func (lru *LRUCache)Size()(int){  
    return lru.dlist.Len()  
}  
  
func (lru *LRUCache)Set(k,v interface{})(error){  
  
    if lru.dlist == nil {  
        return errors.New("LRUCache结构体未初始化.")         
    }  
  
    if pElement,ok := lru.cacheMap[k]; ok {       
        lru.dlist.MoveToFront(pElement)  
        pElement.Value.(*CacheNode).Value = v  
        return nil  
    }  
  
    newElement := lru.dlist.PushFront( &CacheNode{k,v} )  
    lru.cacheMap[k] = newElement  
  
    if lru.dlist.Len() > lru.Capacity {        
        //移掉最后一个  
        lastElement := lru.dlist.Back()  
        if lastElement == nil {  
            return nil  
        }  
        cacheNode := lastElement.Value.(*CacheNode)  
        delete(lru.cacheMap,cacheNode.Key)  
        lru.dlist.Remove(lastElement)  
    }  
    return nil  
}  
 
func (lru *LRUCache)Get(k interface{})(v interface{},ret bool,err error){  
  
    if lru.cacheMap == nil {  
        return v,false,errors.New("LRUCache结构体未初始化.")         
    }  
  
    if pElement,ok := lru.cacheMap[k]; ok {       
        lru.dlist.MoveToFront(pElement)       
        return pElement.Value.(*CacheNode).Value,true,nil  
    }  
    return v,false,nil  
}  
  
func (lru *LRUCache)Remove(k interface{})(bool){  
  
    if lru.cacheMap == nil {  
        return false  
    }  
  
    if pElement,ok := lru.cacheMap[k]; ok {  
        cacheNode := pElement.Value.(*CacheNode)  
        delete(lru.cacheMap,cacheNode.Key)        
        lru.dlist.Remove(pElement)  
        return true  
    }  
    return false  
}  

func main(){  
  
    lru := NewLRUCache(3)  
  
    lru.Set(10,"value1")  
    lru.Set(20,"value2")  
    lru.Set(30,"value3")  
    lru.Set(10,"value4")  
    lru.Set(50,"value5")  
  
    fmt.Println("LRU Size:",lru.Size())  
    v,ret,_ := lru.Get(30)  
    if ret  {  
        fmt.Println("Get(30) : ",v)  
    }  
  
    if lru.Remove(30) {  
        fmt.Println("Remove(30) : true ")  
    }else{  
        fmt.Println("Remove(30) : false ")  
    }  
    fmt.Println("LRU Size:",lru.Size())  
}  
output==>
LRU Size: 3
Get(30) :  value3
Remove(30) : true 
LRU Size: 2
</pre>


###泛型理解
####定义
泛型：实质：一次编码，多次使用。类型化参数。（参数的类型 当做不定值）

####优点
1. 使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能。
2. 泛型最常见的用途是创建集合类，在集合类中，泛型被应用的淋漓尽致。
3. 可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
4. 可以对泛型类进行约束以限制使用这个类的具体版本。
5. 泛型中使用的参数类型可以在运行时通过反射获取相关信息。
####示例
 类：public class person<T>
{
    public void shou(T temp) { int a = "手";}
    public void yan() { int b = "眼"; }
}

调用：

  person<int> p = new person<int>();
        p.shou(1);
        person<string> s = new person<string>();
        s.shou("a");

可以看出，泛型类与Object实现的类有很大的区别：
　　1.、泛型类比object实现的类更安全。实例化了int类型的堆栈，就不能处理string类型的数据，而且处理了别的类型的数据，在编译的时候就通不过，很安全。
　　2、Object实现的类需要进行装箱和拆箱。泛型类可以在实例化时，按照传入的数据类型生成本地代码，这时，本地代码数据类型已确定，这样就无需装箱和拆箱。
　　3、泛型不需要进行数据类型转换，节省了CPU的计算时间。