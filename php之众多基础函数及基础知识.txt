++++++base64_encode()++++++
string base64_encode(string data)
将字符串以64位进行编码，可以让中文字或者图片也能在网络上顺利传输。

++++++get_loaded_extensions()++++++
这是查看php开启的扩展，输出的一个数组元素。

++++++setlocale() ++++++
函数设置地区信息（地域信息）。
设置地区为 US English，然后重新设置回系统默认：
<?php
echo setlocale(LC_ALL,"US");
echo "<br>";
echo setlocale(LC_ALL,NULL);
?>

++++++connection_aborted()来判断用户是否中断+++++++
error_reporting(E_ALL);  //显示报错信息  
var_dump(connection_status());   //显示用户的连接状态  
sleep(1);     //等待1秒  
if(connection_aborted()) die('连接中断');     //如果用户连接中断，停止运行  
echo "保持连接";  
ob_flush();       //存在输出缓存中的内容取出来，设置为等待输出状态  
flush();          //将等待输出缓存中内容，传给用户    
//记录时间，以查看是否已经运行  
$aaa = fopen("test.txt","a+");  
fwrite($aaa, date("Y-m-d H:i:s")."\n");  
fclose($aaa);  


++++++parse_str()函数++++++
将字符串解析成变量	
parse_str("id=23&name=John%20Adams",$myArray);
print_r($myArray);
结果为：
Array ( [id] => 23 [name] => John Adams )

++++++chr()函数++++++
返回指定ASCII值对应的字符
echo chr(077);
结果为：?

++++++ord()函数++++++
返回字符串对应的ASCII值
echo ord('H');
结果为：72

+++strpbrk()函数+++++++++
该函数返回指定字符第一次出现的位置开始的剩余部分，如果失败，返回false。
echo strpbrk('i love hz','ve');
结果是：
ve hz


+++++echo()函数+++++++
//PHP是先连接字符串再进行加法计算了.按照从左向右的方向进行的。
//如果将一个字符串强制转换成一个数字.PHP会去搜索这个字符串的开头.如果开头是数字就转换.如果不是就直接返回0

echo '5+1=' . 1+5;  //输出10
echo '5+1=' . 5+1;  //输出6
echo '5+1=' , 1+5;  //输出5+1=6
echo '5+1=' , 5+1;  //输出5+1=6

++++++strtr()函数+++++++  效果相当于str_replace()
该函数替换原字符串中出现过的所有相同元素。
echo strtr("Hilla Warld","ia","eo");
结果是：
Hello World; (strtr 将字符串中出现的所有i替换成e,a替换成o)

+++++++++str_replace()函数与preg_replace()函数+++++++++
str_replace(修改后的内容，希望替换的内容，原字符串或数组，替换的数目);
<?php
$arr = array("blue","red","green","yellow");
print_r(str_replace("red","pink",$arr,$i));
echo "替换数：$i";
?>
结果为：
Array ( [0] => blue [1] => pink [2] => green [3] => yellow ) 替换数：1
同样功能的函数有preg_replace()函数
preg_replace(修改后的内容，希望替换的内容，原字符串或数组）
转义字符串，json中常用。php5.2有一个系统函数json_encode()自带转义效果
public function escapeJsonString($value) {
    $escapers = array("\\", "/", "\"", "\n", "\r", "\t", "\x08", "\x0c");
    $replacements = array("\\\\", "\\/", "\\\"", "\\n", "\\r", "\\t", "\\f", "\\b");
    $result = str_replace($escapers, $replacements, $value);
    return $result;
}

++++++PHP寻找两个字符串的相似性similar_text()+++++++
PHP 提供了一个极少使用的 similar_text 函数，但此函数非常有用，用于比较两个字符串并返回相似程度的百分比
similar_text($string1, $string2, $percent);
实例：
similar_text('hhllo','hello',$percent);
echo $percent."%";
结果为：80%

++++++htmlspecialchars()函数++++++++
echo htmlspecialchars($str, ENT_COMPAT); // 只转换双引号
echo "<br>";
echo htmlspecialchars($str, ENT_QUOTES); // 转换双引号和单引号  ，更加安全


++++bin2hex()函数++++++++++
bin2hex 将二进位转成十六进位
语法：string bin2hex(string str);

+++++++strip_tags()函数+++++++++
strip_tags()函数去除 剥去 HTML、XML 以及 PHP 的标签。
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果为：
Hello NowaMagic!


+++++++++++ mb_convert_encoding()函数++++++++
mb_convert_encoding($str,'UTF-8','GBK')；将UTF-8格式的转为GBK
另外一个转码函数iconv()函数：
发现iconv在转换字符”—”到gb2312时会出错，如果没有ignore参数，所有该字符后面的字符串都无法被保存。
不管怎么样，这个”—”都无法转换成功，无法输出。 另外mb_convert_encoding没有这个bug. 
一般情况下用 iconv，只有当遇到无法确定原编码是何种编码，或者iconv转化后无法正常显示时才用mb_convert_encoding 函数. 
$content = iconv("GBK", "UTF-8", $str); (以上俩个函数会产生同样效果)
在使用iconv()时候，请不要转成"GB2312"的格式，因为这是iconv的一个bug，可以直接把gb2312写成gbk就OK了。

++++++++ stream_context_create()++++++++
作用：创建并返回一个文本数据流并应用各种选项，可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。 
函数原型：resource stream_context_create ([ array $options [, array $params ]] ) 
function Post($url, $post = null){
     $context = array();
     if (is_array($post)) {
         ksort($post);
         $context['http'] = array (
             'timeout'=>60,
             'method' => 'POST',
             'content' => http_build_query($post, '', '&'),
         );
     }
return file_get_contents($url, false,stream_context_create($context));
}

$data = array(
     'name' => 'test',
     'email' => 'test@gmail.com',
     'submit' => 'submit',
);
$str=Post('http://www.ej38.com', $data);
echo mb_convert_encoding($str,'UTF-8','GBK');

+++++++http_build_query()函数+++++++
将数组返回成一个url格式字符串
$data = array('foo'=>'bar',
              'baz'=>'boom',
              'cow'=>'milk',
              'php'=>'hypertext processor'
             );
echo http_build_query($data);
结果为：
foo=bar&baz=boom&cow=milk&php=hypertext+processor

+++++strstr()函数++++++++
检测一个字符串是否存在另一个字符串中，如果存在则返回检测原样（不加true）或者返回剩下部分
echo strstr('Hello','o');      返回 o
echo strstr('Hello','o',true); 返回 Hell
echo strstr('Hello','22');     不返回任何内容

+++++array_unique()函数+++++++
array_unique()可以去除一个一维数组中相同的元素，但是它不适用于多维数组，下面的方法可以解决。
function array_unique_fb($array2D)
{
    foreach ($array2D as $v)
    {
        $v = join(",",$v);  //降维,也可以用implode,将一维数组转换为用逗号连接的字符串
        $temp[] = $v;
    }
    $temp = array_unique($temp);    //去掉重复的字符串,也就是重复的一维数组
    foreach ($temp as $k => $v)
    {
        $temp[$k] = explode(",",$v);   //再将拆开的数组重新组装
    }
    return $temp;
}


+++++++str_repeat()函数+++++++
重复字符串：
$arr='12';
echo str_repeat($arr,4);
结果为：
12121212


++++str_word_count()函数+++++++++++++
str_word_count()函数，可以确定一个字符串中某个单词的出现次数。
$arr='gg rfg rghh ';
var_dump(str_word_count($arr,1,'g'));
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'rfg' (length=3)
  2 => string 'rghh' (length=4)


++++++++substr_count()函数++++++++++++
substr_count()函数：可以确定一个字符串在所提供的字符串中有多少个
$arr="fghyjffgyhjdsthshgvgfhds";
var_dump(substr_count($arr,'g'));
结果为：
int 4


+++++++array_flip()函数++++++++++
交换键名与键值
$arr=array('1'=>'a','2'=>'b','3'=>'c');
var_dump(array_flip($arr));
结果为：array (size=3)
  'a' => int 1
  'b' => int 2
  'c' => int 3


++++++array_key_exists()与in_array()函数+++++++
检查值、键：
array_key_exists($key,$array);//检查数组键
in_array($value,$array);//检查值于数组


++++++++array_slice()函数+++++++++
array_slice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
var_dump(array_slice($arr,1,1));
结果是：
array (size=1)
0 => string 'tgrt' (length=4)
array_splice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
array_splice($arr,4);
var_dump($arr);
结果是：
array (size=4)
  0 => string 'ffd' (length=3)
  1 => string 'tgrt' (length=4)
  2 => string 'rghd' (length=4)
  3 => string 'erhh' (length=4)

array_change_key_case()	返回其键均为大写或小写的数组。 	
array_chunk()	把一个数组分割为新的数组块。	
array_combine()	通过合并两个数组来创建一个新数组。	
array_count_values()	用于统计数组中所有值出现的次数。	
array_diff()	返回两个数组的差集数组。	
array_diff_assoc()	比较键名和键值，并返回两个数组的差集数组。	
array_diff_key()	比较键名，并返回两个数组的差集数组。	
array_diff_uassoc()	通过用户提供的回调函数做索引检查来计算数组的差集。	
array_diff_ukey()	用回调函数对键名比较计算数组的差集。	
array_fill()	用给定的值填充数组。	
array_filter()	用回调函数过滤数组中的元素。	
array_flip()	交换数组中的键和值。	
array_intersect()	计算数组的交集。	
array_intersect_assoc()	比较键名和键值，并返回两个数组的交集数组。	
array_intersect_key()	使用键名比较计算数组的交集。	
array_intersect_uassoc()	带索引检查计算数组的交集，用回调函数比较索引。	
array_intersect_ukey()	用回调函数比较键名来计算数组的交集。	
array_key_exists()	检查给定的键名或索引是否存在于数组中。	
array_keys()	返回数组中所有的键名。	
array_map()	将回调函数作用到给定数组的单元上。	
array_merge()	把一个或多个数组合并为一个数组。	
array_merge_recursive()	递归地合并一个或多个数组。	
array_multisort()	对多个数组或多维数组进行排序。	
array_pad()	用值将数组填补到指定长度。	
array_pop()	将数组最后一个单元弹出（出栈）。	
array_product()	计算数组中所有值的乘积。	
array_push()	将一个或多个单元（元素）压入数组的末尾（入栈）。	
array_rand()	从数组中随机选出一个或多个元素，并返回。	
array_reduce()	用回调函数迭代地将数组简化为单一的值。	
array_reverse()	将原数组中的元素顺序翻转，创建新的数组并返回。	
array_search()	在数组中搜索给定的值，如果成功则返回相应的键名。
array_shift()	删除数组中的第一个元素，并返回被删除元素的值。	
array_slice()	在数组中根据条件取出一段值，并返回。	
array_splice()	把数组中的一部分去掉并用其它值取代。	
array_sum()	计算数组中所有值的和。	
array_udiff()	用回调函数比较数据来计算数组的差集。	
array_udiff_assoc()	带索引检查计算数组的差集，用回调函数比较数据。
array_udiff_uassoc()	带索引检查计算数组的差集，用回调函数比较数据和索引。	
array_uintersect()	计算数组的交集，用回调函数比较数据。	
array_uintersect_assoc()	带索引检查计算数组的交集，用回调函数比较数据。	
array_uintersect_uassoc()	带索引检查计算数组的交集，用回调函数比较数据和索引。	
array_unique()	删除数组中重复的值。	
array_unshift()	在数组开头插入一个或多个元素。	
array_values()	返回数组中所有的值。	
array_walk()	对数组中的每个成员应用用户函数。	
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。	
arsort()	对数组进行逆向排序并保持索引关系。	
asort()	对数组进行排序并保持索引关系。	
compact()	建立一个数组，包括变量名和它们的值。	
count()	计算数组中的元素数目或对象中的属性个数。	
current()	返回数组中的当前元素。	
each()	返回数组中当前的键／值对并将数组指针向前移动一步。	
end()	将数组的内部指针指向最后一个元素。	
extract()	从数组中将变量导入到当前的符号表。	
in_array()	检查数组中是否存在指定的值。	
key()	从关联数组中取得键名。	
krsort()	对数组按照键名逆向排序。	
ksort()	对数组按照键名排序。	
list()	把数组中的值赋给一些变量。	
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。	
natsort()	用“自然排序”算法对数组排序。	
next()	将数组中的内部指针向前移动一位。	
pos()	current() 的别名。	
prev()	将数组的内部指针倒回一位。	
range()	建立一个包含指定范围的元素的数组。	
reset()	        将数组的内部指针指向第一个元素。	
rsort()	        对数组逆向排序。	
shuffle()	把数组中的元素按随机顺序重新排列。	
sizeof()	count() 的别名。	
sort()	        对数组排序。	
uasort()	使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。	
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。	
usort()	使用用户自定义的比较函数对数组中的值进行排序。

PHP函数microtime()返回当前 Unix 时间戳和微秒数。

++++++++strpos()++++++++
在使用该函数的时候。里面的位置一定要分清楚，strpos(原字符串，“需要查找的字符串片段”);
谨记谨记谨记

 
++++++++strcmp()函数++++++++
比较两个字符串（区分大小写）：
<?php
echo strcmp("Hello world!","Hello world!");
?>


++++++++array_unique(array)函数++++++++
该函数用来移除数组中的重复的值，并返回结果数组。
当几个数组元素的值相等时，只保留第一个元素，其他的元素被删除。
返回的数组中键名不变。

++++++++call_user_func()++++++++
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

++++++++preg_replace_callback()++++++++
preg_replace_callback()正则替换回调函数;

++++++++array_unshift()++++++++
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33

++++++++is_numeric()++++++++
is_numeric()检测变量是否为数字或数字字符串;如果是返回true,不是返回false;

++++++++strpos()++++++++
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()

++++++++array_filter()++++++++
array_filter(array,function);筛选出需要的结果
function myfudction($v)
{
if($v=="H")
{
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfudction"));

+++++++array_intersect()+++++++
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 

+++++++++join()+++++++++
join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串

+++++++面向对象：parent::关键字++++++++
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();


++++++++这里的$name可以直接用$this->name调用+++++++++
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();

+++++php构造函数与析构函数+++++
__construct()构造函数与__destruct()析构函数，前者是在一个类被实例化之前先被自动调用，无返回值，后者则是在销毁一个类之前自动执行一些东西，即两个的执行时间不一样，其他的区别不大。
final 关键字用于定义类和方法，该关键字表示该类或方法为最终版本，即该类不能被继承，或该方法在子类中不能被重载（覆盖）。


echo $HTTP_COOKIE_VARS["TestCookie"]; 输出所有cookie值。

+++++++mktime()++++++
mktime()函数适合用来进行日期计算和校验，设定一个固定日期。
echo date('Y-m-d H:i:s',mktime(0,0,0,12,30,1997));  //输出1997-12-30 00:00:00
echo date('Y-m-d H:i:s',mktime(0,0,0,12,32,1997));  //输出1998-01-01 00:00:00



TCP / IP长连接&连接池的应用
我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。
TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。
在有些文章里总会提到这名词、或者五元组，甚至七元组。虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：
四元组： 源IP地址、目的IP地址、源端口、目的端口
五元组： 源IP地址、目的IP地址、协议、源端口、目的端口
七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引
在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。
再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。
HTTP的长连接
HTTP长连接，HTTP持久连接（HTTPpersistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。
在HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：
Connection: Keep-Alive
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive
这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
在HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。
然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。
loading...
Keep-Alive的优势
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接
Keep-Alive的劣势
对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。
根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。这个指引旨在提高HTTP响应时间并避免阻塞。
但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。
动静分离
为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。
动静分离同时还会有一个额外的好处：
对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后，请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。
如下表：
loading...
一、IT技术文章：
回复"1",查看——“ 如何深入了解linux”
回复"2",查看——“Python 自动化框架”
回复"3",查看——“ Linux 运维职业规划”
回复"4",查看——“提升B格的命令技巧”
回复"5",查看——“网络编程-从Apache到Nginx”
回复"6",查看——“两个使用的Python 装饰器
回复"7",查看——“Python 多线程、进程那些事”
回复"8",查看——“1000，000 packets/s的挑战”
回复"9",查看——“Op危机，你嗅到了没？”
回复"10",查看——“干货丨戏说非阻塞网络编程”
回复"11",查看——“用Python写一个简单的监控系统”
回复"12",查看——“提高你Python 编码效率的‘武林秘籍’”
二、最新课程：
回复"课程",查看——最新课程消息
回复"报名"，查看——报名咨询方式
回复"Reboot",查看——Reboot简介



strstr和strcchr的区别
strstr 显示第一次找到，要查找的字符串，以及后面的字符串。 
strrchr 显示最后一次找到，要查找的字符串，以及后面的字符串。
<?php 
$email = 'test@test.com@jb51.net'; 
$domain = strstr($email, '@'); 
echo "strstr 测试结果 $domain<br>"; 
$domain = strrchr($email, '@'); 
echo "strrchr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 @test.com@jb51.net 
strrchr 测试结果 @jb51.net

substr用法：
<?php $email = 'zhangYingy@jb51.net'; 
$domain = substr($email, 6); 
echo "substr 测试结果 $domain<br>"; 
?>
结果如下：
substr 测试结果 ingy@jb51.net

+++++++++php默认变量+++++++++
echo __FILE__;//这是文件完整的地址为：D:\wamp\wamp\apps\think\test.php
echo __LINE__;//显示这一句所在的行数
echo PHP_VERSION;//显示php版本
echo PHP_OS; //显示php运行系统名称
echo TRUE;  //1,同理FALSE结果为0
echo E_ERROR;
echo "<br>";
//可以用define函数自定义默认变量
define('COPYRIGHT','Copyright');
echo COPYRIGHT;

$testa=array('0'=>array('id'=>14),'1'=>array('id'=>23),'3'=>array('id'=>32));
array_slice($testa,1-1,'id');
var_dump($testa);exit;
用array_slice()可以更换数组的键名，不过如果键名相同，数组会自动添加新的键名，结果会是这样；
array (size=3)
  0 => 
    array (size=1)
      'id' => int 14
  1 => 
    array (size=1)
      'id' => int 23
  3 => 
    array (size=1)
      'id' => int 32


+++++++urlencode()函数+++++++
本函数将字符串以 URL 编码。例如空格就会变成加号。
Homepage 中 form 资料传送就是用 urlencode 编码后再送出。

bool array_walk ( array &array, callback funcname [, mixed userdata] ) 对数组中的每个成员应用用户函数
array array_map ( callback callback, array arr1 [, array ...] )将回调函数作用到给定数组的单元上
array array_fill ( int start_index, int num, mixed value ) 用给定的值填充数组
array_fill(5, 3, 'a')-->array(5=>'a',6=>'a',7=>'a')
array array_chunk ( array input, int size [, bool preserve_keys] )将一个数组分割成多个


++++++array_multisort()这个函数+++++++
有时候我们需要对二维数组的某个键的值进行排序，这里就是讨论这个问题。
我们可以使用array_multisort()这个函数。array_multisort() 函数对多个数组或多维数组进行排序。

++++++list() 函数:+++++++
list() 函数用数组中的元素为一组变量赋值。
注意，与 array() 类似，list() 实际上是一种语言结构，不是函数。
<?php
	$my_array = array("Dog","Cat","Horse");
	list($a, , $c) = $my_array;
	echo "Here I only use the $a and $c variables.";
?>  
运行结果： Here I only use the Dog and Horse variables.

+++++++number_format() 函数:+++++++
number_format() 函数通过千位分组来格式化数字。
<?php
$num = 500000;
echo number_format($num);
// 500,000
echo number_format($num, 2);
// 500,000.00
echo number_format($num, 3, ".", ",");
// 500,000.000
?>

+++++php5常用函数++++++
    connection_status() 函数返回当前的连接状态。
　　connection_aborted() 函数检查是否断开客户机。
　　zip_read() 函数读取打开的 zip 档案中的下一个文件。
　　zip_open() 函数打开 ZIP 文件以供读取。
　　zip_entry_read() 函数从打开的 zip 档案项目中获取内容。
　　zip_entry_open() 函数打开一个 ZIP 档案项目以供读取。
　　PHP5常用函数之zip_entry_name() 函数返回 zip 档案项目的名称。
　　zip_entry_filesize() 函数返回 zip 档案项目的原始大小(在压缩之前)。
　　zip_entry_compressionmethod() 函数返回 zip 档案项目的压缩方法。
　　zip_entry_compressedsize() 函数返回 zip 档案项目的压缩文件尺寸。
　　zip_entry_close() 函数关闭由 zip_entry_open() 函数打开的 zip 档案文件。
　　zip_close() 函数关闭由 zip_open() 函数打开的 zip 档案文件。
    file_exists($file)    判断文件是否存在
    gettype();            获取数据类型

+++++++++file_put_contents()函数+++++++++
file_put_contents(文件名，要加的内容，) 函数把一个字符串写入文件中。
与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。
而file_put_contents(,,FILE_APPEND)则是追加效果，适合用来写日志文件。

	
++++$_SERVER['HTTP_REFERER']++++++
<?php echo $_SERVER['HTTP_REFERER'];?>可以得到链接/提交当前页的父页面URL
如果返回“找不到文件”的提示，则可用 header 函数，header("HTTP/1.0 404 Not Found").
写出一个正则表达式，过虑网页上的所有JS/VBS脚本（即把标记及其内容都去掉）.
/<[^>].*?>.*?<\/>/si


++++php数组中对键名与键值的操作+++++++
arra_keys()获得数组键名
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_keys($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => int 1
  1 => int 2
  2 => int 3
array_values()获得数组键值
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_values($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'sd' (length=2)
  2 => string 'rg' (length=2)


+++++++++parse_url()函数:+++++++++
parse_url() 函数可以解析 URL，返回其组成部分。它的用法如下：
array = parse_url( string url );
<?php 
  $url="http://www.nowmagic.net/welcome/";
  $parts=parse_url($url);
  print_r($parts);
?>
结果是：Array ( [scheme] => http [host] => www.nowmagic.net [path] => /welcome/ )  ;


+++++++strip_tags()函数+++++++
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果是：Hello NowaMagic!


+++++shuffle()函数+++++++++
将数组随机打乱
<?php 
  $data=array('111','222','333','444','555','666');
  shuffle($data);
  print_r($data);
  结果是：Array ( [0] => 222 [1] => 555 [2] => 333 [3] => 111 [4] => 444 [5] => 666 ) 
?>

++++++http_bluid_query()函数++++++
将数组变成url
<?php 
  $data = array(
   'site'=>'www.nowamagic.net', 
	'foo'=>'bar', 
	'baz'=>'boom', 	
	'name'=>'nowamagic'); 
  echo http_build_query($data); 
?>
结果为：site=www.nowamagic.net&foo=bar&baz=boom&name=nowamagic

++++++stream_context_create()函数+++++++
stream_context_create() 作用：创建并返回一个文本数据流并应用各种选项，
可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。

++++++++++查看本地目录之glob()和scandir()+++++++++
glob()函数
$img=array('gif','png','jpg');
$dir='img/';  //查找的文件名所在目录
$pic=array();
foreach($img as $k=>$v){
	$pattern=$dir.'*.'.$v;
	$all=glob($pattern);
	$pic=array_merge($pic,$all);
}
var_dump($pic);
foreach($pic as $p){
echo $p.'<br>';
}
上面的等同于：
$files=glob('img/*.jpg');
print_r($files);
结果均为：
array (size=2)
  0 => string 'img/test.jpg' (length=12)
  1 => string 'img/test2.jpg' (length=13)

scandir()函数：
$dir='img/';
$file=scandir($dir);
print_r($file);
结果为：
Array ( [0] => . [1] => .. [2] => test.jpg [3] => test2.jpg ) 


+++++++++数组比较函数 array_diff()与array_diff_assoc()函数+++++++
array_diff_assoc() 函数返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键和值。
和 array_diff()函数不同，本函数要求键名和键值都进行比较。返回的数组中键名保持不变。
array_diff() 能比较key和value，而实际上它只比较了value，而不关心key，如果关心key的话，可以使用函数array_diff_assoc().

++++++++php数组求交集的array_intersect()函数与array_intersecct_assoc()函数：++++++++++
array_intersect        计算数组的交集，只关心value，不关心key；
array_intersect_assoc  带索引检查计算数组的交集。


json_encode()与json_decode()
这是PHP的原生函数，然而在今天JSON越来越流行，所以在PHP5.2以后，
PHP开始支持JSON，你可以使用 json_encode() 和 json_decode() 函数

filectime — 取得文件的 inode 修改时间
filemtime — 取得文件修改时间
fileatime — 取得文件上次访问时间
fileperms -- 取得文件的访问权限
is_executable — 判断给定文件名是否可执行



++++++get_headers()函数++++++++++
get_headers()获取所有的，由服务器发送的响应一个HTTP请求的头信息
$url='http://www.example.com';
print_r(get_headers($url));
结果为：
Array(
 [0] => HTTP/1.1 200 OK 
 [1] => Date: Sat, 29 May 2004 12:28:13 GMT 
 [2] => Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)
 [3] => Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
 [4] => ETag: "3f80f-1b6-3e1cb03b"
 [5] => Accept-Ranges: bytes
 [6] => Content-Length: 438
 [7] => Connection: close
 [8] => Content-Type: text/html 
) 


++++++php魔幻方法+++++++
php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。  
PHP中的魔术方法有 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone, __autoload  
1、__get、__set  
这两个方法是为在类和他们的父类中没有声明的属性而设计的  
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名  
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值  
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）。  
2、__isset、__unset  
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法  
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法  
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）  
3、__call  
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法  
这里的未定义的方法包括没有权限访问的方法；如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方​法，如果本类中不存在__call()方法就去找父类中的__call()方法   
4、__autoload  
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。  
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：  
<?php    
class Loader    
{    
static function autoload_class($class_name)    
{    
//寻找正确的$class_name类，并引入，没有则抛出异常    
}    
}    
/**
*   设置对象的自动载入 
*   spl_autoload_register — Register given function as __autoload() implementation 
*/    
spl_autoload_register(array('Loader', 'autoload_class'));    
    
$a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类    
    
?>    
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。  
5、__construct、__destruct  
__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称  
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。  
在一个函数的命名空间内，这会发生在函数return的时候。  
对于全局变量,这发生于脚本结束的时候。  
如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.  
6、__clone  
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。  
7、__toString  
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。  
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in  
此方法必须返回一个字符串。  
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。  
8、__sleep、__wakeup  
__sleep 串行化的时候用  
__wakeup 反串行化的时候调用  
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。  
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。  
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。  
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。  
9、__set_state  
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。  
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。  
10、__invoke  
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。  
PHP5.3.0以上版本有效  
11、__callStatic  
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，  
PHP5.3.0以上版本有效  
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此  

使用POSIX兼容规则的函数有：  
ereg_replace()  
ereg()  
eregi()  
eregi_replace()  
split()  
spliti()  
sql_regcase()  
mb_ereg_match()  
mb_ereg_replace()  
mb_ereg_search_getpos()  
mb_ereg_search_getregs()  
mb_ereg_search_init()  
mb_ereg_search_pos()  
mb_ereg_search_regs()  
mb_ereg_search_setpos()  
mb_ereg_search()  
mb_ereg()  
mb_eregi_replace()  
mb_eregi()  
mb_regex_encoding()  
mb_regex_set_options()  
mb_split()  
  
使用PERL兼容规则的函数有：  
preg_grep()  
preg_replace_callback()  
preg_match_all()  
preg_match()  
preg_quote()  
preg_split()  
preg_replace()  


+++++++json_encode()与json_decode()++++++++
<?php   
$json = '{"a":"php","b":"mysql","c":3}';  
$json_Class=json_decode($json);   
$json_Array=json_decode($json, true);   
print_r($json_Class);   
print_r($json_Array);   
?>
程序输出：
   stdClass Object ( 
    [a] => php 
    [b] => mysql 
    [c] => 3 ) 
    Array ( 
    [a] => php 
    [b] => mysql 
    [c] => 3 )  
在上面代码的前提下,访问对象类型$json_Class的a的值

echo $json_Class->{'a'};     //看这里，两者访问方法不一样
        程序输出：php
 访问数组类型$json_Array的a的值
echo $json_Array['a'];       //看这里，两者访问方法不一样
        程序输出：php   


++++++sleep()函数++++++死循环
无限执行程序，容易导致浏览器或电脑崩溃哟
ignore_user_abort();//关闭浏览器后，继续执行php代码
set_time_limit(0); //程序执行时间无限制
$intval=60; 
   do{
     $msg=date("Y-m-d H:i:s");
     echo date('Y-m-d H:i:s',time());
     file_put_contents("log.log",$msg,FILE_APPEND);//记录日志
    sleep($interval);//等待时间，进行下一次操作。
	
  }while(true);


+++++flush()与ob_flush()函数+++++++
实现php定时执行功能。
header("Content-Type: text/html");
set_time_limit(0);
$infoString = "Hello World";
while( isset($infoString) )
{
echo $infoString;
flush();  //把不在缓冲中的或者说是被释放出来的数据发送到浏览器
ob_flush(); //把数据从PHP的缓冲中释放出来，必须配合flush()使用
sleep(5);
}
