##栈的定义及实现
这里的栈的实现采用的是复用顺序表和单向链表的方式。
###栈的基本定义

1. 栈是一种特殊的线性表，只能从固定的方向进出，而且栈进出的基本原则是：先进栈的元素后出栈。
2. 对栈顶栈底的定义：<br>
栈顶：允许操作的一端；栈底：不允许操作的一端。
###栈的基本实现方式
####1.顺序栈
1.首先定义的顺序栈中的数据结点的结构，主要包括两个部分，一部分是数据元素，另一部分是顺序栈的长度。

具体代码如下：
<pre>
typedef struct _tag_stack_  
{  
    int a[20];  
    int top;  
}Sqstack; 
</pre>
2.使用顺序栈之前要先初始化顺序栈。

主要是为顺序栈结点分配一个空间，然后将顺序栈的长度初始化为0.
<pre>
Sqstack* InitStack ()  
{  
    Sqstack *ret = NULL;  
    ret = (Sqstack*)malloc (sizeof(Sqstack));  
    if (ret)  
    {  
        /*将栈的长度初始化为0*/   
        ret -> top = 0;  
    }  
    return ret;  
}  
</pre>
3.将元素压入栈，这里采用复用方式。
<pre>
int Push(Sqstack *stack, int data)  
{  
    /*这里有一个复用方式，也就是顺序栈的长度和数组的下标进行复用s*/  
    stack -> a[stack -> top] = data;  
    stack -> top++;  
    return 1;  
}
</pre>
4.将已经在栈中的元素进行打印，因为栈不是只是一种存储数据的结构，所以我们不经过弹出栈中的元素也是可以访问到栈中的元素的。
<pre>
void Play (Sqstack *stack)  
{  
    int i = 0;  
    if (stack -> top == 0)  
    {  
        printf ("It is empty\n");  
    }  
    /*stack -> top，栈的长度*/  
    else  
    {  
        for (i = 0; i < stack -> top; i++)  
        {  
            printf ("栈中的数据为：%d\n", stack -> a[i]);  
        }  
    }  
}
</pre>
5.数据结点出栈
<pre>
int Pop (Sqstack *stack, int *data)  
{  
    if (stack -> top == 0)  
    {  
        printf ("the stack is empty\n");  
        printf ("弹出已经被改变了的u的值");  
    }  
    else  
    {     
        stack -> top--;  
        *data = stack -> a[stack -> top];  
    }  
    return 1;     
}  
</pre>
6.测试部分代码如下：
<pre>
int main()  
{     
    int h = 4;  
    int p = 0;  
    int i = 0;  
    int u = 3;  
    Sqstack* qq;  
      
    qq = InitStack();  
              
    for (i = 0; i < 5; i++)  
    {  
        Push (qq, i);  
    }  
    Play (qq);  
      
    /*弹出操作*/  
    Pop (qq, &u);  
    printf ("弹出的元素是：%d\n",u);  
    Pop (qq, &u);  
    printf ("弹出的元素是：%d\n",u);  
    Pop (qq, &u);  
    printf ("弹出的元素是：%d\n",u);  
    Pop (qq, &u);  
    printf ("弹出的元素是：%d\n",u);  
    Pop (qq, &u);  
    printf ("弹出的元素是：%d\n",u);  
    Pop (qq, &u);  
    printf ("%d\n",u);  
  
    return 1;  
}  
</pre>
7.虽然顺序栈实现了栈的基本功能，毕竟是顺序存储结构，而且占用的内存空间也必须是连续的，所以还是有一定的局限性的。

综上所述，可以将顺序表实现栈的建立和进栈出栈的过程用下面的代码总结。
<pre>
    #include <stdio.h>  
    #include "1.h"  
    #include "SeqList.h"   
      
    /******************************************************************************* 
    *函数名： SeqStack_Create 
    *参数：capacity 栈中元素的个数  
    *返回值：SeqStack*类型，是一个void*类型，然后再由接收函数进行强制类型转换  
    *功能：创建顺序栈，调用顺序表创建函数  
    *******************************************************************************/   
    SeqStack* SeqStack_Create(int capacity)  
    {  
        return SeqList_Create(capacity);  
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Destroy 
    *参数：SeqStack* stack 栈指针  
    *返回值：void  
    *功能：销毁顺序栈，调用顺序表销毁函数  
    *******************************************************************************/   
    void SeqStack_Destroy(SeqStack* stack)  
    {  
        SeqList_Destroy (stack);  
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Clear 
    *参数：SeqStack* stack 栈指针  
    *返回值：void  
    *功能：清空顺序栈，调用顺序表清空函数  
    *******************************************************************************/   
    void SeqStack_Clear(SeqStack* stack)  
    {  
        SeqList_Clear (stack);   
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Push 
    *参数：SeqStack* stack 栈指针  void* item要进栈的元素  
    *返回值：void  
    *功能：将一个item元素压入栈  
    *******************************************************************************/   
    int SeqStack_Push(SeqStack* stack, void* item)  
    {  
        return SeqList_Insert(stack, item, SeqList_Length(stack));  
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Pop 
    *参数：SeqStack* stack 栈指针  
    *返回值：void  
    *功能：将元素弹出栈  
    *******************************************************************************/  
    void* SeqStack_Pop(SeqStack* stack)  
    {  
        return SeqList_Delete(stack, SeqList_Length(stack) - 1);   
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Top 
    *参数：SeqStack* stack 栈指针  
    *返回值：void  
    *功能：获取栈顶元素  
    *******************************************************************************/  
    void* SeqStack_Top(SeqStack* stack)  
    {  
        return SeqList_Get(stack, SeqList_Length(stack) - 1);  
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Size 
    *参数：SeqStack* stack 栈指针  
    *返回值：int 返回栈的长度  
    *功能：获取栈的长度  
    *******************************************************************************/  
    int SeqStack_Size(SeqStack* stack)  
    {  
        return SeqList_Length (stack);  
    }  
      
    /******************************************************************************* 
    *函数名： SeqStack_Capacity 
    *参数：SeqStack* stack 栈指针  
    *返回值：void  
    *功能：获取栈的容量  
    *******************************************************************************/  
    int SeqStack_Capacity(SeqStack* stack)  
    {  
        return SeqList_Capacity(stack);  
    }  
</pre>
测试代码：
<pre>
#include <stdio.h>  
#include <stdlib.h>  
#include "1.h"  
  
/*int main(int argc, char *argv[]) 
{ 
    int i; 
    int a[10]; 
    int q = 20; 
    int temp; 
     
    SeqStack* stack = SeqStack_Create (20); 
    for (i = 1; i < 10; i++) 
    { 
        a[i] = i; 
        SeqStack_Push (stack, a + i); 
    }  
     
    printf ("栈的长度是： %d\n", SeqStack_Size (stack)); 
     
    /*这里必须加上强制类型转换，因为调用函数结束以后返回的也是void *类型，所以要转换*/  
    /*printf ("栈顶元素是： %d\n", *(int*)SeqStack_Top (stack)); 
     
    for (i = 1; i < 10; i++) 
    { 
        printf ("栈中的元素分别是：%d\n", *(int *)SeqStack_Pop (stack)); 
    }  
     
     
    temp =  (int) SeqStack_Capacity(stack); 
    printf ("栈的容量为：%d\n", temp); 
     
    temp = SeqStack_Size(stack);  
    printf ("栈的元素个数为：%d\n", temp); 
     
    return 0; 
}*/  
  
  
int main()  
{  
    int i = 0;  
    char a[10];  
    char temp;  
      
    SeqStack* stack = SeqStack_Create (20);  
    for (i = 0; i < 9; i++)  
    {  
        a[i] = 'a';  
        SeqStack_Push (stack, a + i);  
    }  
    a[9] = 'b';  
    SeqStack_Push (stack, a + 9);     
      
    for (i = 0; i < 10; i++)  
    {  
        temp = *(char*)SeqStack_Pop (stack);  
        printf ("%c\n", temp);  
    }  
    return 0;  
}  
</pre>