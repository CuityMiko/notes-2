###web工作方式
对于普通的上网过程，系统其实是这样做的：浏览器本身是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP，然后通过IP地址找到IP对应的服务器后，要求建立TCP连接，等浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。<br>
一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是Web浏览器(其实手机端客户端内部也是浏览器实现的)。

####Web服务器的工作原理可以简单地归纳为：

- 客户机通过TCP/IP协议建立到服务器的TCP连接
- 客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档
- 服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端
- 客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果
- 一个简单的HTTP事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。
#####URL和DNS解析
我们浏览网页都是通过URL访问的，那么URL到底是怎么样的呢？
URL(Uniform Resource Locator)是“统一资源定位符”的英文缩写，用于描述一个网络上的资源, 基本格式如下
<pre>
scheme://host[:port#]/path/.../[?query-string][#anchor]
scheme         指定低层使用的协议(例如：http, https, ftp)
host           HTTP服务器的IP地址或者域名
port#          HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/
path           访问资源的路径
query-string   发送给http服务器的数据
anchor         锚
</pre>
DNS(Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它从事将主机名或域名转换为实际IP地址的工作。DNS就是这样的一位“翻译官”.
更详细的DNS解析的过程如下，这个过程有助于我们理解DNS的工作模式

- 在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

- 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。

- 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

- 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。

- 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。

- 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。
####HTTP协议详解
HTTP协议是Web工作的核心，所以要了解清楚Web的工作方式就需要详细的了解清楚HTTP是怎么样工作的。

HTTP是一种让Web服务器与浏览器(客户端)通过Internet发送与接收数据的协议,它建立在TCP协议之上，一般采用TCP的80端口。它是一个请求、响应协议--客户端发出一个请求，服务器响应这个请求。在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的HTTP连接。

HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web程序引入了Cookie机制来维护连接的可持续状态。
####HTTP请求包（浏览器信息）
我们先来看看Request包的结构, Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。header和body之间有个空行，请求包的例子所示:
<pre>
GET /domains/example/ HTTP/1.1      //请求行: 请求方法 请求URI HTTP协议/协议版本
Host：www.iana.org             //服务端的主机名
User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4            //浏览器信息
Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    //客户端能接收的mine
Accept-Encoding：gzip,deflate,sdch     //是否支持流压缩
Accept-Charset：UTF-8,*;q=0.5      //客户端字符编码集
//空行,用于分割请求头和消息体
//消息体,请求资源参数,例如POST传递的参数
</pre>
HTTP协议定义了很多与服务器交互的请求方法，最基本的有4种，分别是GET,POST,PUT,DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。
####HTTP响应包（服务器信息）
我们再来看看HTTP的response包，他的结构如下：
<pre>
HTTP/1.1 200 OK                     //状态行
Server: nginx/1.0.8                 //服务器使用的WEB软件名及版本
Date:Date: Tue, 30 Oct 2012 04:14:25 GMT        //发送时间
Content-Type: text/html             //服务器发送信息的类型
Transfer-Encoding: chunked          //表示发送HTTP包是分段发的
Connection: keep-alive              //保持连接状态
Content-Length: 90                  //主体内容长度
//空行 用来分割消息头和主体
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"... //消息体
</pre>
Response包中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response。HTTP/1.1协议中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别:

- 1XX 提示信息 - 表示请求已被成功接收，继续处理
- 2XX 成功 - 表示请求已被成功接收，理解，接受
- 3XX 重定向 - 要完成请求必须进行更进一步的处理
- 4XX 客户端错误 - 请求有语法错误或请求无法实现
- 5XX 服务器端错误 - 服务器未能实现合法的请求
####HTTP协议是无状态的和Connection: keep-alive的区别
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。

HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。

从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。

Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间。

###CGI(Common Gateway Interface)通用网关接口
CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。<br>
组成CGI通信系统的是两部分：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。<br>
服务器和客户端之间的通信，是客户端的浏览器和服务器端的http服务器之间的HTTP通信，我们只需要知道浏览器请求执行服务器上哪个CGI程序就可以了，其他不必深究细节，因为这些过程不需要程序员去操作。<br>
服务器和CGI程序之间的通讯才是我们关注的。一般情况下，服务器和CGI程序之间是通过标准输入输出来进行数据传递的，而这个过程需要环境变量的协作方可实现。<br>
1.    服务器将URL指向一个应用程序
2.    服务器为应用程序执行做准备
3.    应用程序执行，读取标准输入和有关环境变量
4.    应用程序进行标准输出
<strong>
环境变量在CGI中有着重要的地位！每个CGI程序只能处理一个用户请求，所以在激活一个CGI程序进程时也创建了属于该进程的环境变量。
</strong>
二．环境变量
1. 对于CGI程序来说，它继承了系统的环境变量。CGI环境变量在CGI程序启动时初始化，在结束时销毁。
2. 当一个CGI程序不是被HTTP服务器调用时，它的环境变量几乎是系统环境变量的复制。
当这个CGI程序被HTTP服务器调用时，它的环境变量就会多了以下关于HTTP服务器、客户端、CGI传输过程等项目。
<b>REQUEST_METHOD：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。</b>
2．URL编码
不管是POST还是GET方式，客户端浏览器发送给服务器的数据都不是原始的用户数据，而是经过URL编码的。此时，CGI的环境变量Content_type将被设置，如Content_type = application/x-www-form-urlencode就表示服务器收到的是经过URL编码的包含有HTML表单变量数据。
####HTTP状态码：
表示了请求的结果状态，是CGI程序通过服务器用来通知用户其请求是否成功执行的信息码，本文不做研究。
####CGI中的信号量和文件锁
因为CGI程序时公用的，而WEB服务器都支持多进程运行，因此可能会发生同时有多个用户访问同一个CGI程序的情况。比如，有2个用户几乎同时访问同一个CGI程序，服务器为他们创建了2个CGI程序进程，设为进程A和进程B。假如进程A首先打开了某个文件，然后由于某种原因被挂起（一般是由于操作系统的进程调度）；而就在进程A被挂起的这段时间内，进程B完成了对文件的整个操作流程：打开，写入，关闭；进程A再继续往下执行，但进程A所操作的文件依旧是原来文件的就版本，此时进程A的操作结果将覆盖进程B的操作结果。
为了防止这种情况发生，需要用到文件锁或者信号量。
钥匙文件？
假如有多个不同的HTML可以调用同一个CGI程序，那么CGI程序如何区分它们呢？一个是通过隐含的INPUT标签。不过觉得这个比较麻烦，因为CGI必须经过一系列解码后才能找到这个隐含INPUT的变量和其值。

####五．设置HTTP服务器以兼容CGI
用Perl编写的CGI程序后缀为：.pl；Python编写的CGI程序后缀为：.py；而C编写的CGI程序后缀为：.cgi，如果在win下编译出来的是.exe，最好将它重命名为.cgi。这些都是为了HTTP服务能够识别并调用它们。
####后话
有的人认为可以用JavaScript来代替CGI程序，这其实是一个概念上的错误。JavaScript只能够在客户浏览器中运行，而CGI却是工作在服务器上的。他们所做的工作有一些交集，比如表单数据验证一类的，但是JavaScript是绝对无法取代CGI的。但可以这样说，如果一项工作即能够用JavaScript来做，又可以用CGI来做，那么绝对要使用JavaScript，在执行的速度上，JavaScript比CGI有着先天的优势。只有那些在客户端解决不了的问题，比如和某个远程数据库交互，这时就应该使用CGI了。