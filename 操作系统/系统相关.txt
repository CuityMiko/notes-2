++++++++Linux操作系统初学者的学习线路图++++++++
如果你正在学习Linux操作系统，不知从哪里入手，可以参考下面给出的9点建议.
1.掌握至少50个以上的常用命令。
比如：安装和登录命令：login、 shutdown、 halt、 reboot 、mount、umount 、chsh
文件处理命令：file、 mkdir、 grep、dd、 find、 mv 、ls 、diff、 cat、 ln
系统管理相关命令： df、 top、 free、 quota 、at、 lp、 adduser、 groupadd kill、 crontab、 tar、 unzip、 gunzip 、last
网络操作命令：ifconfig、 ip 、ping 、 netstat 、telnet、 ftp、 route、 rlogin rcp 、finger 、mail 、nslookup
系统安全相关命令： passwd 、su、 umask 、chgrp、 chmod、chown、chattr、sudo、 pswho
2.熟悉Gnome/KDE等X-windows桌面环境操作。
3.掌握.tgz、.rpm等软件包的常用安装方法。
4.学习添加外设，安装设备驱动程序(比如网卡）。
5.熟悉Grub/Lilo引导其及简单的修复操作。
6.熟悉Linux文，件系统和目录结构。 
7.掌握vi、gcc、gdb等常用编辑器，编译器，调试器。
8.理解shell别名、管道、I/O重定向、输入和输出以及shell脚本编程。
9.学习Linux环境下的组网。

 +++++++++++开机顺序+++++++++++
1) BIOS: BIOS是写在主板上的程序，他负责查找硬盘的MBR；
2) MBR: 主引导分区，内包含Boot Loader；
3) Boot Loader: 按用户选择读取操作系统内核程序；
4) Kernel: 内核程序运行，开机；
Tips：安装Windows和Linux双系统，应该先安装Windows再安装Linux，因为先安装Linux，在Windows安装时会覆盖MBR，重写Boot Loader程序，这样会导致Loader无法查找到Linux。而Linux在安装时可以手动选择安装Loader程序的启动扇区，或者设置Loader程序的启动菜单，而不会破坏Windows的loader。当然如果先装了Linux，MBR被覆盖后也可以用其他方式来修复MBR。


++++++unix/linux 基本使用++++++++
ssh 安全增强方法;密码方式和rsa key 方式的配置。
rpm/apt/yum/ports 装包，查询，删除的基本命令。
Makefile的基本格式，gcc 编译，连接的命令,-O0 和-O3区别。
gdb,strace,valgrind的基本使用.
Linux查看当前文件夹下面占用空间最大的文件夹的方法：
du --max-depth=1 -h
iostat命令：
iostat可以显示CPU和I/O系统的负载情况及分区状态信息.
tcpdump命令：
根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。
tcpdump  监视第一个网络接口上所有流过的数据包
tcpdump -i eth1   监视指定网络接口的数据包
tcpdump host 210.27.48.1  截获所有210.27.48.1 的主机收到和发出的所有数据包
tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信
tcpdump ip host 210.27.48.1 and ! 210.27.48.2
  获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包
lsof命令：
是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。
lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。 
常用的参数列表： 
lsof  filename 显示打开指定文件的所有进程
lsof -a 表示两个参数都必须满足时才显示结果
lsof -c string   显示COMMAND列中包含指定字符的进程所有打开的文件
lsof -u username  显示所属user进程打开的文件
lsof -g gid 显示归属gid的进程情况
lsof +d /DIR/ 显示目录下被进程打开的文件
lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长
lsof -d FD 显示指定文件描述符的进程
lsof -n 不将IP转换为hostname，缺省是不加上-n参数
lsof -i 用以显示符合条件的进程情况
Netstat命令：
用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。
-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态
-p 显示建立相关链接的程序名
-r 显示路由信息，路由表
-e 显示扩展信息，例如uid等
-s 按各个协议进行统计
-c 每隔一个固定时间，执行该netstat命令。
提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到


++++Linux重启网卡命令++++
service network restart


++++++linux系统题目+++++++
3. 在你的Linux机器上跟踪系统事件的守护进程名是什么？
答案：’syslogd’，它负责跟踪系统信息，并将跟踪日志存储在特定的日志文件里。
4. 在/root分区运行'fsck'命令的最低要求是什么？
答案：/root分区必须挂载为只读模式，而不是读写模式
7.怎样知道Linux中是谁在安排工作？
答案：使用’at’命令加上’-l’选项，就可以查出。
8. 如何在不解压tar包的前提下，查看包里的内容？
答案：使用’tar -tvf’。选项‘t’(显示内容)，‘v’（详细报告tar处理的文件信息），
‘f’（使用档案文件或者设备）。
less 命令
一次只会显示一个页面的文本。往前翻页你需要按 Page Up, 或者 ‘b’。往后翻页你可以
按Page Down, 或者 空格。大写的G会跳转到文本的末尾，1G会跳转到文本的开端。/字符会在文本
内搜索指定字符（例如，如果你输入 /suse ，它会找寻所有文本含有的 suse 并标记出来）。
n 会重复执行你的搜索，h会显示所有的选项（h，即帮助的意思）。
python命令
下面的命令生产一个通过HTTP显示文件夹结构树的简单网页，可以通过浏览器在端口8000访问，直到发出中断信号。
# python -m SimpleHTTPServer
4. Ctrl+x+e命令
这个命令对于管理员和开发者非常有用。为了使每天的任务自动化，管理员需要通过输入vi、vim、nano等打开编辑器。
仅仅从命令行快速的敲击“Ctrl-x-e”，就可以在编辑器中开始工作了。
10. tree命令
以树式的格式得到当前文件夹的结构。
11. pstree
这个命令显示当前运行的所有进程及其相关的子进程，输出的是类似‘tree’命令的树状格式。
8. last命令
“last”命令显示的是上次登录用户的历史信息。
7. ss命令
“ss”表示socket统计。这个命令调查socket，显示类似netstat命令的信息。它可以比其他工具显示更多的TCP和状态信息。
23. 命令: man
‘man‘是系统帮助页。Man提供命令所有选项及用法的在线文档。几乎所有的命令都有它们的帮助页，
24. 命令: ps
ps命令给出正在运行的某个进程的状态，每个进程有特定的id成为PID。
26. 命令: whereis
whereis的作用是用来定位命令的二进制文件\资源\或者帮助页.举例来说,获得ls和kill命令的二进制文件/资源以及帮助页:
28. 命令: alias
alias是一个系统自建的shell命令，允许你为名字比较长的或者经常使用的命令指定别名。
我经常用‘ls -l‘命令，它有五个字符（包括空格）。于是我为它创建了一个别名‘l’。
29.命令: df
报告系统的磁盘使用情况。在跟踪磁盘使用情况方面对于普通用户和系统管理员都很有用。 
‘df‘ 通过检查目录大小工作，但这一数值仅当文件关闭时才得到更新。
2. host 命令
这个命令可以让您来查看主机的 IP 信息。比如：
$ host google.com
3.  arch 命令
这个命令可以让您得到系统的处理器系统构架信息。
4. uname 命令
上面的 arch 只能得到系统的简单信息，如果想得到更多的信息，我们就需要使用 uname 命令了，uname 命令可以获取到操作系统名称、内核名称、内核版本、主机名、网络节点等信息。
5. dig 命令
dig 命令是 DNS 查看工具，使用此命令可以查看域名服务器的主机地址
$ dig google.com
1、linux下查看ssh用户的登录日志：
less secure
1. 使用pgrep快速查找PID
pgrep会遍历当前运行的进程，列出符合查找条件的进程ID。
pgrep ssh
这条命令会列出所有与ssh有关的进程ID。
2. 执行上次执行过的命令
这个标题有些绕口，但下面这条命令的确能做到这一点。
!!
该命令会执行你在命令行中执行过的上一条命令。
3. 执行最近一次以特定字母开头的命令
如欲执行命令行历史中一个s开头的命令，可以使用如下命令：
!s
该命令会执行最近一次在命令行中用过的且以字母s开头的命令。
4. 反复执行一个命令并在屏幕上输出
watch会反复执行一个命令，并在屏幕上打印输出。你可以借此观察一段时间内程序的输出变化。程序（即示例中的ls -l）默认每2秒运行一次.watch命令与tail命令非常相似。
watch -d ls -l
这条命令会监视当前目录，如有文件增删或修改，就会高亮显示目录变化。
5. 在VI/VIM中快速保存
要忙着办其他事情时，可以使用Shift + zz（即按住换档键，敲两下z键）快速退出vi插入模式。
6. 快速退出终端会话
使用CTRL+D可以快速退出终端会话。
7. 返回上一次所在的目录
使用命令cd -可以返回上一次所在的目录：
8. 巧妙创建父目录
命令mkdir -p /home/adam/make/all/of/these/directories/会根据需要创建不存在的目录。何苦要浪费时间做这种傻事呢：mkdir make ； cd make ； mkdir all ； cd all ； mkdir of ； cd of … 切中要害，使用
mkdir -p!
9. 删除一整行
输入了一长串命令但又不想要了，可以使用CTRL+U删除这一整行。（译注：光标不在行尾时，可以先用CTRL+E定位到行尾。）
10. 设定文件的时间戳
命令touch -c -t 0801010800 filename.c会将文件的时间戳设定为2008-01-01 8:00，格式为(YYMMDDhhmm)。


+++++Linux 的启动流程+++++++
第一阶段：BIOS启动引导阶段
在该过程中实现硬件的初始化以及查找启动介质
从MBR中装载启动引导管理器（GRUB）并运行该启动引导管理
第二阶段：GRUB启动引导阶段
装载stage1
装载stage1.5
装载stage2
读取/boot/grub.conf文件并显示启动菜单
装载所选的kernel和initrd文件到内存中
第三阶段：内核阶段
运行内核启动参数
解压initrd文件并挂载initd文件系统，装载必须的驱动
挂载根文件系统
第四阶段：Sys V init初始化阶段
启动/sbin/init程序
运行rc.sysinit脚本，设置系统环境，启动swap分区，检查和挂载文件系统
读取/etc/inittab文件，运行在/et/rc.d/rc<#>.d中定义的不同运行级别的服务初始化脚本
打开字符终端1-6号控制台/打开图形显示管理的7号控制台
启动流程和细节详解
　　BIOS ==> bootloader ==> kernel & initrd.img ==> /sbin/init
　　1.bootloader （grub）
　　/boot/grub/grub.conf  <– grub的配置文件，决定使用哪个kernel和initrd.img
　　在/boot/grub目录中有两个stage文件，其中：
　　　　stage1  <— 大小是512字节，这个文件会被写进MBR中
　　　　stage2  <— stage1被引导之后，会调用这个文件
　　如果grub出现问题可能会有两种情况：
　　a.无法进入grub，屏幕左上角只出现一个光标。出现这种情况基本上MBR已经被破坏，需要进入rescue模式进行修复。
　　–> chroot环境，执行 “grub-install /boot所在分区” 进行修复
　　–> 无grub相关命令时，安装grub.rpm包进行恢复
　　–> /boot目录下无相关的vmlinuz和initrd.img文件时，安装kernel.rpm包进行修复
　　–> 无grub.conf时需要手工修复
　　b.grub成功加载，屏幕出现“grub>”，表示配置文件grub.conf找不到。
　　–> 手工修复
　　2.kernel & initrd.img
　　在加载vmlinuz和initrd时出现：kernel panic情况，基本是grub.conf设置参数出问题。
　　　　–> 检查grub.conf编写是否出现问题
　　　　–> 也有可能是分区设置或者硬盘损坏等问题，需要进入rescue模式检查
　　3./sbin/init
　　/sbin/init的配置文件是/etc/inittab
　　按照这个配置文件，系统会依次执行以下脚本：
　　　　—> /etc/rc.d/rc.sysinit
　　定义hostname,重新挂载各分区，加载各模块
　　　　—> /etc/rc.d/rc[0-6].d/目录下以S开头的脚本
　　启动各runlevel的服务
　　　　—> mingetty /dev/tty[1-6]
　　启用终端

 
++++16个Linux服务器监控命令+++++
iostat
iostat 命令用来显示存储子系统的详细信息，通常用它来监控磁盘 I/O 的情况。要特别注意 iostat 统计结果中的 %iowait 值，太大了表明你的系统存储子系统性能低下。
meminfo 和 free
Meminfo 可让你获取内存的详细信息，你可以使用 cat 和 grep 命令来显示 meminfo 信息。另外你可以使用 free 命令来显示动态的内存使用信息，free 只是给你大概的内存信息，而 meminfo 提供的信息更加详细。
mpstat
mpstat mpstat是MultiProcessor Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，
这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。
netstat
Netstat 和 ps 命令类似，是 Linux 管理员基本上每天都会用的工具，它显示了大量跟网络相关的信息。
nmon
Nmon, 是 Nigel’s Monitor 的缩写，是一个使用很普遍的开源工具，用以监控 Linux 系统的性能。Nmon 监控多个子系统的性能数据，
例如处理器的使用率、内存使用率、队列、磁盘I/O统计、网络I/O统计、内存页处理和进程信息。
要运行 nmon，你可以在命令行中启动它，然后选择要监控的子系统，这些子系统都对应有一个快捷键，例如输入 c 可查看 CPU 信息，m用于
查看内存，d用来查看磁盘信息等，你也可以使用 -f 命令将 nmon 的执行结果保存到一个 CSV 文件中，便于日后分析。
pmap
pmap 命令用来报告每个进程占用内存的详细情况，可用来看是否有进程超支了，该命令需要进程 id 作为参数。
ps 和 pstree
ps 和 pstree 命令是 Linux 系统管理员最好的朋友，都可以用来列表正在运行的所有进程。ps 告诉你每个进程占用的内存和 CPU 处理时间，
而 pstree 显示的信息没那么详细，但它以树形结构显示进程之间的依赖关系，包括子进程信息。一旦发现某个进程有问题，你可以使用 kill 来杀掉它。
sar
sar 程序是系统监控工具里的瑞士军刀。该程序包含三个工具：sar 用来显示数据，sa1 和 sa2 用来收集数据并保存。sar 可用来显示 CPU 使用率、内存页数据、
网络 I/O 和传输统计、进程创建活动和磁盘设备的活动详情。sar 和 nmon 最大的不同就是 sar 跟适合用作长期的监控，而 nmon 可以让你快速的了解系统当前状态。
strace
strace 经常被认为是程序员调试的工具，但不止如此。它可以记录进程进行系统调用的详情，因此它也是一个非常好的诊断工具，例如你可以使用它来找出某个程序正在打开某个配置文件。
Strace 也有一个缺陷，但它在跟踪某个进程时会让该进程的性能变得非常差，因此请谨慎使用。
tcpdump
Tcpdump 是一个简单、可靠的网络监控工具，用来做基本的协议分析，看看那些进程在使用网络以及如何使用网络。当然，如果你要获取跟详细的信息，你应该使用 Wireshark .
top
top 命令显示当前的活动进程，默认它是按消耗 CPU 的厉害程度进行排序，每5秒钟刷新一次列表，你也可以选择不同的排序方式，例如 m 是按内存占用方式进行排序的快捷键。
uptime
uptime 命令告诉你这台服务器从开机启动到现在已经运行了多长时间了。同时也包含了从启动到现在服务器的平均负载情况。
vmstat
你可以使用 vmstat 来监控虚拟内存，一般 Linux 上的开发者喜欢使用虚拟内存来获得最佳的存储性能。该命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。
由 vmstat 命令生成的报告可以用于平衡系统负载活动。系统范围内的这些统计信息（所有的处理器中）都计算出以百分比表示的平均值，或者计算其总和。
Wireshark
Wireshark, 前身是 Ethereal ，是一个网络协议检测程序，让您经由程序抓取运行的网站的相关资讯，包括每一封包流向及其内容、资讯可依操作系统语系看出,方便查看、监控TCP session动态等等.


+++++让Linux主机开启.htaccess支持++++++
国内的很多Linux型主机默认是不开启.htaccess的，从而导致不支持伪静态。而国外的虚拟主机基本上都是支持此服务的，我曾经问过国内的主机提供商
为何不开启.htaccess服务，他们的回答很可笑，说是减轻服务器的负担，呵，这真是符合了中国的国情，真让你不知以何种语言反击之。
这里给一些菜鸟扫扫盲，很多站长都单纯的以为.htaccess就是伪静态，把.htaccess当成伪静态的代名词，以为.htaccess就起到.htaccess的作用，其实它的作用比你想象的大得多，
除了伪静态，还有我们熟知的404啊、301跳转啊等，都可以通过.htaccess来实现，下面来给大家介绍一下如何在Linux型主机下开启.htaccess的支持，前提你有这个权限，
一般这个针对的是服务器或者VPS，虚拟主机基本上是没门，除非你要求提供商帮你开启。另一种情况是有些童鞋在本地搭建PHP+MySQL+Apache的时候用得着此方法，
本地的一键安装包有xampp和phpnow等，我个人推荐使用phpnow，简单易用，完全傻瓜式。如果你使用phpnow搭建的话你就不用往下看了，因为默认是开启的。
方法如下：
第一：在Apache文件夹下的conf文件夹中找到httpd.conf，记事本或者类似的编辑工具打开后Ctrl+F查找“LoadModule rewrite_module”，
找到“LoadModule rewrite_module modules/mod_rewrite.so”所在的那一行，确定这一行前面没有#，就说明已经加载了伪静态模块，假如这一行前面有#，请去掉，phpnow安装后默认是没有#的。
第二：让Apache服务器支持.htaccess，如何让自己的本地Apache服务器支持”.htaccess”呢?其实只要简单修改一下apache的httpd.conf设置
就可以让支持.htaccess了。打开httpd.conf文件，用文本编辑器打开后,查找
Options FollowSymLinks
AllowOverride None
改为
Options FollowSymLinks
AllowOverride All
第一是确定是否已经加载了伪静态模块，第二是修改这一处的设置。操作完后测试一下.htaccess是否已生效，如还未生效，请重启Apache服务。


++++.htaccess屏蔽搜索引擎蜘蛛+++++
.htaccess也可以屏蔽搜索引擎蜘蛛了，这和修改robots.txt不同，这属于牛逼级别的屏蔽，
并且不会轻易被人发现。
RewriteEngine On 
RewriteCond %{HTTP_USER_AGENT} (baiduspider|googlebot|soso|bing|sogou|yahoo|sohu-search|yodao|robozilla|msnbot) [NC] 
RewriteRule ^(.*)$ http://www.zoneself.org/ [R=301,L]



++++++DNS,A记录,子域名,CNAME别名,MX记录,TXT记录,SRV 记录,TTL值,泛域名(泛解析),域名转向,域名绑定++++++++
DNS
DNS，Domain Name System或者Domain Name Service（域名系统或者域名服务）。域名系统为Internet上的主机分配域名地址和IP地址。由于网络中的计算机都必须有个IP地址，
来识别,互相之间才能通信,但让我们记住一大串的IP地址来访问网站显然是不可能的,所以用户使用域名地址，而DNS系统的功能就是自动把域名地址翻译为IP地址。域名服务是运行域名
系统的Internet工具。执行域名服务的服务器称之为DNS服务器，通过DNS服务器来应答域名服务的查询。
1、DNS就是域名服务器，他的任务就是确定域名的解析，比如A记录MX记录等等。2、任何域名都至少有一个DNS，一般是2个。但为什么要2个以上呢？因为DNS可以轮回处理，这样第一个解析失败可以找第二个。这样只要有一个DNS解析正常，就不会影响域名的
正常使用。
3、如何确定域名的DNS
很简单到[url]www.internic.net/whois.html[/url]输入你要查询的域名就可以看到了。这个是国际域名管理中心。唯一的权威。只要这里能查到某个域名，就表示域名是生效的。它说你
什么时候到期，就是什么时候到期。
4、有效的DNS表示当前正在起作用的DNS服务器是谁，比如查询结果是NS.XINNETDNS.COM、NS.XINNET.CN(新网信海)就表示当前域名是由NS.XINNETDNS.COM、NS.XINNET.CN(新网信海
)负责解析。其他未显示的DNS的设置，都是无效的。
5、DNS是可以修改的。修改以后需要24-72小时以后，全世界范围的所有DNS服务器才能刷新过来。internic的信息一般在24小时以后可以看到。另外，修改的过程，并不表示域名会
停止解析，只要你在2边都做好了解析。如果生效了就是新的DNS在起作用。如果没生效。就是旧的DNS在起作用。要么生效，要么不生效。不存在2个都不起作用的时间。所以域名解析，不会
中断。前提是两边都做了解析。
A记录
A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的子域名。通俗来说A记录就
是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器
子域名。
子域名道理等同二级域名，不过比二级域名更加延伸，比如我们继续扩展该域名的主机名，设置主机名为bbs.at,那么就可以建立一个三级域名：bbs.at.abc.com，当然也可以建立四级
域名bbs.at.go.abc.com，五级域名bbs.at.go.home.abc.com……，依次类推，可以建立无限级别的域名，我们统称这些域名为顶级域名abc.com的子域名。
CNAME别名指向记录
NAME (Canonical Name)记录，通常称别名指向。在这里，您可以定义一个主机别名，比如设置ftp.***.com，用来指向一个主机www.***.com,那么以后就可以用FTP.***.com来代替
访问www.***.com了。
MX记录
MX记录也叫做邮件路由记录，用户可以将该域名下的邮件服务器指向到自己的mail server上，然后即可自行操控所有的邮箱设置。您只需在线填写您服务器的IP地址，即可将您域名
下的邮件全部转到您自己设定相应的邮件服务器上。
简单的说，通过操作MX记录，您才可以得到以您域名结尾的邮局。
TXT 记录
TXT 记录，一般指为某个主机名或域名设置的说明，如：
admin IN TXT “管理员, 电话： 13901234567″
mail IN TXT “邮件主机, 存放在xxx , 管理人：AAA”
Jim IN TXT “contact: abc@mailserver.com”
也就是您可以设置 TXT ，以便使别人联系到您
SRV 记录
SRV 记录：一般是为Microsoft的活动目录设置时的应用。DNS可以独立于活动目录，但是活动目录必须有DNS的帮助才能工作。为了活动目录能够正常的工作，DNS服务器必须支持服务
定位（SRV）资源记录，资源记录把服务名字映射为提供服务的服务器名字。活动目录客户和域控制器使用SRV资源记录决定域控制器的IP地址。
TTL值
TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。要理解TTL值，请先看下面的一个例子：
假设，有这样一个域名myhost.abc.com（其实，这就是一条DNS记录，通常表示在abc.com域中有一台名为myhost的主机）对应IP地址为1.1.1.1，它的TTL为10分钟。这个域名或称这条记录存储
在一台名为dns.abc.com的DNS服务器上。
现在有一个用户在浏览器中键入一下地址（又称URL）：[url]http://myhost.abc.com[/url] 这时会发生什么呢？
该访问者指定的DNS服务器（或是他的ISP,互联网服务商, 动态分配给他的)8.8.8.8就会试图为他解释myhost.abc.com，当然8.8.8.8这台DNS服务器由于没有包含myhost.abc.com这条信息，
因此无法立即解析，但是通过全球DNS的递归查询后，最终定位到dns.abc.com这台DNS服务器，dns.abc.com这台DNS服务器将myhost.abc.com对应的IP地址1.1.1.1告诉8.8.8.8这台DNS服务器，
然有再由8.8.8.8告诉用户结果。8.8.8.8为了以后加快对myhost.abc.com这条记录的解析，就将刚才的1.1.1.1结果保留一段时间，这就是TTL时间，在这段时间内如果用户又有对myhost.abc.com
这条记录的解析请求，它就直接告诉用户1.1.1.1，当TTL到期则又会重复上面的过程
泛域名与泛解析
泛域名是指在一个域名根下，以 *.Domain.com 的形式表示这个域名根所有未建立的子域名。
泛解析是把*.Domain.com 的A 记录解析到某个IP 地址上,然后别人通过任意的前缀.domain.com访问都能访问到你解析的站点上
    例：
域名根　 name.com 只建立了 [url]www.name.com[/url] 和 name.com 这两个域名记录， 
那么 ftp.name.com mail.name.com bbs.name.com 等域名记录是不存在的，
但为域名根 name.com 建立泛域名记录 *.name.com 后，
*.name.com 就涵盖了 ftp.name.com mail.name.com bbs.name.com 等所有不存在的子域名记录。 
您可以定义 *.name.com 指向一个 IP ，那么当访问者无论是输入 ftp.name.com mail.name.com 或 bbs.name.com 的时候，
访问者都将直接访问您定义 *.name.com 的那个 IP 。
域名绑定
什么是域名绑定
域名绑定是指，域名绑定是指域名和主机(即某个服务器)的空间进行关联绑定,其实就是在虚拟服务器上设置或者WEB服务器上设置，使一个域名被引导向服务器上的某一特定空间
（某一个特定站点），访问者访问你的域名的时候就会打开你存放在该空间上的网页，简单来说其实就是把域名解析到服务器IP,然后在服务器上设置该域名有权限访问的过程。一般虚拟主机
有控制面板给进行绑定域名，如果没有面板就需要自己在服务器上的IIS里面设置
域名转向
　　域名转向我们又称为域名(URL)指向或域名转发，当用户地址栏中输入您的域名时，将会自动跳转到您所指定的另一个网络地址（URL）。
　　假设abc.com是您注册的域名，则通过URL转发服务可以实现当用户访问[url]http://www.abc.com[/url]时，自动转向访问另外一个URL，如:我的空间不支持绑定到目录功能,所以为了
方便访问者,我就设置:[url]http://bbs.bnxb.com[/url]来访问,这个是设置了通过URL转发服务转发到[url]http://www.bnxb.com/bbs[/url]上面来实现的，这样您就可以轻松实现多个域名
指向一个网站或网站子目录；另外，通过URL转发服务，可以方便的实现将您的中文域名，设置自动转发到您的英文域名主站点。域名转发的另外一个好处就是可以把长域名压缩,用短域名的
转向代替,让你的访客不需输入那么长的域名
IIS连接数
     IIS连接数指并发连接数，什么意思呢？
     要分几种情况：（以100M空间50人在线为例）
     A 用户单点下载你的文件，结束后正常断开，这些连接是按照瞬间计算的，就是说你50人的网站瞬间可以接受同时50个点下载
     B 用户打开你的页面，就算停留在该页面，这时候网页已经加载完了没有对服务器再发出任何请求，那么在用户完全打开这个页面的时间内算一个在线，在页面完全打开后IIS连接数就释放。
    C 上面B的情况用户继续打开同一个网站的其他页面，那么在线人数按照用户最后一次点击（发出请求）计算，在这个时间内不管用户怎么点击（包括新窗口打开）都还是一人在线。
    D 当你的页面内存在框架(Iframe)，那么每多一个框架就要多一倍的在线！因为这相当于用户同一时间向服务器请求了多个页面。
    E 当用户打开页面然后正常关闭浏览器，用户的在线人数也会马上清除。


++++CMD++++++
查看局域网内所有IP地址和用户名：net view(用户名); arp -a (所有IP);


++++linux命令+++++
diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。
Example:diff log2014.log log2013.log 


++++++++乱入内容++++++++
C++ / Java 和面向对象
我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“C++学习信心图” 和“21天学好C++”
学习（麻省理工免费课程）C++面向对象编程
读我的 “如何学好C++”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《C++虚函数表解析》或是《C++对象内存存局》，或是《C/C++返回内部静态成员的陷阱》那就非常不错了）
然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。
实践任务：
用C++实现一个BigInt，支持128位的整形的加减乘除的操作。
用C++封装一个数据结构的容量，比如hash table。
用C++封装并实现一个智能指针（一定要使用模板）。
《设计模式》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《深入浅出设计模式》）
实践任务：
使用工厂模式实现一个内存池。
使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。
使用命令模式实现一个命令行计算器，并支持undo和redo。
使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。
学习STL的用法和其设计概念  – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。
实践任务：尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能
做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。
做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。
学习C++的一些类库的设计，如： MFC（看看候捷老师的《深入浅出MFC》） ，Boost, ACE,  CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，
如果你能深入到我写的《STL string类的写时拷贝技术》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）
Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看Java中的设计模式）。
推荐阅读《Effective Java》 and 《Java解惑》
学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。
Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。
学习使用Java做Web Service （官方教程在这里）
实践任务： 尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。
C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是：
深究C++（我深究C/C++了十来年了）学习Java的各种设计模式。

+++Rune+++
Rune是“字符”的概念。世界上的所有语言的字符在Unicode编码中已经分配了不同的编码，而且也有不同的字节长度。英语是1个字节长度，中文是3个字节长度。在plan9中不是使用char来表示字符，是使用rune来表示字符。字符是使用单引号来进行表示，比如"你"和'你'这两个是代表不同的含义，单引号的是你这个中文字符，双引号代表将你这个中文字符当作三个UTF-8的字符串。
Buffer IO
操作系统的文件操作有两种：buffer IO和非buffer IO。buffer IO就是读取文件前都先将文件读取到内存中，然后从内存再输出或者从输入到内存中。由于内存的读写速度比磁盘快，所以Buffer IO是比非buffer IO快，但是有的不足是有可能会掉数据，这个也是由于内存中的数据是非持久化的。
标准的C库中是没有buffer IO的，于是plan9就有了一个<bio.h>专门负责buffer IO的功能。


+++线程安全++++
线程安全就是说多线程访问同一代码，不会产生不确定的结果。编写线程安全的代码是低依靠线程同步。
线程安全一般都涉及到synchronized 就是一段代码同时只能有一个线程来操作 不然中间过程可能会产生不可预制的结果。
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程
运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。


+++http长轮询与短轮询+++
http 协议介绍：
http 协议是请求/响应范式的, 每一个 http 响应都是由一个对应的 http 请求产生的; http 协议是无状态的, 多个 http 请求之间是没有关系的.
http 长连接：
目前 http 协议普遍使用的是 1.1 版本, 之前有个 1.0 版本, 两者之间的一个区别是 1.1 支持 http 长连接, 或者叫持久连接.1.0 不支持 http 长连接, 每次一个 http 请求响应后都关闭 tcp 连接, 下个 http 请求会重新建立 tcp 连接.
所谓 http 长连接, 就是多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp 建立关闭所产生的时间消耗. http 1.1 中在请求头和相应头中用 connection字段标识是否是 http 长连接, connection: keep-alive, 表明是 http 长连接; connection:closed, 表明服务器关闭 tcp 连接
与 connection 对应的一个字段是 keep-live, http 响应头中出现, 他的格式是 timeout=30, max=5, timeout 是两次 http 请求保持的时间(s), , max 是这个 tcp 连接最多为几个 http 请求重用
http 长轮询：
http 长轮询是服务器收到请求后如果有数据, 立刻响应请求; 如果没有数据就会 hold 一段时间, 这段时间内如果有数据立刻响应请求; 如果时间到了还没有数据, 则响应 http 请求;浏览器受到 http 响应后立在发送一个同样 http 请求查询是否有数据;
http 长轮询的局限:
浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询;
服务器端没有数据 hold 住连接时会造成浪费, 容易产生服务器瓶颈;
http 短轮询：
http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求; 浏览器受到 http 响应隔一段时间在发送同样的 http 请求查询是否有数据;
http 短轮询的局限是实时性低;
两者相同点：
可以看出 http 长轮询和 http 短轮询的都会 hold 一段时间;
两者不同点
间隔发生在服务端还是浏览器端: http 长轮询在务端会 hold 一段时间, http 短轮询在浏览器端 “hold” 一段时间;
应用：
长轮询一般用在 web im, im 实时性要求高, http 长轮询的控制权一直在服务器端, 而数据是在服务器端的, 因此实时性高;
像新浪微薄的im, 朋友网的 im 以及 webQQ 都是用 http 长轮询实现的;
NodeJS 的异步机制貌似可以很好的处理 http 长轮询导致的服务器瓶颈问题, 这个有待研究.
http 短轮询一般用在实时性要求不高的地方, 比如新浪微薄的未读条数查询就是浏览器端每隔一段时间查询的.
其他：
关于 http 长连接一个误解就是服务器主动推送数据, 这个在 http 协议下是无法实现的, 因为 http 请求/响应范式决定的, http 中服务器返回数据必须要有一个浏览器端的请求对应, 服务器无法主动推送给浏览器数据.
不管 http 长轮询还是 http 短轮询 保证同一个用户在多 tab 下只存在一个定时查询是有好处的, 这可以通过在浏览器端缓存数据解决, 在 http 响应后在浏览器端缓存数据, 并设置一个有效期, 然后在每次发送 http 请求时检查是否有有效数据, 没有则发送请求获取


+++linux编辑文件遇到只读文件时候的处理方式++++
保存的时候会提示：没有Root Permission 
可以用如下方法解决：
保存时加上：
:w !sudo tee %


+++linux 常用命令++++
whoami 查看当前用户
df 显示系统的硬件信息
pwd 显示当前路径
cat more less 都可以查看一个或者多个文档，区别是cat可以将多个文件合
tac filename 从最后一行开始反向查看名叫filename的文内容并在一起看，
cat -n 1.txt显示1.txt文件并且前面显示行号而more与less不能合并成一个文件查看.
od 1.txt 二进制形式显示文件1.txt
mkdir /home/test 创建文件夹 /home/test
chown oracle /home/test 表示改变目录所有者为oracle账户
chgrp dba /home/test 改变/home/test目录为dba所有
rmdir /home/test 删除home/test目录
hostname查看linux的计算机名
su - 切换为root最高管理员账户
su 账户名 切换为指定账户
rm -f filename 删除一个叫filename的文件
rmdir testdir 删除一个叫testdir的目录
mv dir1 new_dir 移动/重命名一个目录
cp file1 file2 复制一个文件
cp -a /tmp/dir1 复制/tmp/dir1下面所有文件到当前工作目录
cp -a dir1 dir2 复制一个目录到dir2目录
find / -name 1.txt 进入根文件系统搜索叫1.txt的文件和目录
find / -user dongjun 搜索属于用户dongjun的所有文件与目录
find /hone/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 
find /new/ -type f -mtime -10 搜索在10天内/new/目录下被创建或者修改过的文件
groupadd group_name 创建一个新用户组 
groupdel group_name 删除一个用户组 
useradd dj 创建一个新用户dj
userdel -r dj 删除一个用户dj (这里必须有-r ,目的是排除主目录)
passwd 修改当前账号的密码
passwd user1 修改名字为user1用户的密码（只有当前用户是root才有效）
ls -lh 显示带有权限的文件
head -2 file1 查看一个文件的前两行 
tail -1 file1 查看一个文件的最后一行
grep llo 1.txt 在1.txt文件中查找关键字 llo
grep ^llo 1.txt在1.txt文件中查找以llo开头的单词
grep [0-9] 1.txt 在1.txt文件中查找所有包含数字的行
grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串"Aug" 
paste file1 file2合并两个文件的内容
sort file1 file2 排序两个文件的内容
comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容 
comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容 
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 
ps aux 列出系统进程
whereis filename 显示文件filename的所在位置
runlevel查看现在的运行级别
free显示内存CPU的使用情况
top动态观察进程
id 用来查看账户的信息
dmesg显示启动信息
source /etc/profile  刷新配置环境信息
查看linux内核版本3种方法：
cat /proc/version      uname -a         uname -r 
查看linux版本，列出所有版本信息：
lsb_release -a     cat /etc/issue
查看系统是64位还是32位:
getconf LONG_BIT      
主库 增删改-MyISAM
query_cache_size = 512M
#指定单个查询能够使用的缓冲区大小，缺省为1M
query_cache_limit = 2M
查看无法删除的文件，被占资源 
lsof |grep deleted  


+++Linux必备的内核知识+++++

用户模式和内核模式
执行进程的模式有两种：用户模式和内核模式。你编写的代码和执行所链接的库运行在用户模式下。需要内核服务时执行的内核代码只能在内核模式下运行。这是为了安全性考虑，用户模式可以确保一个进程只能访问自己的内存空间，如果破坏了自己内部结构，它也只能影响到自己，而不涉及其它的进程，更不会影响到整个系统。在用户模式下，进程能访问的内存称为用户空间。

内核需要维护数据结构以控制系统中每个进程，它提供了一个所有进程共享的内存区域，为了保证安全性，内核代码和数据结构必须严格独立于用户代码和数据，只有内存代码可以在内核模式下运行，访问的共享内核数据以及执行权限指令。把进程在内核模式下访问的内存区域叫做内核空间。内核空间只有一个，在内核模式下的进程才能访问，但是内核空间是每个进程所特有的。

典型的32环境下的虚拟地址（3G/1G分配方式）：

0xFFFFFFFF

Linux内核               内核空间（内存1G）

0xC0000000

0xBFFFFFFFF

进程A|B|C              用户空间（内存3G）

0x00000000

系统调用
       进程通过系统调用进入和退出内核模式，许多POSIX函数是系统调用的简单封装，如open，close，ictol，write和read等。驱动设备只能在内核模式下执行，应用程序不能直接调用设备驱动程序，而是使用预定义的系统调用间接的访问驱动程序代码。

       下面是系统调用read的一个例子：

#include <syscall.h>

….

n = syscall(SYS_read, fd, buffer, length)

       Linux提供的系统调用列表由内核版本决定，并且不随时间变化而变化。然而，用于创建系统调用的机制却会因为不同处理器体系结构而不同。系统调用函数是一个用于创建系统调用的汇编代码的封装。命令strace对于追踪系统调用非常有用，因为利用它可以知道当前任务执行的情况。

通常用户代码先将参数压入堆栈或者保存在预定义的寄存器中，然后在使用中断调用系统调用处理器。中断处理器将进程转入到内核模式，并调用适当的系统调用。在内核模式下，它从寄存器中读取参数或使用特定的函数从用户空间复制参数。可移植程序不能直接使用系统调用，而是依赖库为其实现系统调用。系统调用随着操作系统版本变化而变化，库的调用则无需这些变化。

Linux使用syscall技术称为应用程序二进制接口(ABI)，它并不是Linux所独有的。该技术可以用于其它操作系统，甚至是BOIS系统。它与API是不同的，API要求链接兼容的函数，而ABI步要求链接步需要运行的代码。这是可执行程序无需重建就可以在许多不同内核中运行的原因之一。一个运行在2.2内核下的静态链接的可执行程序可能在2.6内核下仍然可以运行，因为大多数常见的系统调用接口从不会变化。

用户空间和内核空间的数据传递
用户模式下的内核空间是不可见的，当访问用户空间时，内核模式也必须格外注意。因此，通过系统调用传送数据非常的麻烦。虽然简单的参数可以通过寄存器传递，但是大型的内存必须通过复制，导致效率相当的低下。一些系统调用（read/write）需要在用户模式和内核模式之间传递大量数据，虽然这些额外的复制作用不大，但是它能维持内核空间和用户空间的相对独立。

虽然复制在短期看来会降低程序的性能，但从长远来看它有助于性能的提高，例如文件系统高速缓存，当数据写入文件时，数据被写入磁盘之前会先写入到内核空间，所以write这个动作可以在后台完成，应用程序可以通过flush来刷新用户空间的缓冲，使得程序继续执行。

进程调度程序
解决多任务操作系统问题的算法叫做程序调度（Scheduler），Linux内核提供多种调度算法，并且允许用户在系统安装时选择合适的调度算法。

调度程序的调用通常嵌入到系统调用中，并在进程需要等待事件时发生。一个与设备进行大量通信的进程会经常调用调度程序，由于设备的速度很慢，进程的大部分运行时间都浪费在等待过程中，这样运行时不会耗费太多的CPU时间。

注：何为协同多任务处理（Cooperativer multitasking）。

一个进程若不进行I/O，那就会占用大量的CPU时间，从而使得其它进程无法使用CPU，此时需要采用抢占式任务处理（Preemptive multitasking）。

每个Linux进程都有一个执行时间片或quantum，当一个进程因为时间片使用完被内核停止执行时，这个进程被抢占，如果有一个享有更高优先级的进程在就绪队列中，内核同样可以抢占正在执行的进程。一个进程也可以自动放弃CPU，可以通过sched_yield系统调用来放弃CPU。也可以通过其它系统调用（sleep）来实现对CPU的放弃。当进程在内核模式下等待一个事件时，称为阻塞（blocking）。一个阻塞进程既不会占用CPU，也不会被调度程序使用。

所有抢占式多任务处理操作系统都实现了按优先级调度策略。高优先权的进程总是比低优先级的进程先被调度。虽然用户可以影响进程的优先级，但进程的优先级最终还是由内核决定。Linux内核通过使用动态优先级（Dynamic Priority），不断提高和降低正在运行进程的优先级，从而使得低优先级的进程也能运行。

Linux内核调度策略一个重要目的是保证所有进程都有机会被调度，也就是说每个任务都有相应的使用CPU的时间。进程的有效优先级就是静态优先级和额外值之和，这个额外值可正可负。

ps命令选项中-C显示进程与参数的配对项，如-C <proc_name>，-o用于控制输出的格式，如etime,pid,pri,cmd。

内核允许用户通过使用一个名为nice的数值来影响调度程序关于优先级的调度。正的nice可以降低优先级，负的nice可以提高优先级。请查看ice和renice命令。

实时优先权
响应时间是指软件响应外部事件的时间，比如中断。严格的响应时间的应用程序通常被称为实时应用程序。Linux中实时进程的优先级范围是41-139，实时优先级越大，优先级越高。实时优先级在整个生命周期中值是不变的。

在设计实时进程时，必须确定它的调度策略，POSIX为实时进程指定了两种策略：先进先出（FIFO）和时间片法（round robin）。

创建实时进程的方法就是使用chrt命令，chrt在内部调用fork和exec和POSIX函数来设置优先级，函数如下：

int sched_setscheduler(pid_t pid, int policy, const struct sched_param*p);

int pthread_setschedparam(pthread_t thread, int policy, const struct sched_param*p);

int sched_get_priority_min/max(int policy)；

第一个为进程服务，第二个为线程服务。

# sodu chrt --fifo 50 ./chewer &

进程状态
在进程的生命周期中，进程经历几种不同的状态，使用ps命令或cat /proc文件系统查看，进程状态如下：

R-运行或将要运行

S-被中断等待一个事件，可能会被一个信号激活

D-被中断等待一个事件，不会被信号激活

T-由于任务的控制或者外部追踪而被终止，比如ptrace

Z-僵死，但是它的父进程没有调用wait函数。

一个进程处于不可中断状态是一件危险的事情，只能重启计算机来修补。

当一个进程退出时并不完全小时，而是等到父进程发出wait系统调用才会完全消失，否则一直会处于僵死状态，等待它的父进程终止它。僵死进程步占用内存和进程资源，但是可以铜鼓ps命令显示出来，它被init收养（adopted），init进程会定期的调用wait命令来回收这些未被撤销的进程。

内核能追踪每个进程的运行时间，内核记录每个进程分别用在用户空间和内核空间的时间，命令time很有用。如果进程在用户空间耗费太多时间，就不能抱怨内核。造成这样的结果可能是代码或者连接的库函数问题，而不是内核的原因。用strace来跟踪为何会在系统调用上耗费太多的时间的问题。如果代码因为设备阻塞或者系统调用而运行太慢，几乎没有什么方法可以提高代码的运行速度，最好避免做那些调用，也可以试一试对应用程序采用线程方法或者异步I/O操作。

Linux内核时钟标准单位为jiffy，内部时钟有硬件计数器以一定频率产生中断得到，这个频率在内核编译时已经确定，它存储在HZ的宏中。中断频率的提高会增加CPU的使用，加快消耗电池的电量速度。可以使用make memuconfig进行时间频率设置。

使用sysfs的示例：一个用于追踪内部时钟的小模块。

Hz.c：

#include "linux/module.h"

 

int user_hz = USER_HZ;

int hz = HZ;

 

module_param(user_hz, int, 0444);

module_param(hz, int, 0444);

 

Makefile:

all:

        make -C /lib/modules/`uname -r`/build M=`pwd` modules

obj-m+=hz.o

编译、安装和查看：

# make

# insmod hz.ko

# cat /sys/module/hz/parameters/user_hz

# cat /sys/module/hz/parameters/hz

 

Intel的物理地址扩展（PAE）
在电脑上安装的RAM数量不受限制，只是受制于主板上的DIMM数量，处理器可以选址的物理内存数量受限。通常，CPU的字长决定了这个限制，一个32为机器只能存储32位的指针，因此物理地址限制为4GB。


当需要增加DRAM大于4GB的解决办法是转换为64位体系结构，这意味着你的所有应用程序放到一个新的平台上，这是个相当高的解决方案。

Intel公司的Physical Address Extension（PAE）技术允许处理器通过页面地址从20bit扩展到24bit，从而可以寻址64GB的RAM，页面大小可以改变，所以偏移量仍然为12bit，这意味着有效物理地址为36bits。因为逻辑地址必须符合32为寄存器，处理器仍然只能选址4GB的虚拟内存。

MMU和操作系统使用页面地址管理页面，所以分配给缓存或者进程页面时候，操作系统可以随意使用24bits的页面地址，因此，系统可以用的虚拟内存是有效的64GB。

注：pmap命令查看内存分配，# jobs -x pmap %1

内核调试工具：

# mkswap, swapon, swapoff – 用于分区交换的工具

# nice，renice，chrt – 用于影响调度行为的工具

# pmap – 用于显示进程虚拟内存的工具

# ps，time，times – 用于显示进程在用户态和内核态的花费时间

# strace – 用于分析程序进行系统调用行为的一种绝佳工具

内核调试API:

# clock_getres, clock_gettime – 高分辨率的POSIX时钟

# getrusage,times – 查看资源使用情况的库函数

# mallopt – 属于GNU的API，用于设置动态分配内存行为

# mlock, munlock – 用于在ram总锁定页

# mmap, msync, madvise – 内存在RAM和磁盘上如何释放

# pthread_setschedparam – 为线程选择一个时序安排策略

# sysconf – 显示系统常量的配置细节内容


++++Linux内存管理Slab分配器++++++
一：概述

采用伙伴算法分配内存时，每次至少分配一个页面。但当请求分配的内存大小为几十个字节或几百个字节时应该如何处理？如何在一个页面中分配小的内存区，小内存区的分配所产生的内碎片又如何解决？Linux采用Slab。

Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。例如，如果内存被分配给了一个互斥锁，那么只需在为互斥锁首次分配内存时执行一次互斥锁初始化函数（mutex_init）即可。后续的内存分配不需要执行这个初始化函数，因为从上次释放和调用析构之后，它已经处于所需的状态中了

Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。

图 1 给出了 slab 结构的高层组织结构。在最高层是 cache_chain，这是一个 slab 缓存的链接列表。这对于 best-fit 算法非常有用，可以用来查找最适合所需要的分配大小的缓存（遍历列表）。cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。
每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。存在 3 种 slab：

slabs_full：完全分配的 slab

slabs_partial：部分分配的 slab

slabs_free：空 slab，或者没有对象被分配

注意 slabs_free 列表中的 slab 是进行回收（reaping）的主要备选对象。正是通过此过程，slab 所使用的内存被返回给操作系统供其他用户使用。

slab 列表中的每个 slab 都是一个连续的内存块（一个或多个连续页），它们被划分成一个个对象。这些对象是从特定缓存中进行分配和释放的基本元素。注意 slab 是 slab 分配器进行操作的最小分配单位，因此如果需要对 slab 进行扩展，这也就是所扩展的最小值。通常来说，每个 slab 被分配为多个对象。

由于对象是从 slab 中进行分配和释放的，因此单个 slab 可以在 slab 列表之间进行移动。例如，当一个 slab 中的所有对象都被使用完时，就从 slabs_partial 列表中移动到 slabs_full 列表中。当一个 slab 完全被分配并且有对象被释放后，就从 slabs_full 列表中移动到 slabs_partial 列表中。当所有对象都被释放之后，就从 slabs_partial 列表移动到 slabs_free 列表中。
每个Slab的首部都有一个小小的区域是不用的，称为“着色区（coloring area）”。着色区的大小使Slab中的每个对象的起始地址都按高速缓存中的”缓存行（cache line）”大小进行对齐（80386的一级高速缓存行大小为16字节，Pentium为32字节）。因为Slab是由1个页面或多个页面（最多为32）组成，因此，每个Slab都是从一个页面边界开始的，它自然按高速缓存的缓冲行对齐。但是，Slab中的对象大小不确定，设置着色区的目的就是将Slab中第一个对象的起始地址往后推到与缓冲行对齐的位置。因为一个缓冲区中有多个Slab，因此，应该把每个缓冲区中的各个Slab着色区的大小尽量安排成不同的大小，这样可以使得在不同的Slab中，处于同一相对位置的对象，让它们在高速缓存中的起始地址相互错开，这样就可以改善高速缓存的存取效率。

每个Slab上最后一个对象以后也有个小小的废料区是不用的，这是对着色区大小的补偿，其大小取决于着色区的大小，以及Slab与其每个对象的相对大小。但该区域与着色区的总和对于同一种对象的各个Slab是个常数。

每个对象的大小基本上是所需数据结构的大小。只有当数据结构的大小不与高速缓存中的缓冲行对齐时，才增加若干字节使其对齐。所以，一个Slab上的所有对象的起始地址都必然是按高速缓存中的缓冲行对齐的。

与传统的内存管理模式相比， slab 缓存分配器提供了很多优点。首先，内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。slab 缓存分配器通过对类似大小的对象进行缓存而提供这种功能，从而避免了常见的碎片问题。slab 分配器还支持通用对象的初始化，从而避免了为同一目而对一个对象重复进行初始化。最后，slab 分配器还可以支持硬件缓存对齐和着色，这允许不同缓存中的对象占用相同的缓存行，从而提高缓存的利用率并获得更好的性能。

二：初始化

初看起来，slab系统的初始化不是特别麻烦，因为伙伴系统已经完全启用，内核没有受到其他特别的限制。尽管如此，由于slab分配器的结构所致，这里有一个鸡与蛋的问题。为初始化slab数据结构，内核需要若干远小于一整页的内存块，这些最适合由kmalloc分配。这里是关键所在：只有在slab系统已经启用之后，才能使用kmalloc。更确切的说，该问题涉及kmalloc的Per-CPU缓存的初始化。在这些缓存能初始化之前，kmalloc必须可以用来分配所需的内存空间，而kmalloc自身也处于初始化的过程中，所以这是一个不可能完成的场景，内核必须借助一些技巧。内核中使用kmem_cache_init函数用于初始化slab分配器。它在内核初始化阶段(start_kernel)、伙伴系统启用之后调用。kmem_cache_init采用了一个多步骤的过程，逐步激活slab分配器。

kmem_cache_init可以分为六个阶段：

第一个阶段：是根据kmem_cache来设置cache_cache的字段值；

第二个阶段：首先是创建arraycache_init对应的高速缓存，同时也是在这个kmem_cache_create的调用过程中，创建了用于保存cache的kmem_cache的slab，并初始化了slab中的各个对象;

第三个阶段：创建kmem_list3对应的高速缓存，在这里要注意的一点是，如果sizeof(arraycache_t)和sizeof(kmem_list3)的大小一样大，那么就不再使用kmem_cache_create来为kmem_list3创建cache了，因为如果两者相等的话，两者就可以使用同一个cache;

第四个阶段：创建并初始化所有的通用cache和dma cache;

第五个阶段：创建两个arraycache_init对象，分别取代cache_cache中的array字段和malloc_sizes[INDEX_AC].cs_cachep->array字段;

第六个阶段：创建两个kmem_list3对象，取代cache_cache中的kmem_list3字段和malloc_sizes[INDEX_AC].cs_cachep->nodelist3字段.如此一来，经过上面的六个阶段后，所有的初始化工作基本完成了。

+++linux线程池及内存池++++++
Linux下通用线程池的创建与使用
本文给出了一个通用的线程池框架，该框架将与线程执行相关的任务进行了高层次的抽象，使之与具体的执行任务无关。另外该线程池具有动态伸缩性，它能根据执行任务的轻重自动调整线程池中线程的数量。文章的最后，我们给出一个简单示例程序，通过该示例程序，我们会发现，通过该线程池框架执行多线程任务是多么的简单。
 
为什么需要线程池
目前的大多数网络服务器，包括Web服务器、Email服务器以及数据库服务器等都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。
传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。
我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。
T1：线程创建时间
T2：线程执行时间，包括线程的同步等时间
T3：线程销毁时间
那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。如果任务执行时间很频繁的话，这笔开销将是不可忽略的。
除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生200个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求。
因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。
基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销。
 
构建线程池框架
一般线程池都必须具备下面几个组成部分：
线程池管理器:用于创建并管理线程池
工作线程: 线程池中实际执行的线程
任务接口: 尽管线程池大多数情况下是用来支持网络服务器，但是我们将线程执行的任务抽象出来，形成任务接口，从而是的线程池与具体的任务无关。
任务队列:线程池的概念具体到实现则可能是队列，链表之类的数据结构，其中保存执行线程。
我们实现的通用线程池框架由五个重要部分组成CThreadManage，CThreadPool，CThread，CJob，CWorkerThread，除此之外框架中还包括线程同步使用的类CThreadMutex和CCondition。
CJob是所有的任务的基类，其提供一个接口Run，所有的任务类都必须从该类继承，同时实现Run方法。该方法中实现具体的任务逻辑。
CThread是Linux中线程的包装，其封装了Linux线程最经常使用的属性和方法，它也是一个抽象类，是所有线程类的基类，具有一个接口Run。
CWorkerThread是实际被调度和执行的线程类，其从CThread继承而来，实现了CThread中的Run方法。
CThreadPool是线程池类，其负责保存线程，释放线程以及调度线程。
CThreadManage是线程池与用户的直接接口，其屏蔽了内部的具体实现。
CThreadMutex用于线程之间的互斥。
CCondition则是条件变量的封装，用于线程之间的同步。


++++多态++++
多态就是运行时向同一实例发送同一消息产生不同响应


++++Linux core文件介绍+++++
1. core文件的简单介绍
在一个程序崩溃时，它一般会在指定目录下生成一个core文件。core文件仅仅是一个内存映象(同时加上调试信息)，主要是用来调试的。 

2. 开启或关闭core文件的生成
用以下命令来阻止系统生成core文件:
ulimit -c 0
下面的命令可以检查生成core文件的选项是否打开:
ulimit -a
该命令将显示所有的用户定制，其中选项-a代表“all”。 

也可以修改系统文件来调整core选项
在/etc/profile通常会有这样一句话来禁止产生core文件，通常这种设置是合理的:
# No core files by default
ulimit -S -c 0 > /dev/null 2>&1
但是在开发过程中有时为了调试问题，还是需要在特定的用户环境下打开core文件产生的设置
在用户的~/.bash_profile里加上ulimit -c unlimited来让特定的用户可以产生core文件
如果ulimit -c 0 则也是禁止产生core文件，而ulimit -c 1024则限制产生的core文件的大小不能超过1024kb 

3. 设置Core Dump的核心转储文件目录和命名规则
/proc/sys/kernel/core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0
/proc/sys/kernel/core_pattern可以设置格式化的core文件保存位置或文件名，比如原来文件内容是core-%e
可以这样修改:
echo "/corefile/core-%e-%p-%t" > /proc/sys/kernel/core_pattern
将会控制所产生的core文件会存放到/corefile目录下，产生的文件名为core-命令名-pid-时间戳
以下是参数列表:
    %p - insert pid into filename 添加pid
    %u - insert current uid into filename 添加当前uid
    %g - insert current gid into filename 添加当前gid
    %s - insert signal that caused the coredump into the filename 添加导致产生core的信号
    %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
    %h - insert hostname where the coredump happened into filename 添加主机名
    %e - insert coredumping executable name into filename 添加命令名 

4. 使用core文件
在core文件所在目录下键入:
gdb -c core
它会启动GNU的调试器，来调试core文件，并且会显示生成此core文件的程序名，中止此程序的信号等等
如果你已经知道是由什么程序生成此core文件的，比如MyServer崩溃了生成core.12345，那么用此指令调试:
gdb -c core MyServer
以下怎么办就该去学习gdb的使用了 

5. 一个小方法来测试产生core文件
直接输入指令:
kill -s SIGSEGV $$ 

6. 为何有时程序Down了，却没生成 Core文件。 

Linux下，有一些设置，标明了resources available to the shell and to processes。 可以使用 

#ulimit -a 来看这些设置。 (ulimit是bash built-in Command) 

              -a     All current limits are reported
              -c     The maximum size of core files created
              -d     The maximum size of a process鈥檚 data segment
              -e     The maximum scheduling priority ("nice")
              -f     The maximum size of files written by the shell and its children
              -i     The maximum number of pending signals
              -l     The maximum size that may be locked into memory
              -m     The maximum resident set size (has no effect on Linux)
              -n     The maximum number of open file descriptors (most systems do not allow this value to be set)
              -p     The pipe size in 512-byte blocks (this may not be set)
              -q     The maximum number of bytes in POSIX message queues
              -r     The maximum real-time scheduling priority
              -s     The maximum stack size
              -t     The maximum amount of cpu time in seconds
              -u     The maximum number of processes available to a single user
              -v     The maximum amount of virtual memory available to the shell
              -x     The maximum number of file locks 

从这里可以看出，如果 -c是显示：core file size          (blocks, -c) 

如果这个值为0，则无法生成core文件。所以可以使用： 

#ulimit -c 1024 或者 #ulimit -c unlimited 来使能 core文件。 

如果程序出错时生成Core 文件，则会显示Segmentation fault (core dumped)。 

7. Core Dump的核心转储文件目录和命名规则:
/proc/sys/kernel/core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0 


+++CPU相关+++++
CPU的指令集是什么

指令集是底层软件与硬件交互的语言。一台计算机的全部指令称为该计算机的指令集。

现在的常见的指令集有：

MIPS指令集

ARM指令集

Intel x86指令集

 

指令集有两种形式，一种是人类可以编程书写的形式（也就是平时所说的汇编语言），另一种是计算机所能识别的形式（就是汇编语言对应计算机的机器语言）。

下面是一个典型的MIPS汇编语言：

add s1,

s2,$3

汇编语言和高级语言不一样，变量不能任意指定，它只能操作寄存器中的变量，寄存器的个数在计算机中是有限制的，一般是32个。不同的指令集按照寄存器的顺序给他们排列编号0,1,2... 并且用号来表示寄存器。比如MIPS是使用
s0-s7表示寄存器16−23，

t0-$t7表示寄存器8-15。
寄存器的长度

寄存器一个字的长度有32和64，由于寄存器是CPU一次运算执行的变量单元，因此我们说的32位机器和64位机器最本质的区别就在于寄存器字的长度是32还是64。

寄存器中存的可能是值，也可能是一个地址。
什么是程序计数器（PC）

储存当前程序运行指令的寄存器就是程序计数器。
指令集的寻址方式

其实就是说如何根据寄存器找到一个值。比如MIPS的PC相对寻址，就是说要获取的值的地址是PC（程序计数器）的值与指令中常数的和。
CPU架构

CPU架构指的是全套CPU的机制，包括用什么CPU指令集，用什么寄存器，有什么寻址方式。一般一种指令集对应一种CPU架构。

ARM指令集

ARM指令集是在嵌入式设备中最常用到的指令集，像苹果和三星的移动设备都是使用这个ARM 架构。

Intel X86指令集

这个是PC中最常用到的指令集了，比如平常说的Intel 8086是第一款寄存器为16位长的体系结构。Intel 80386是第一款寄存器为32位长的指令集。

AMD64 指令集

AMD64是64位的。由AMD公司开发。更多用于服务器上。其后也为Intel所采用，称为Intel X86-64
具体产品

举具体产品的例子，iphone4使用的cpu是苹果A4处理器，iphone5使用的是苹果A5处理器，这两个实质上都是ARM架构。三星应用在智能手机和平板电脑上的Exynos处理器也是基于ARM架构的，由自家公司研发改造的。

Intel公司生产的所有CPU都兼容x86指令集，只不过后来它开发出了很多扩展指令集，比如酷睿系列i3/5/7就支持Intel avx扩展指令集，MMX（多媒体扩展指令集）。

比如戴尔的Inspiron笔记本电脑系列多使用AMD的CPU架构。
go中的5g/6g/8g

go编译器支持三种指令集：

amd64（即Intel x86-64或AMD64）: 6g，最成熟的实现
386（即Intel X86-32） : 8g，是amd64到386机器的完美移植
arm： 5g，所以说go本质是支持在移动终端的开发
5g, 5l, 5c, 5a 分别表示 arm的go编译器，链接器，c编译器，汇编编译器


+++操作系统之页式存储管理+++++
说到页式存储管理，我想应该先说用户的程序，因为页式存储管理就是为用户的程序或者是说进程服务的，一个程序编制好了以后它肯定占用空间，也就是说它肯定有大小，程序既然有大小就能将它划分，在这里，就将程序的逻辑空间划分成若干页，称为逻辑页面也叫页。

基础、页划分的理解
页的大小是根据什么划分的那？这就追溯到内存的划分了。页的大小是根据内存中的块大小来划分的。什么是内存中的块那？下面解释一下块。页式存储空间将内存划分为等长的若干区域，每一个区域的大小一般取2的整数幂，每个区域就是一个块，块号从0开始编号，称为块号。分块的大小由什么确定的那呢？是有地址结构确定了主存储器的分块大小，这里不做解释。

现在程序中的页与内存中的块就对应上了，地址结构确定。块，块确定页，而页是有页号和页内地址组成的。
假定地址总长度为15位，其中页号占5位，业内地址占10位。这样，逻辑地址可以有32页（2的五次方=32），可以编号为0―31，每一页有1024个字节（2的十次方=1024），编号为0―1023。从地址结构来看，逻辑地址是连续的，在编制程序时无需考虑如何分页，因为当使用一组顺序地址时，如果地址时0―1023，这显然时第0页，若果是1024―2047，这用的是第1页，也就是页号为1。

一、请求分页式存储管理的基本思想
请求分页式存储管理是基于分页式存储管理的一种虚拟存储器

1. 相同点
a. 把内存空间划分成尺寸相同、位置固定的块

b. 按照内存块大小，把作业的虚拟地址空间（相对地址空间）划分成页（划分过程对用户透明）

c. 虚拟地址空间中的一页可以装入到内存中的任何一块中

2. 不同点
a. 作业全部进入辅存，运转时，并不把整个作业程序一起都装入到内存，只装入目前要用的若干页

b. 运行过程中，虚拟地址被转换成（页号，页内偏移）

c. 根据页号查页表，如果该页不在内存中，就没有具体的块号与之对应，表明“缺页”，运行无法继续，此时，要根据页号把它从辅存中调入内存

d. 所谓请求分页式，是指当程序运行中需要某一页时，再把它从辅存中调入内存使用

3. 其他
用户的虚拟地址空间可以很大，不受内存尺寸约束

二、页表表目的扩充
在请求分页式存储管理中：通过“缺页中断位”判断所需要的页是否在内存中

页的表项包括：页号、块号、缺页中断位、辅存地址、引用位、改变位

页号：虚拟地址空间中的页号

块号：该页所占内存的块号

缺页中断位：1 表示在内存中，0 表示不在内存中，为 0 时会发生“缺页”中断信号，请求系统处理

辅存地址：该页内容存放在辅存中的地址，缺页时，缺页中断处理根据它的指点，将所缺的页调入内存

引用位：在系统规定的时间间隔内，该页是否被引用过（在页面淘汰算法中使用）

改变位：0 表示页面在内存时数据未被修改，1 表示被修改过。当页面被选为淘汰对象时，根据此为的取之来确定是否要将该页的内容进行磁盘回写操作

三、缺页中断的处理
1. 处理过程
a. 根据当前执行指令中的虚拟地址，形成（页号，页内偏移），用页号查页表，判断该页是否在内存中

b. 如该页的缺页中断位为 0，表示该页面不在内存，于是产生缺页中断，让操作系统的中断处理程序进行中断处理

c. 中段处理程序查询存储分块表，寻找一个空闲的内存块；查询页表，得到该页在辅存中的地址，启动磁盘读信息

d. 把从磁盘上读出的信息装入到分配的内存块中

e. 根据分配存储快的信息，修改页表、存储分块表中相应表目的信息

f. 由于产生缺页中断的那条指令并未执行，所以在完成所需页面的装入工作后，应该返回原指令重新执行

2. 缺页中断与一般中断的区别
a. 缺页中断时在执行一条指令中间时产生的中断，并立即转去处理；一般中断则是在一条指令执行完毕之后，当发现有中断请求时再去响应和处理

b. 缺页中断处理执行完毕之后，仍返回到原指令处重新执行；一般终端则是返回到下一跳指令去执行

四、调页方式
主要分为：请调和预调两种，请调为主，预调为辅

1. 请调
发生缺页时，终端请求调入此页

2. 预调
作业最初被调入运行时，通常是预先将相应的第一页装入内存，而所需的其他各页，按照请求顺序装入

五、页面淘汰算法
页面走向：一个程序执行过程中页号的变化序列

页面淘汰问题：发生缺页时，需要从辅存上把所需要的页面调入内存，而当时内存中又没有空闲块，需要选择一个页面调出内存

抖动（颠簸）：一个刚被淘汰出去的页面，不久又要访问，又把它从辅存调入内存，调入不久后又被淘汰......如此反复的调入调出，整个系统一直陷于页面的调入调出，大部分时间都用在处理缺页中断和页面淘汰中

抖动使得整个系统的效率低下，应极力避免

如果淘汰的页面在内存中修改过，必须把它写回到磁盘，以便更新该页在辅存上的副本

1. 先进先出页面淘汰算法（FIFO）
做法：淘汰最早进入内存的页面

FIFO 算法认为：随着时间的推移，在内存中待的时间最长的页面，被访问的可能性最小

实际中：有可能把经常要访问的页面淘汰出去

2. 最近最久未使用页面淘汰算法（Least Recently Used，LRU）
做法：淘汰最长时间未被访问的页面

这是一种基于局部性原理的淘汰算法

LRU 算法认为：如果一个页面刚被访问过，那么不久的将来被访问的可能性就大

3. 最近最少使用页面淘汰算法（Least Frequently Used，LFU）
做法：淘汰当前使用的最少的页面

着眼点在于页面的使用频率

LFU 算法认为：在一段时间内使用得最多的页面，将来用到的可能性就大

要实现 LFU 算法，应该为内存中每一个页面设置一个计数器，对某个页面每访问一次计数器加一，过一段时间，所有计数器清零

4. 最优页面淘汰算法（Optimd，OPT）
做法：把以后不再使用的或在最长时间内不会用到的页面淘汰出去

前提：已知作业运行时的页面走向

因为其苛刻的前提条件：没有实用价值，只能用来做一个标尺

5. FIFO 页面淘汰算法的异长现象
有若干因素会影响缺页中断的发生次数，例如：分配给作业的内存块数

一般情况：分配给作业的内存块数增多，发生缺页中断的可能性就下降

FIFO 的异常现象：对于 FIFO 算法，有时增加分配给作业的内存块数，它的缺页中断次数反而上升

FIFO 算法并不总是产生异长现象，它和页面走向有关

六、缺页中断率
1. 定义
假设一个作业运行的页面走向中涉及到的页面总数为 A，其中有 F 次缺页，必须通过缺页中断把他们调入内存

缺页中断率：f = F/A

2. 影响缺页中断次数的因素
a. 分配给作业的内存块数

b. 页面尺寸

c. 程序的实现

d. 页面淘汰算法

七、虚拟存储的性能问题
在虚拟存储中，页面在内存和外存之间频繁的调度以至于系统中页面所需的时间比进程实际运行的时间还多，在这种情况下，系统效率急剧下降，甚至可能出现全面崩溃

在颠簸时，伴随着磁盘的剧烈抖动，引起颠簸的原因是缺页过于频繁，CPU 忙于处理缺页

活跃页面：进程运行时，CPU 总是集中访问的一些页面

工作集：对于给定的访页序列，在其中选取定长区间，成为工作集的窗口，落在工作集窗口中的集合称为工作集，记为 WS(t)

工作集的大小取决于页的三个因素：访页序列特性、时刻 Ti、窗口长度

引入工作集的目的是：希望分配给进程的页面数与当前工作集的大小吻合

实现工作集存储管理的策略是很困难的

一般可用硬件装置统计当前工作集的大小，用软件根据工作集的大小调整对每个进程分配的物理块数

只有在具备足够内存的情况下，才能有效的实现多道程序设计



+++Lucene++++
全文检索与Lucene学习（一）

1 概述... 1

2 Lucene概述... 3

3 Lucene的索引和检索... 5

4 查询方式总结... 8

4.1 查询API 8

TermQuery（词查询）... 9

BooleanQuery （布尔查询）... 9

WildcardQuery（通配符查询）... 9

PhraseQuery（词组查询）... 10

PrefixQuery（前缀搜索）... 11

TermRangeQuery（非数字范围查询）... 11

NumericRangeQuery（数字范围查询）... 11

FuzzyQuery（模糊查询 ）... 12

MatchAllDocsQuery（查询所有Document）... 12

MultiPhraseQuery（多词组查询）... 13

SpanQuery (跨度搜索，又细分为很多类) 14

4.2 QueryParser语法查询... 16

5 理解得分”Score”（摘自网络）... 18

1 概述
概念：Lucene不是一个完整的全文索引应用，而是是一个用Java写的全文索引引擎工具包，它可以方便的嵌入到各种应用中实现针对应用的全文索引/检索功能。

当前的版本有：Java版的，.NET版的（不完全），网上也有C++重写的，其他各类语言大部分也都有重写的。

简单地说它就两个功能：索引和检索。

主要应用：全文检索，顾名思义即在文件文本中搜索是否含有某个词之类的。（实质不一定是大文本）

全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。

全文检索使用的理由：执行模糊查询都需要对全表扫描或索引扫描意味着消耗大量IO，如果模糊查询经常发生，会造成数据库性能恶化。（当然不一定非得是对大文件的检索，字段的模糊检索也是如此）

通常比较厚的书籍后面常常附关键词索引表（比如：北京：12, 34页， 上海：3,77页……），它能够帮助读者比较快地找到相关内容的页码。而数据库索引能够大大提高查询的速度原理也是一样，想像一下通过书后面的索引查找的速度要比一页一页地翻内容高多少倍……而索引之所以效率高，另外一个原因是它是排好序的。对于检索系统来说核心是一个排序问题。

由于数据库索引不是为全文索引设计的，因此，使用like "%keyword%"时，数据库索引是不起作用的，在使用like查询时，搜索过程又变成类似于一页页翻书的遍历过程了，所以对于含有模糊查询的数据库服务来说，LIKE对性能的危害是极大的。如果是需要对多个关键词进行模糊匹配：like"%keyword1%" and like "%keyword2%" ...其效率也就可想而知了。

全文检索：

全文检索的方法主要分为按字检索和按词检索两种。按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。对于各种不同的语言而言，字有不同的含义，比如英文中字与词实际上是合一的，而中文中字与词有很大分别。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。英文等西方文字由于按照空白切分词，因此实现上与按字处理类似，添加同义处理也很容易。中文等东方文字则需要切分字词，以达到按词索引的目的，关于这方面的问题，是当前全文检索技术尤其是中文全文检索技术中的难点。

全文检索系统是按照全文检索理论建立起来的用于提供全文检索服务的软件系统。一般来说，全文检索需要具备建立索引和提供查询的基本功能，此外现代的全文检索系统还需要具有方便的用户接口、面向WWW的开发接口、二次应用开发接口等等。功能上，全文检索系统核心具有建立索引、处理查询返回结果集、增加索引、优化索引结构等等功能，外围则由各种不同应用具有的功能组成。结构上，全文检索系统核心具有索引引擎、查询引擎、文本分析引擎、对外接口等等，加上各种外围应用系统等等共同构成了全文检索系统。下图展示了上述全文检索系统的结构与功能。


全文检索系统中最为关键的部分是全文检索引擎，各种应用程序都需要建立在这个引擎之上。一个全文检索应用的优异程度，根本上由全文检索引擎来决定。因此提升全文检索引擎的效率即是我们提升全文检索应用的根本。另一个方面，一个优异的全文检索引擎，在做到效率优化的同时，还需要具有开放的体系结构，以方便程序员对整个系统进行优化改造，或者是添加原有系统没有的功能。比如在当今多语言处理的环境下，有时需要给全文检索系统添加处理某种语言或者文本格式的功能，比如在英文系统中添加中文处理功能，在纯文本系统中添加XML或者HTML格式的文本处理功能，系统的开放性和扩充性就十分的重要。

Lucene是纯Java的，是相对比较成熟的，速度也还是可以的，而对于其他的有很多是C++写的，速度甚至会更好，但是成熟性还不够，不过考虑效率的话完全可以选择一些C++版本的全文检索工具。

2 Lucene概述
Lucene索引index由若干段(segment)组成，每一段由若干的文档（document）组成，每一个文档由若干的域（field）组成，每一个域由若干的项（term）组成。项是最小的索引概念单位，它直接代表了一个字符串以及其在文件中的位置、出现次数等信息。域是一个关联的元组，由一个域名和一个域值组成，域名是一个字串，域值是一个项，比如将“标题”和实际标题的项组成的域。文档是提取了某个文件中的所有信息之后的结果，这些组成了段，或者称为一个子索引。子索引可以组合为索引，也可以合并为一个新的包含了所有合并项内部元素的子索引。我们可以清楚的看出，Lucene的索引结构在概念上即为传统的倒排索引（倒排文件或倒排索引是指索引对象是文档或者文档集合中的单词等，用来存储这些单词在一个文档或者一组文档中的存储位置，是对文档或者文档集合的一种最常用的索引机制。）结构。

主要的索引文件及功能：

1、segment_*：描述一组索引的参数，使用文件头固定格式描述后面的内容，包括每个独立新建索引的大小，属性等。

2、fnm：索引域描述文件，一个独立的索引（PerIndex）叫做一个segment（索引段），一个fnm文件描述了本索引的File数，各个 Field的属性编号。

3、fdx：文档域值索引文件，采用定长方式存储，根据docid排序，可直接定位。用来记录每个文档的Stored fields值的存储位置。

4、fdt：文档域值存储文件，存储Stored fields值的文件。通过fdx中记录的便宜访问。

5、tis：存储每个term在文档中的分布信息，如文档频率，每个含term文档出现次数记录的偏移和位置记录的偏移排列顺序。先按Field名字字典 排序，在每个Field按term字典排序。

6、tii：该文件是tis文件的索引和精简，排列格式一样，但不含有每个term属性的信息。这个文件可以完全读入到内存中。

7、frq：该文件是tis文件的扩展。记录每个term在每个包含文件中具体出现频率。

8、prx：该文件是tis文件的延伸，记录每个term在每个文档偏移信息。这个文档省略类docid，必须配合frq文件使用。

9、tvx，tvd，tvf：用来索引和保持每一个文档的向量化字段的信息。

命名规则：更新或创建都会修改文件名字 0-9a-z来进行命名，36进制命名规则。

3 Lucene的索引和检索
在此我做了一个简单的Demo，先以demo为例来讲述一下大体流程：

比如咱现在要将一些报警信息进行索引并用于检索，报警信息格式（简略演示）如下：

PCIP：xx.xx.xx.xx

DeviceIP：xx.xx.xx.xx

DeviceSerialNum：xxxxxxxx

AlarmType：移动侦测

AlarmDatetime:xxxxxx

为了读取待索引数据方便，将一些条目保存到记事本里面：

172.7.14.198 172.7.19.71 DS-2DF1-4010020090611AACH290005648WC移动侦测 2011/9/1

172.7.14.198 172.7.19.71 DS-2DF1-4010020090611AACH290005648WC移动侦测 2011/9/1

172.7.14.198 172.7.24.51 DS-9016HF-S1620100809BBRR401273372WCVU移动侦测 2011/9/1

172.7.14.198 172.7.24.51 DS-9016HF-S1620100809BBRR401273372WCVUC移动侦测 2011/9/1

…

…

建项目：

引入最新的Lucene包（3.3.0）lucene-core-3.3.0.jar到工程

建索引：

使用的对象和基本步骤：

Analyzer，解析器。

IndexWriter，需要对象IndexWriter来进行索引的创建与更新。

Document，写入的文档，是IndexWriter的基本对象。（一条报警可以用一个文档表示）

Field，一个Document可以有多个Field，这是我们存储的基本单位。（PCIP等都可以视为Field）注：field默认域名区分大小写，最好统一。

A. 创建写对象IndexWriter，它依赖于Analyzer、存储路径，可通过IndexWriterConfig对其进行参数设置。

B. 创建空文档Document doc = newDocument();

C. 向空文档里面添加若干个Field，doc.add(new Field("PCIP", fields[0],Field.Store.YES, Field.Index.ANALYZED_NO_NORMS));

注：

Field参数STORE，与索引无关，是否额外存储原文 ，可以在搜索结果后调用出来，

NO不额外存储；

YES，额外存储。

Field参数INDEX，

NO，不索引；

ANALYZED，分词后索引；

NOT_ANALYZED，不分词索引

ANALYZED_NO_NORMS，分词索引，不存储NORMS；

NOT_ANALYZED_NO_NORMS，不分词，索引，不存储NORMS。

除了NO外都算索引，可以搜索。NORMS存储了boost所需信息，包含了NORM可能会占用更多内存。

D. 向IndexWriter添加Document，writer.addDocument(doc);

E. 优化索引（优化相对比较慢，可以选择进行，优化之后可以达到最大查询速度，//writer.optimize();//优化索引

注：实质上一个Document里面的同一个Field可以多次添加，也就是一个数组，这也可以理解为一个Document又可以添加自己的子集，例如下面的例子：

TeacherId: 1

StuFirstName: james

StuLastName: jones

TeacherId: 2

StuFirstName: james

StuLastName: smith

StuFirstName: sally

StuLastName: jones

TeacherId: 3

StuFirstName: james

StuLastName: smith

StuFirstName: keith

StuLastName: keith

StuFirstName: keith

StuLastName: keith

StuFirstName: sally

StuLastName: jones

三个老师，每个老师拥有的同学个数不一样，可以创建三个Document去存储，当然也可以创建更多的Document去处理，这个视实际的需要定。

检索：

IndexSearcher：由于检索的检索器

Analyzer：查询条件对象使用的解析器

QueryParser：将查询字符串转为查询条件对象

Query（或者SpanQuery）：由于查询的查询条件对象。

TopDocs：获取结果集的最靠前的若干项。

ScoreDoc：获取结果集中的结果。

Document：每一条结果的文档对象，也就是所要查询的结果项，可以由它继续获取它所包含的所有Field等。

A． 创建检索对象IndexSearcher，IndexSearcher searcher = new IndexSearcher(FSDirectory.open(new File(indexFilePath)));

B． 创建查询条件对象Query（方式很多，也较复杂），它的详细类型在后面的查询方式总结中细述了。

C． 开始查询：TopDocs results = searcher.search(query, 5 * hitsPerPage);

D． 获取查询结果集：ScoreDoc[] hits = results.scoreDocs;

E． 获取文档并对文档信息进行处理：

以上就是一个简单的索引和检索过程，实质上可以利用一些其他的类实现一些比较复杂的索引和查询，其功能是十分强大的。我写了很多的的Demo源码，大家可以传一下作为参考，依赖包为：lucene-core-3.3.0.jar。

对于IndexReader性能资源讨论

IndexReader封装了底层的API操作，reader的open操作非常耗费资源，因此reader应该重用。

但是reader打开后便不能获悉之后更新的Index，因此可reopen：

reopen将尝试尽量重用 ，如果无法重用将创建新的IndexReader，因此需要判断。

IndexReader newReader = reader.reopen();
if (reader != newReader) {
reader.close();
reader = newReader;
searcher = new IndexSearcher(reader);
}

执行搜索

IndexSearcher提供了很多API，下述几个均可以。

TopDocs search(Query query, int n)

TopDocs search(Query query, Filter filter, int n)

TopFieldDocs search(Query query, Filter filter, int n, Sort sort)

TopDocs

多数search直接返回一个TopDocs作为搜索的结果（已经按照相似度排序） ，它包含三个属性（方法）：

totalHits：有多少个Document被匹配

scoreDocs：每一个具体的搜索结果（含分、Document等）

结果的分页

在Lucene中，常用的解决方法有：

1、在第一次就把很多结果都抓取过来，然后根据用户的分页请求来显示

2、每次重新查询

一般来说，Web是“无状态协议”，重新查询可回避状态的存储，是一种较好的选择。每次用户选择后面的页后，将“n”的数值加大，即可显示后面的内容。

“实时搜索”

实时搜索的关键是：不要自己创建Directory->IndexReader，而是使用下述办法：

IndexWriter.getReader()：这可以不需要重新commit 索引就立即获得更新。

IndexReader newReader = reader.reopen()：重用reader，比起open非常快捷，但是注意如果reader!=oldReader，则需要关闭oldReader。

4 查询方式总结
查询方式总体来讲分两类：查询API查询和语法查询

建议：依据咱项目的需要我觉得可以着重看一下这几种：语法查询（QueryParser），TermQuery，BooleanQuery，WildcardQuery，PrefixQuery，PhraseQuery ，SpanTermQuery ，FieldMaskingSpanQuery。

4.1 查询API
注：对于查询时的Field名一定要大小写对应，默认情况下要查询的关键字要转成小写，这在lucene建索引的时候做过特殊处理。可以采用 QueryParser.setLowercaseExpandedTerms(boolean flag)来设置是否将其转为小写。最好将查询的关键词转为小写来检索。

基类是Query，继承自Query类的一些类即可实现很多复杂的查询，这些查询包括：TermQuery，MultiTermQuery，BooleanQuery，WildcardQuery，PhraseQuery，PrefixQuery，MultiPhraseQuery，FuzzyQuery，TermRangeQuery，NumericRangeQuery，SpanQuery（又包括：SpanTermQuery、SpanFirstQuery、SpanNearQuery、SpanNotQuery、SpanOrQuery、 FieldMaskingSpanQuery、SpanMultiTermQueryWrapper）、MatchAllDocsQuery ，

其中：NumericRangeQuery，FuzzyQuery，NumericRangeQuery，PrefixQuery,TermRangeQuery,WildcardQuery,SpanMultiTermQueryWrapper 属于多term查询，继承自MultiTermQuery,我们也可以自定义实现我们自己的查询，下面我们来详细了解各种查询，并每一种都有对应的 demo，最好结合Demo去理解各种查询。

TermQuery（词查询）
TermQuery是Lucene里面最基本的一种原子查询，它基本就是在某个Field里面查找某个词，如果查询到这个词就将对应的Document返回到结果集。

BooleanQuery （布尔查询）
布尔查询其实就是将各种查询的结果再进行布尔运算，最后在得到查询结果。一个查询中可以添加很多的布尔查询进行帅选。布尔查询在对于按条件查询记录的时候特别方便。

查询条件的限制方式：MUST、SHOULD、MUST_NOT

限制组合的意义：

1．MUST和MUST：取得连个查询子句的交集。

2．MUST和MUST_NOT：表示查询结果中不能包含MUST_NOT所对应得查询子句的检索结果。

3．SHOULD与MUST_NOT：连用时，功能同MUST和MUST_NOT。

4．SHOULD与MUST连用时，结果为MUST子句的检索结果,但是SHOULD可影响排序。

5．SHOULD与SHOULD：表示“或”关系，最终检索结果为所有检索子句的并集。

6．MUST_NOT和MUST_NOT：无意义，检索无结果。

PhraseQuery（词组查询）
PhraseQuery支持多个关键字的搜索，slop用于表示“距离”，设定PhraseQuery的slop可控制多关键词的检索。相连的两词，将总被检索出来，无论slop为多少。对于slop距离的理解：对于“移动侦测”这个在不使用中文分词的技术时，被理解为4个词，现在以“移、侦、测”三个词为例：

'移’当前处于位置1，实际位置1

'侦’当前处于位置2，实际位置3

'测’当前处于位置3，实际位置4

只需要移动一步就可以构成：移*侦测

所以slop最小为1.

假如现在给的关键字序列是：测、侦、移

'移’当前处于位置3，实际位置1

'侦’当前处于位置2，实际位置3

'测’当前处于位置1，实际位置4

需要移动的步数最少是几呢？

1. 测侦移

2. 侦测移

3. 侦移测

4. 移侦测

5. 移*侦测

这是最少的移动方式，需要5次，所以slop最小为5时才可以检索到词组：移动侦测

综上我们了解到实质上slop是移动距离：将一个Query经过移动多少步可以符合另一个 。



+++++++epoll详解+++++++
首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。

    不管是文件，还是套接字，还是管道，我们都可以把他们看作流。

    之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？

阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。

非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”

    很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。

    大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。

    为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。

假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。

假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。

    但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。

假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”

    也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。

这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。

    然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。

    于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：
<pre>
while true {
    for i in stream[]; {
        if i has data
            read until unavailable
    }
}
</pre>
   我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。

    为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:
<pre>
while true {
    select(streams[])
    for i in streams[] {
        if i has data
            read until unavailable
    }
}
</pre>
于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。

    但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次

说了这么多，终于能好好解释epoll了

    epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）

    在讨论epoll的实现细节之前，先把epoll的相关操作列出：

epoll_create 创建一个epoll对象，一般epollfd = epoll_create()

epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件

比如

epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入

epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入

epoll_wait(epollfd,...)等待直到注册的事件发生

（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。
一个epoll模式的代码大概的样子是：
<pre>
while true {
    active_stream[] = epoll_wait(epollfd)
    for i in active_stream[] {
        read or write till
    }
}
</pre>


+++linux ssh远程登录原理及中断原理++++++
linux ssh远程登录原理及中断原理
问题：对远程linux/UNIX系统进行操作，通常的途径是采用终端软件通过SSH登陆远程系统进行操作。但是在发生网络中断时，linux/UNIX端运行的程序将会中断。请简述这种问题发生的原理、通过何种途径避免这种问题，以及该途径可以规避此问题的原理。
我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。
　　　　场景：
　　如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？  hangup 名称的来由在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。
　　解决方法：nohup/setsid/&
　　我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。
　　1. nohup
　　nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：NOHUP（1） User Commands NOHUP（1）
　　NAME nohup - run a command immune to hangups， with output to a non-tty
　　SYNOPSIS nohup COMMAND [ARG]……
　　nohup OPTION
　　DESCRIPTION Run COMMAND， ignoring hangup signals.
　　——help display this help and exit
　　——version output version information and exit
　　可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&"来将命令同时放入后台运行，也可用">filename 2>&1"来更改缺省的重定向文件名。
　　nohup 示例[root@pvcent107 ~]# nohup ping www.ibm.com & [1] 3059 nohup： appending output to `nohup.out' [root@pvcent107 ~]# ps -ef |grep 3059 root 3059 984 0 21：06 pts/3 00：00：00 ping www.ibm.com root 3067 984 0 21：06 pts/3 00：00：00 grep 3059 [root@pvcent107 ~]#
　　2. setsid
　　nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：SETSID（8） Linux Programmer‘s Manual SETSID（8）
　　NAME setsid - run a program in a new session
　　SYNOPSIS setsid program [ arg …… ]
　　DESCRIPTION setsid runs a program in a new session.
　　可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。
　　setsid 示例[root@pvcent107 ~]# setsid ping www.ibm.com [root@pvcent107 ~]# ps -ef |grep www.ibm.com root 31094 1 0 07：28 ？ 00：00：00 ping www.ibm.com root 31102 29217 0 07：29 pts/4 00：00：00 grep www.ibm.com [root@pvcent107 ~]#
　　值得注意的是，上例中我们的进程 ID（PID）为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID.请将此例与nohup例中的父 ID 做比较。
　　3. &
　　这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“（）”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。
　　当我们将"&"也放入“（）”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。
　　subshell 示例[root@pvcent107 ~]# （ping www.ibm.com &）
　　[root@pvcent107 ~]# ps -ef |grep www.ibm.com root 16270 1 0 14：13 pts/4 00：00：00 ping www.ibm.com root 16278 15362 0 14：13 pts/4 00：00：00 grep www.ibm.com [root@pvcent107 ~]#
　　从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID.因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。


+++收藏的一些常用Linux命令+++++
抓取某个进程:ps -eaf | grep xxx ，一般用作ps -aux | grep xxx
ctrl+r:搜索某个以前输入过的命令 或者!command
sudo !!执行最近输入的一次命令
输入错误命令全部取消，重新输入：ctrl+c
set、env、export的区别：
set是shell变量，env是环境变量，export是一个将shell变量导入到env变量集合的工具。
打开一个shell后，操作系统会分配一个记忆块给shell使用，此内存内的变量可让子进程取用；若在父进程利用export功能，可以让自定义变量的内容写到上述的记忆块中（环境变量）；当加载另一个shell时（启动子shell，离开父shell，可通过echo $$查看该shell的PID），子shell可以将父shell的环境变量所在的记忆块导入自己的环境变量块当中。
tar是打包命令，不压缩，但一般使用中有z压缩成gzip和j压缩成bzip2.
tar -jtv -f a.bzip2 查看包内文件
tar -jcv -f DES 新建压缩包
ar -jxv -f DES 解压包
scp命令是linux主机间的文件传输命令。格式为
scp local_file user@remote_ip:$DIR(本地到远端)
scp user@remote_ip:file $DIR(远端到本地)
linux的rpm机制 在linux下，几乎所有的软件都是通过rpm方式来进行安装、卸载、管理的。RPM的全称为redhat package manager，是由redhat公司提出的，用于管理linux下软件的软件。rpm一般分为5个模式：安装、卸载、升级、查询、验证。
rpm安装：rpm -ivh example.rpm //安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度；
rpm卸载：rpm -e tomcat4 //卸载 tomcat4 软件包(一般先使用rpm查询安装包是否存在、安装目录什么的)
rpm升级：rpm -Uvh example.rpm //升级 example.rpm 软件包
rpm查询：rpm -qa | grep tomcat4 //查看 tomcat4 是否被安装；rpm -qpl packagename //查看rpm包中的内容
rpm验证：rpm -Vf /etc/tomcat4/tomcat4.conf //验证rpm包的修改信息等
在一个文件夹中需要找到某个变量的定义，可以使用这个命令（其实是脚本）:
for file in ls;do echo file;grep‘CQueryFeed′file;grep‘CQueryFeed′file;done
在学了find,grep之后，功力暴涨：find ./* -exec grep -Hn ‘keyword’ {} \;
从当前目录开始查找所有扩展名为.js的文本文件，并找出包含logout的行
find . -type f -name “*.js” | xargs grep “logout”
安装源码包后，无法找到动态库：这个首先需要了解动态库和静态库的区别，然后需要了解/etc/ld.so.conf，默认情况下，编译器寻找动态库只会到/lib和/usr/lib下寻找，如果我们我们没有使用—prefix指定安装目录，那么会安装到/usr/local下，这时我们可以把/usr/local/lib加入到/etc/ld.so.conf中，然后用/sbin/ldconfig命令将新安装的库缓存到/etc/ld.so.cache中，这样编译器就能找到新安装的库了。第二种解决方法就是改变PKG_CONFIG_PATH，这个ls /usr/lib/pkgconfig看到的*.pc就会明白这个变量的作用了。
在Ubuntu中创建新用户，通常会用到两个命令：useradd和adduser。虽然作用一样，但用法却不尽相同：
使用useradd时，如果后面不添加任何参数选项，例如：#sudo useradd test创建出来的用户将是默认“三无”用户：一无Home Directory，二无密码，三无系统Shell。
使用adduser时，创建用户的过程更像是一种人机对话，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。
mbr是硬盘的一个引导区，而grub是一个引导程序！在mbr中有一段空间需要编写引导程序！grub只是引导程序的一种！如果grub够小的话，直接写在mbr中，就可以引导操作系统了！如果grub太大，在只能写一部分在mbr了！如果装windows则硬盘中的grub程序就不能运行了！不是不行，而是微软不愿兼容其它操作系统程序！
ubuntu下的鼠标有时候设置起来不是很管用，这时候我们可以通过xset m a b来设置，a代表加速多少倍，b代表移动多少像素。这个命令的意思就是在移动b个像素之后鼠标加速a倍。如果你的鼠标灵敏度太高，就可以把b调到很大，这样鼠标肯定就不能加速，鼠标速度就能慢下来了。
在命令提示符中输入命令，难免会输错。有几个命令会很常用：
ctrl + c :直接停止当前命令行编辑，转到下一行
ctrl + u:删除本行的命令
ctrl + a:到命令头
ctrl + e:到命令尾
ctrl+w:删除当前字段
在查看某个服务的log时，经常使用tail -f命令循环查看log的实时信息，同样，还有一个watch -d ls -l命令，默认2秒检测一下ls -l的情况，如果有变动就会高亮显示。另外，在查看进程时，ps是查看某个时间点，而top如tail -f和watch -d一样，也可以动态查看。
如果我们需要知道某些服务的进程号时，一般会使用ps aux | grep ssh这样的命令，然后再去看看各个进程的PID，其实有pgrep ssh这个命令，直接查找所有ssh的进程ID。
上传文件只需在shell终端仿真器中输入命令“rz”，即可从弹出的对话框中选择本地磁盘上的文件，利用Zmodem上传到服务器。下载文件只需在shell终端仿真器中输入命令“sz 文件名”，即可利用Zmodem将文件下载到“路径\SecureCRT-5.1.3\download\”目录下。通过“File Transfer”可以修改上传和下载的默认路径。
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c查看CPU；free -g查看内存
当一个文件夹内log信息太多时，使用rm -f .log会显示augument list too long，这时可以使用find -name ‘.log’ | xargs rm -rf应该就可以了，或者写一个for的shell脚本也可以。
vim匹配汉字[^\x00-\x7f]+，然后如果替换3个字段中间那个，其他2个保持不变，可使用:1,$s(…)X(…)/\1Y\2/g即可。
awk -F “:” ‘/something_to_sum/ {sum += $5}; END {print sum}’ /data1/log/a.log，统计在a.log以：分隔的第五个字段的总和。cat a.log | grep ‘hello’ | wc -l 统计a.log中hello字段出现的总行数。当然，在vim中也可以统计，命令是”:%s/hello//gn”然后下方会提示有多少个match（只统计hello出现次数，与在不在同一行无关。所以统计行数时候有可能2个hello处在同一行，这样结果就不对了）【复制的时候看看双引号是不是被搞成中文了。。】
用vim操作后，当需要保存文件时我常用的是:wq命令，看到同事有用:x的。今天查了一下区别：
:wq 强制性写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。
:x 写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。 区别不大，但是当用make之类根据文件修改时间进行操作的工具时就有了影响。这点考虑到就可以了。
有时候用vim会遇到权限问题，比如一个root的文件，你用一个普通用户编辑了半天，等保存时候猛然发现，你没有权限。。。这是多么蛋疼的情景啊。不过当你试过这个命令就笑了“:w !sudo tee %”，解释一下：把当前编辑的文件的内容当做标准输入输入到命令sudo tee 文件名里去也就是sudo保存为当前文件名（%代表当前文件名）
在java中一般使用jdbc.properties配置mysql数据库。从中可以得到4个信息：name,pwd,url,port。name/pwd/port都直接标出来了，url就是mysql://:3746中间的部分。然后命令行登陆为> mysql -uname -ppwd -hurl -Pport。
对数据库中某个字段（a）的所有记录中的另一个字段求和（b）：select SUM(b) from tablename where (Id=’a’) and (createTime like ‘20130926%’); 其中还用到了like，如果date不是date类型的，而是varchar的，就可以使用like，其中%代表mysql的通配符，然后你懂的。
发现/usr的空间全满了，可以使用du -sh * 查看当前目录下某个文件夹的大小。我使用的ll -h，原来以为是列出当前目录下面的所有文件/目录的总大小，其实对文件来说，是列出文件的大小（以人类易读的方式，如2k,3M,5G）,但是对于目录，目录保存的仅仅是下面文件的inode占用空间。（一般一个目录带下为4K），而如
果想要知道目录下所有文件占用的总空间，就得使用du（相当于统计的命令）
统计最常用的top ten命令：
history | awk ‘{CMD[$2]++;count++;} END { for(a in CMD) {print CMD[a] “ “ CMD[a]/count*100 “% “ a}}’ \
pipe> | grep -v “./“ | column -c3 -s “ “ -t | sort -nr | nl | head -n10
linux查看设置的语言：/etc/sysconfig/i18n下。
有时候需要把一个文件排序，但是名字可能是固定的不想修改，你使用>定向（sort 1 > 1会把文件清空），而sort -o选项可以把结果写到原文件。比如sort -n 1 -o 1
使用cat合并文件，如cat 1.txt 2.txt 3.txt > 4.txt；如果1/2/3.txt中存在多个空行，最终保存到4.txt时，连续的空行会被替换为1行。如果我们希望去掉空行，可以使用如下：cat -s 1.txt 2.txt 3.txt | sed ‘/^[[:space:]]*$/d’ > 4.txt
vim的virtual模式分为3种：
用v命令进入的字符可视化模式（Characterwise visual mode)。文本选择是以字符为单位的。
用V命令进入的行可视化模式（Linewise visual mode)。文本选择是以行为单位的。
用ctrl-V进入的块可视化模式（Blockwise visual mode）。可以选择一个矩形内的文本。（注意： 在Windows中，ctrl-V可能已经被影射为粘贴操作，可以使用ctrl-Q进入块可视化模式。）
在使用diff命令的时候有3种显示，但是如果我们仅仅需要查看2个文件所有不同的记录，去掉diff加上的123a124或者>或者<,可以先diff a b > difflog，然后使用grep+sed：cat difflog | grep -v ‘^[0-9]’ | sed -e ‘s/[^ ]* //‘ > difflog2
管道是实现“将前面的标准输出作为后面的标准输入”xargs是实现“将标准输入作为命令的参数”
我们写完shell脚本一般会使用三种方式来执行
source 1.sh：当前shell执行
sh 1.sh：子shell执行
./1.sh：子shell执行 很明显，子shell执行后对父shell没有任何影响，就好像局部变量。比如你1.sh起作用的是cd /data0/niushuai，那么你用后两种执行后，还是在当前目录（因为子shell进入/data0/niushuai后完成任务退出后，不会给父shell任何影响）；如果想对当前shell影响，就必须使用source。这就是配置.bashrc后需要source的原因。
查询数据库某个表的大小（字节为单位）
use information_schema;
select TABLE_NAME,DATA_LENGTH+INDEX_LENGTH,TABLE_ROWS FROM TABLES WHERE TABLE_SCHEMA=’数据库名’ AND TABLE_NAME=’表名’;
mysql通过root新建数据库后，必须给某一用户通过grant授权后，用户才能正常使用。
vim将匹配的行全部删除:g/^2013#/d，删除所有以2013#开头的行。:g/^#/d删除空行。
获取本机某块网卡IP地址的命令：ifconfig eth0 | grep ‘inet addr’ | sed ‘s/^.addr://‘ | sed ‘s/ B.//‘但是当一台机器有多个网卡且只有一个工作的时候，可以使用这个命令来获得当前机器提供网络服务的IP地址：grep//‘但是当一台机器有多个网卡且只有一个工作的时候，可以使用这个命令来获得当前机器提供网络服务的IP地址：grep(hostname) /etc/hosts| awk ‘{print $1}’ 然后又碰到了逆天一样简单的hostname -i
有时候查看log日志时候，想抓取随机几行。但是log太大的时候，打开都不容易。我们可以使用sed -n ‘20,60p’ log > temp.log。其中-n是安静模式（不在stdout输出）
监控某台服务器的cpu load信息（设置5s）：top -b -d 5 | grep —line-buffered ‘load’ > cpuload &
查看服务器CPU数目： cat /proc/cpuinfo | grep -c ‘model name’
查看当前内存使用情况可以使用top或者free来查看。
查看cpu使用情况：sar -u 5 720 > cpu.out &
查看cpu是几核的，详细信息： cat /proc/cpuinfo | grep ‘model name’
最新到位了新机器，修改了/etc/profile,root后用non login登陆的话，source /etc/profile发现只在当前shell生效，退出登陆还是不行。然后问了一下运维，才知道这个必须完全切换到root才能全局生效。由之前的sudo su切换变为login的sudo su -然后再source就可以了。

+++查看历史使用过的Linux命令的top 10++++
history | awk '{CMD[$2]++;count++;}END { for (a in CMD)\
print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" \
| column -c3 -s " " -t | sort -nr | nl | head -n10





