1》》》》》base64_encode
string base64_encode(string data)
将字符串以64位进行编码，可以让中文字或者图片也能在网络上顺利传输。

2》》》》》get_loaded_extensions()
这是查看php开启的扩展，输出的一个数组元素。

3》》》》》setlocale() 
函数设置地区信息（地域信息）。
设置地区为 US English，然后重新设置回系统默认：
<?php
echo setlocale(LC_ALL,"US");
echo "<br>";
echo setlocale(LC_ALL,NULL);
?>

4》》》》》数组函数
array()	创建数组。	
array_change_key_case()	返回其键均为大写或小写的数组。 	
array_chunk()	把一个数组分割为新的数组块。	
array_combine()	通过合并两个数组来创建一个新数组。	
array_count_values()	用于统计数组中所有值出现的次数。	
array_diff()	返回两个数组的差集数组。	
array_diff_assoc()	比较键名和键值，并返回两个数组的差集数组。	
array_diff_key()	比较键名，并返回两个数组的差集数组。	
array_diff_uassoc()	通过用户提供的回调函数做索引检查来计算数组的差集。	
array_diff_ukey()	用回调函数对键名比较计算数组的差集。	
array_fill()	用给定的值填充数组。	
array_filter()	用回调函数过滤数组中的元素。	
array_flip()	交换数组中的键和值。	
array_intersect()	计算数组的交集。	
array_intersect_assoc()	比较键名和键值，并返回两个数组的交集数组。	
array_intersect_key()	使用键名比较计算数组的交集。	
array_intersect_uassoc()	带索引检查计算数组的交集，用回调函数比较索引。	
array_intersect_ukey()	用回调函数比较键名来计算数组的交集。	
array_key_exists()	检查给定的键名或索引是否存在于数组中。	
array_keys()	返回数组中所有的键名。	
array_map()	将回调函数作用到给定数组的单元上。	
array_merge()	把一个或多个数组合并为一个数组。	
array_merge_recursive()	递归地合并一个或多个数组。	
array_multisort()	对多个数组或多维数组进行排序。	
array_pad()	用值将数组填补到指定长度。	
array_pop()	将数组最后一个单元弹出（出栈）。	
array_product()	计算数组中所有值的乘积。	
array_push()	将一个或多个单元（元素）压入数组的末尾（入栈）。	
array_rand()	从数组中随机选出一个或多个元素，并返回。	
array_reduce()	用回调函数迭代地将数组简化为单一的值。	
array_reverse()	将原数组中的元素顺序翻转，创建新的数组并返回。	
array_search()	在数组中搜索给定的值，如果成功则返回相应的键名。
array_shift()	删除数组中的第一个元素，并返回被删除元素的值。	
array_slice()	在数组中根据条件取出一段值，并返回。	
array_splice()	把数组中的一部分去掉并用其它值取代。	
array_sum()	计算数组中所有值的和。	
array_udiff()	用回调函数比较数据来计算数组的差集。	
array_udiff_assoc()	带索引检查计算数组的差集，用回调函数比较数据。
array_udiff_uassoc()	带索引检查计算数组的差集，用回调函数比较数据和索引。	
array_uintersect()	计算数组的交集，用回调函数比较数据。	
array_uintersect_assoc()	带索引检查计算数组的交集，用回调函数比较数据。	
array_uintersect_uassoc()	带索引检查计算数组的交集，用回调函数比较数据和索引。	
array_unique()	删除数组中重复的值。	
array_unshift()	在数组开头插入一个或多个元素。	
array_values()	返回数组中所有的值。	
array_walk()	对数组中的每个成员应用用户函数。	
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。	
arsort()	对数组进行逆向排序并保持索引关系。	
asort()	对数组进行排序并保持索引关系。	
compact()	建立一个数组，包括变量名和它们的值。	
count()	计算数组中的元素数目或对象中的属性个数。	
current()	返回数组中的当前元素。	
each()	返回数组中当前的键／值对并将数组指针向前移动一步。	
end()	将数组的内部指针指向最后一个元素。	
extract()	从数组中将变量导入到当前的符号表。	
in_array()	检查数组中是否存在指定的值。	
key()	从关联数组中取得键名。	
krsort()	对数组按照键名逆向排序。	
ksort()	对数组按照键名排序。	
list()	把数组中的值赋给一些变量。	
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。	
natsort()	用“自然排序”算法对数组排序。	
next()	将数组中的内部指针向前移动一位。	
pos()	current() 的别名。	
prev()	将数组的内部指针倒回一位。	
range()	建立一个包含指定范围的元素的数组。	
reset()	        将数组的内部指针指向第一个元素。	
rsort()	        对数组逆向排序。	
shuffle()	把数组中的元素按随机顺序重新排列。	
sizeof()	count() 的别名。	
sort()	        对数组排序。	
uasort()	使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。	
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。	
usort()	使用用户自定义的比较函数对数组中的值进行排序。


5》》》》strpos()
在使用该函数的时候。里面的位置一定要分清楚，strpos(原字符串，“需要查找的字符串片段”);
谨记谨记谨记

 
6》》》》strcmp()函数
比较两个字符串（区分大小写）：
<?php
echo strcmp("Hello world!","Hello world!");
?>


7》》》》array_unique(array)  函数
该函数用来移除数组中的重复的值，并返回结果数组。
当几个数组元素的值相等时，只保留第一个元素，其他的元素被删除。
返回的数组中键名不变。

1>
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

2>
preg_replace_callback()正则替换回调函数;
3>
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33
4>
is_numeric()   检测变量是否为数字或数字字符串;如果是返回true,不是返回false;
5>
array_unique() 函数移除数组中的重复的值，并返回结果数组.
$unique=array('f','d','f','s');
print_r(array_unique($unique));
结果为：
Array ( [0] => f [1] => d [3] => s ) 
6>
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()
7>
array_filter(array,function);筛选出需要的结果
function myfudction($v)
{
if($v=="H")
{
 
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfudction"));
8>
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 
9>
join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串
10>PHP 面向对象：parent::关键字
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();
11>
这里的$name可以直接用$this->name调用。
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();
12>__construct()构造函数与__destruct()析构函数，前者是在一个类被实例化之前先被自动调用，无返回值，后者则是在销毁一个类之前自动执行一些东西，即两个的执行时间不一样，其他的区别不大。
final 关键字用于定义类和方法，该关键字表示该类或方法为最终版本，即该类不能被继承，或该方法在子类中不能被重载（覆盖）。

13>
__call(1,2) 方法用于监视错误的方法调用。


echo $HTTP_COOKIE_VARS["TestCookie"]; 输出所有cookie值。

mktime()函数适合用来进行日期计算和校验，设定一个固定日期。
echo date('Y-m-d H:i:s',mktime(0,0,0,12,30,1997));  //输出1997-12-30 00:00:00
echo date('Y-m-d H:i:s',mktime(0,0,0,12,32,1997));  //输出1998-01-01 00:00:00


验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间：
<?php 
$str = 'a1234'; 
if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) { 
echo "验证成功";} else { 
echo "验证失敗";}?>


TCP / IP长连接&连接池的应用
Reboot | 2015-11-20 15:28
我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。
TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。
在有些文章里总会提到这名词、或者五元组，甚至七元组。虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：
四元组： 源IP地址、目的IP地址、源端口、目的端口
五元组： 源IP地址、目的IP地址、协议、源端口、目的端口
七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引
在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。
再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。
HTTP的长连接
HTTP长连接，HTTP持久连接（HTTPpersistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。
在HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：
Connection: Keep-Alive
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive
这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
在HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。
然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。
loading...
Keep-Alive的优势
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接
Keep-Alive的劣势
对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。
根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。这个指引旨在提高HTTP响应时间并避免阻塞。
但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。
动静分离
为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。
动静分离同时还会有一个额外的好处：
对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后，请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。
如下表：
loading...
关于Reboot：
专注于互联网运维开发分享、交流，让更多的运维工程师更加专注于自动化，为国内公有云开发、监控、运维贡献自己的力量，这里集聚着国内一线互联网工程师，乐于分享与交流 ^.^发现文章不错的话请关注我们
Reboot QQ交流群：
238757010
365534424
等着   与你一起  改变这世界
一、IT技术文章：
回复"1",查看——“ 如何深入了解linux”
回复"2",查看——“Python 自动化框架”
回复"3",查看——“ Linux 运维职业规划”
回复"4",查看——“提升B格的命令技巧”
回复"5",查看——“网络编程-从Apache到Nginx”
回复"6",查看——“两个使用的Python 装饰器
回复"7",查看——“Python 多线程、进程那些事”
回复"8",查看——“1000，000 packets/s的挑战”
回复"9",查看——“Op危机，你嗅到了没？”
回复"10",查看——“干货丨戏说非阻塞网络编程”
回复"11",查看——“用Python写一个简单的监控系统”
回复"12",查看——“提高你Python 编码效率的‘武林秘籍’”
二、最新课程：
回复"课程",查看——最新课程消息
回复"报名"，查看——报名咨询方式
回复"Reboot",查看——Reboot简介





strstr和strcchr的区别
strstr 显示第一次找到，要查找的字符串，以及后面的字符串。 
strrchr 显示最后一次找到，要查找的字符串，以及后面的字符串。
<?php 
$email = 'test@test.com@jb51.net'; 
$domain = strstr($email, '@'); 
echo "strstr 测试结果 $domain<br>"; 
$domain = strrchr($email, '@'); 
echo "strrchr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 @test.com@jb51.net 
strrchr 测试结果 @jb51.net

strstr与stristr的区别
<?php $email = 'zhangYingy@jb51.net'; 
$domain = stristr($email, 'y'); 
echo "strstr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 y@jb51.net
stristr 测试结果 Yingy@jb51.net

substr用法：
<?php $email = 'zhangYingy@jb51.net'; 
$domain = substr($email, 6); 
echo "substr 测试结果 $domain<br>"; 
?>
结果如下：
substr 测试结果 ingy@jb51.net

php默认变量
echo __FILE__;//这是文件完整的地址为：D:\wamp\wamp\apps\think\test.php
echo __LINE__;//显示这一句所在的行数
echo PHP_VERSION;//显示php版本
echo PHP_OS; //显示php运行系统名称
echo TRUE;  //1,同理FALSE结果为0
echo E_ERROR;
echo "<br>";
//可以用define函数自定义默认变量
define('COPYRIGHT','Copyright');
echo COPYRIGHT;

$testa=array('0'=>array('id'=>14),'1'=>array('id'=>23),'3'=>array('id'=>32));
array_slice($testa,1-1,'id');
var_dump($testa);exit;
用array_slice()可以更换数组的键名，不过如果键名相同，数组会自动添加新的键名，结果会是这样；
array (size=3)
  0 => 
    array (size=1)
      'id' => int 14
  1 => 
    array (size=1)
      'id' => int 23
  3 => 
    array (size=1)
      'id' => int 32


jquery中attr()使用
<script>                                  //用attr设置属性值
$("ul li:eq(1)").attr("title","不吃橘子");
alert($("ul li:eq(1)").attr("title"));
</script>
                                          //用attr删除属性值
<script>
$("ul li:eq(1)").removeAttr ("title");
</script>

urlencode()函数：
本函数将字符串以 URL 编码。例如空格就会变成加号。
Homepage 中 form 资料传送就是用 urlencode 编码后再送出。

array_multisort()这个函数：
有时候我们需要对二维数组的某个键的值进行排序，这里就是讨论这个问题。
我们可以使用array_multisort()这个函数。array_multisort() 函数对多个数组或多维数组进行排序。

list() 函数:
list() 函数用数组中的元素为一组变量赋值。
注意，与 array() 类似，list() 实际上是一种语言结构，不是函数。
<?php
	$my_array = array("Dog","Cat","Horse");
	list($a, , $c) = $my_array;
	echo "Here I only use the $a and $c variables.";
?>  
运行结果： Here I only use the Dog and Horse variables.

number_format() 函数:
number_format() 函数通过千位分组来格式化数字。
<?php
$num = 500000;

echo number_format($num);
// 500,000

echo number_format($num, 2);
// 500,000.00

echo number_format($num, 3, ".", ",");
// 500,000.000
?>

parse_url()函数:
parse_url() 函数可以解析 URL，返回其组成部分。它的用法如下：
array = parse_url( string url );
<?php 
  $url="http://www.nowmagic.net/welcome/";
  $parts=parse_url($url);
  print_r($parts);
?>
结果是：Array ( [scheme] => http [host] => www.nowmagic.net [path] => /welcome/ )  ;

strip_tags()函数:
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果是：Hello NowaMagic!

is_numeric函数：
is_numeric检测变量是否为数字或数字字符串

shuffle（）函数：将数组随机打乱
<?php 
  $data=array('111','222','333','444','555','666');
  shuffle($data);
  print_r($data);
  结果是：Array ( [0] => 222 [1] => 555 [2] => 333 [3] => 111 [4] => 444 [5] => 666 ) 
?>

http_bluid_query()函数：将数组变成url
<?php 
  $data = array(
   'site'=>'www.nowamagic.net', 
	'foo'=>'bar', 
	'baz'=>'boom', 	
	'name'=>'nowamagic'); 
  echo http_build_query($data); 
?>
结果为：site=www.nowamagic.net&foo=bar&baz=boom&name=nowamagic

stream_context_create()函数：
stream_context_create() 作用：创建并返回一个文本数据流并应用各种选项，
可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。

php查看本地目录glob()和scandir()
glob()函数
$img=array('gif','png','jpg');
$dir='img/';  //查找的文件名所在目录
$pic=array();
foreach($img as $k=>$v){
	$pattern=$dir.'*.'.$v;
	$all=glob($pattern);
	$pic=array_merge($pic,$all);
}
var_dump($pic);
foreach($pic as $p){
echo $p.'<br>';
}
上面的等同于：
$files=glob('img/*.jpg');
print_r($files);

结果均为：
array (size=2)
  0 => string 'img/test.jpg' (length=12)
  1 => string 'img/test2.jpg' (length=13)

scandir()函数：
$dir='img/';
$file=scandir($dir);
print_r($file);

结果为：
Array ( [0] => . [1] => .. [2] => test.jpg [3] => test2.jpg ) 


序列化与反序列化
序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这
两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 
PHP中的序列化和反序列化分别通过函数serialize()和unserialize()即可实现。
serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将serialize的返回结果作为参数，进行反序列化，得到原对象。

json_encode()与json_decode()
这是PHP的原生函数，然而在今天JSON越来越流行，所以在PHP5.2以后，
PHP开始支持JSON，你可以使用 json_encode() 和 json_decode() 函数


文件压缩的原理：
电脑是采用二进制的，所以就全是1和0两个数字。那么难免的有的时候会重复出现，比如：10101010101010101010101010101010，那么就是16个10于是压缩的时候就记做16个10。
然后我们把16换算为二进制的，就是1000。那么电脑就会写成100010。当然，这其中一定还会有一些记号。只是我不太清楚而已。然后在解压的时候就可以把100010还原为10101010101010101010101010101010。
那么一算，就把本来的32位的数字变为了6位。所以就达到了压缩的目的！
php字符串压缩与解压缩：

php扫描本地目录与文件：
header('content-type:text/html; charset=utf-8');
   $dirname='Public'; //要遍历的目录名字
   $dir_handle=opendir($dirname);
    echo '<table border="1" align="center" width="960px" cellspacing="0" cellpadding="0">';
   echo '<caption><h2>目录'.$dirname.'下面的内容</h2></caption>';
   echo '<tr align="left" bgcolor="#cccccc">';
   echo '<th>文件名</th><th>文件大小</th><th>文件类型</th><th>修改时间</th><th>完整路径</th><th>test1</th><th>test2</th></tr>';
   while($file=readdir($dir_handle))
   {
     if($file!="."&&$file!="..")
     {
        $dirFile=$dirname."/".$file;	
        echo '<td>'.$file.'</td>';
        echo '<td>'.filesize($dirFile).'</td>';
        echo '<td>'.filetype($dirFile).'</td>';
        echo '<td>'.date("Y/n/t",filemtime($dirFile)).'</td>';
		echo '<td>'.$dirFile.'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filectime($dirFile)).'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filemtime($dirFile)).'</td>';
        echo '</tr>';
     }
   }
   echo '</table>';
   closedir($dir_handle);

filectime — 取得文件的 inode 修改时间
filemtime — 取得文件修改时间
fileatime — 取得文件上次访问时间
fileperms -- 取得文件的访问权限
is_executable — 判断给定文件名是否可执行


PHP/Mysql中几个版本的进化史，比如mysql4.0到4.1，PHP 4.x到5.1的重大改进等等：
MySQL：  
一、从 4.0 到 4.1 的主要变化  
  
如果在4.1.0到4.1.3版本的MySQL中创建了包含 TIMESTAMP 字段的 InnoDB表。则在升级到4.1.4及更高时需要重建表，因为存储格式发生变化了。  
  
字符串根据标准SQL来比较：比较之前不删除末尾的空格，以前用末尾空格扩展了比较短的字符串。现在的结果是  
  
'a' > 'a\t'，以前则不这样。可以用 mysqlcheck 来检查一下数据表。  
  
TIMESTAMP 返回 'YYYY-MM-DD HH:MM:SS' 格式的字符串。在MySQL 4.0中，可以增加选项 --new 来获得ySQL 4.1中这方面的特性。  
  
在MySQL4.1.1前，语句解析器不是那么严格，它在处理字符串转时间转换时会忽略第一个数字前的其他字符。在4.1.1之后，就比较严格了，返回结果是 DATE, DATETIME, 或 TIME 类型的函数的结果会被转换成时间型  
  
二、再看从 4.1 到 5.0 的主要变化  
  
◆InnoDB 和 MyISAM 表中空格结尾的 TEXT 字段索引顺序改变了。因此需要运行"CHECK TABLE" 语句修复数据表，如果出现错误，就运行 "OPTIMIZE TABLE" 或 "REPAIR TABLE" 语句修复，甚至重新转储(用mysqldump)。  
  
◆MySQL 5.0.15开始，如何处理 BINARY 字段中填充的值已经改变了。填充的值现在是0x00 而非空格了，并且在取值的时候不会去除末尾的空格。  
  
◆从MySQL 5.0.3开始，DECIMAL 的实现方式已经改变了，5.0对 DECIMAL的格式限制严格多了。在MySQL 5.0.3到5.0.5之间版本的 MyISAM 和 InnoDB 表中创建的 DECIMAL字段升级到5.0.6之后会发生崩溃。从5.0.3开始，DECIMAL 用更有效的格式来存储。5.0.3开始，在计算 DECIMAL 值和舍入精确值的时候采用精确数学。  
  
◆在以前，等待超时的锁会导致 InnoDB回滚当前全部事务，从5.0.13开始，就只回滚最近的SQL语句了。  
  
◆在4.1.13/5.0.8以前，DATETIME 的加0后就转换成 YYYYMMDDHHMMSS 格式，现在变为YYYYMMDDHHMMSS.000000 格式了  
  
◆4.1中，FLOAT 或 DOUBLE 之间的比较碰巧没问题，但在5.0中可能就不行了  
  
◆从5.0.3开始，VARCHAR 和 VARBINARY 字段中末尾的空格不再删除  
  
◆增加了一个新的启动选项 innodb_table_locks，它导致 LOCK TABLE 时也可以请求InnoDB 表锁。这个选项默认打开，不过可能在 AUTOCOMMIT=1 和 LOCK TABLES应用中会导致死锁。看来，我只需主要关注 时间(TIMESTAMP, DATETIME< DATE, TIME) 和数值型(FLOAD, DOUBLE, DECIMAL) 这两种类型的变化;另外，我升级过程中暂时还不需要涉及到字符集问题，因此相对轻松一些。  
  
升级步骤如下：  
  
执行  
  
FLUSH TABLES WITH READ LOCK;  
  
直接拷贝 MyISAM 表文件  
  
用 mysqldump 导出 Innodb 类型的表  
  
整个过程都很顺利，新系统启动之后，发现如下2个问题：  
  
新增了关键字 INOUT，因此需要检查表结构中还有其他什么字段使用关键字了  
  
DATE_FORMAT 函数要求严谨多了，  
  
DATE_FORMAT('2006/11/24 09:14:00', '%Y-%m-%d %T')   
和DATE_FORMAT('2006/11/2409:14:00', '%Y-%m-%d %T')  
  
的结果完全不一样，在 4.0 中，能兼容这两种格式，而在 5.0 中，只能正确的使用前者了，后者则会有问题。这也应该是上面提到的时间类型发生的变化所致。  

PHP5以下几个改进值得关注：  
1、极大地提高了面向对象能力；  
2、支持try/catch异常处理；  
3、改进了字符串地处理；  
4、改经了xml和web服务支持；  
5、对SQlite内置支持。  

一些php魔幻方法;
php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。  
PHP中的魔术方法有 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone, __autoload  
1、__get、__set  
这两个方法是为在类和他们的父类中没有声明的属性而设计的  
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名  
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值  
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）。  
2、__isset、__unset  
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法  
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法  
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）  
3、__call  
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法  
这里的未定义的方法包括没有权限访问的方法；如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方​法，如果本类中不存在__call()方法就去找父类中的__call()方法  
  
4、__autoload  
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。  
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：  
view plaincopy to clipboardprint?  
<?php    
class Loader    
{    
static function autoload_class($class_name)    
{    
//寻找正确的$class_name类，并引入，没有则抛出异常    
}    
}    
    
/** 
*   设置对象的自动载入 
*   spl_autoload_register — Register given function as __autoload() implementation 
*/    
spl_autoload_register(array('Loader', 'autoload_class'));    
    
$a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类    
    
?>    
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。  
5、__construct、__destruct  
__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称  
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。  
在一个函数的命名空间内，这会发生在函数return的时候。  
对于全局变量,这发生于脚本结束的时候。  
如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.  
6、__clone  
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。  
7、__toString  
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。  
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in  
此方法必须返回一个字符串。  
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。  
8、__sleep、__wakeup  
__sleep 串行化的时候用  
__wakeup 反串行化的时候调用  
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。  
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。  
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。  
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。  
9、__set_state  
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。  
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。  
10、__invoke  
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。  
PHP5.3.0以上版本有效  
11、__callStatic  
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，  
PHP5.3.0以上版本有效  
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此  

使用POSIX兼容规则的函数有：  
ereg_replace()  
ereg()  
eregi()  
eregi_replace()  
split()  
spliti()  
sql_regcase()  
mb_ereg_match()  
mb_ereg_replace()  
mb_ereg_search_getpos()  
mb_ereg_search_getregs()  
mb_ereg_search_init()  
mb_ereg_search_pos()  
mb_ereg_search_regs()  
mb_ereg_search_setpos()  
mb_ereg_search()  
mb_ereg()  
mb_eregi_replace()  
mb_eregi()  
mb_regex_encoding()  
mb_regex_set_options()  
mb_split()  
  
使用PERL兼容规则的函数有：  
preg_grep()  
preg_replace_callback()  
preg_match_all()  
preg_match()  
preg_quote()  
preg_split()  
preg_replace()  

写代码来解决多进程/线程同时读写一个文件的问题：
大家都知道，PHP是没有多线程概念的，尽管如此我们仍然可以用“不完美”的方法来模拟多线程。简单的说，就是队列处理。通过对文件进行加锁和解锁，来实现。当一个文件被一个用户操作时，该文件是被锁定的，其他用户只能等待，确实不够完美，但是也可以满足一些要求不高的应用。  
function T_put($filename,$string){  
$fp = fopen($filename,’a'); //追加方式打开  
if (flock($fp, LOCK_EX)){ //加写锁  
fputs($fp,$string); //写文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
}  
function T_get($filename,$length){  
$fp = fopen($filename,’r'); //追加方式打开  
if (flock($fp, LOCK_SH)){ //加读锁  
$result = fgets($fp,$length); //读取文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
return $result;  
}  

MyISAM 与Innodb
简单的表达。  
MyISAM 是非事务的存储引擎。  
innodb 是支持事务的存储引擎。  
  
innodb    的引擎比较适合于插入和更新操作比较多的应用  
而MyISAM  则适合用于频繁查询的应用  
  
MyISAM    --表锁。  
innodb    --设计合理的话是行锁。  
MyISAM    不会出现死锁。  
  
最大的区别就是MYISAM适合小数据，小并发；INNODB 适合大数据，大并发。最大的区别就是在锁的级别上。  
  
MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。综述，就可以根据数据表不同的用处是用不同的存储类型。而且MyISAM是文件存储的，可以进行直接在不同操作系统间拷贝使用。  
   
InnoDB：  
InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。InnoDB 提供了行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)。这些特性均提高了多用户并发操作的性能表现。在InnoDB表中不需要扩大锁定(lock escalation)，因为 InnoDB 的列锁定(row level locks)适宜非常小的空间。InnoDB 是 MySQL 上第一个提供外键约束(FOREIGN KEY constraints)的表引擎。InnoDB 的设计目标是处理大容量数据库系统，它的 CPU 利用率是其它基于磁盘的关系数据库引擎所不能比的。在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 InnoDB 把数据和索引存放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 MyISAM 中，表被存放在单独的文件中。InnoDB 表的大小只受限于操作系统的文件大小，一般为 2 GB。InnoDB所有的表都保存在同一个数据文件 ibdata1 中（也可能是多个文件，或者是独立的表空间文件），相对来说比较不好备份，可以拷贝文件或用navicat for mysql。  
   
MyISAM  
每张MyISAM 表被存放在三个文件 ：frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex) 引伸。  
因为MyISAM相对简单所以在效率上要优于InnoDB，小型应用使用MyISAM是不错的选择。  
MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦  

2.web 架构，安全,项目经验

介绍xdebug,apc,eAccelerator,Xcache,Zend opt的使用经验。
使用mod_rewrite,在服务器上没有/archivers/567.html这个物理文件时，重定向到index.php?id=567 ,请先打开mod_rewrite.
MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？
写出一种排序算法（原理），并说出优化它的方法。
请简单阐述您最得意的开发之作
对于大流量的网站,您采用什么样的方法来解决各页面访问量统计问题
您是否用过模板引擎? 如果有您用的模板引擎的名字是?
请介绍Session的原理,大型网站中Session方面应注意什么?
测试php性能和mysql数据库性能的工具,和找出瓶颈的方法。
正则提出一个网页中的所有链接.
介绍一下常见的SSO(单点登陆)方案(比如dedecms整合discuz的passport)的原理。
您写过的PHP框架的特点，主要解决什么问题，与其他框架的不同点。
大型的论坛/新闻文章系统/SNS网站在性能优化上有什么区别?
相册类应用:要求在浏览器中能同时选中并上传多个文件，图片要求能剪裁，压缩包在服务器端解压。能上传单个达50M的文件。上传过程中有进度条显示。每个图片能生成四种大小缩略图，视频文件要转成flv供flash播放。叙述要涉及的各类开源软件和简单用途。
一 群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的 进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。用程序模拟该过程。

3. unix/linux 基本使用

linux下查看当前系统负载信息的一些方法。
vim的基本快捷键。
ssh 安全增强方法;密码方式和rsa key 方式的配置。
rpm/apt/yum/ports 装包，查询，删除的基本命令。
Makefile的基本格式，gcc 编译，连接的命令,-O0 和-O3区别。
gdb,strace,valgrind的基本使用.

4. 前端,HTML,JS

css盒模型。
javascript中的prototype。
javascript中this对象的作用域。
IE和firefox事件冒泡的不同。
什么是怪异模式,标准模式，近标准模式。
DTD的定义
IE/firefox常用hack.
firefox,IE下的前端js/css调试工具。




 public function search(){
            $map['tel'] = array('LIKE' , '%'.$_GET['tel'].'%');//模糊          
              if(empty($map['ctime'])){
                    if (isset($_GET['ctimes'])) {
                          $map['ctime'][] = array('EGT',strtotime($_GET['ctimes']));
                          $pamap['ctimes'] = $_GET['ctimes'];
                    }
                    if (isset($_GET['ctimee'])) {
                          $map['ctime'][] = array('ELT',strtotime($_GET['ctimee']));
                          $pamap['ctimee'] = $_GET['ctimee'];
                     }
              }
            $list = paging('tel_message', $map, true, '30', 'id desc',$pamap);              
            foreach ($list['list'] as $k => $val) {
            $arr[] = $val;
            }
            $Model=D('Telmessage');
            $array=$Model->getData();
            foreach($arr as $num=>$value){
                    $arr[$num]['ctime']=date('Y-m-d H:i:s',$arr[$num]['ctime']);
                 }       
            $this->assign('count',$array['count']); 
            $this->assign('_page', $list['show']);           
            $this->assign('arrcount', $arrcount);
            $this->assign('data',$arr);
            $this->display('index');
     }
    
php近1000个系统函数：
Abs: 取得绝对值。
Acos: 取得反余弦值。
ada_afetch: 取得数据库的返回列。
ada_autocommit: 开关自动改动功能。
ada_close: 关闭 Adabas D 链接。
ada_commit: 改动 Adabas D 数据库。
ada_connect: 链接至 Adabas D 数据库。
ada_exec: 执行 SQL 指令。
ada_fetchrow: 取得返回一列。
ada_fieldname: 取得字段名称。
ada_fieldtype: 取得字段资料类型。
ada_freeresult: 释出返回资料的内存。
ada_numfields: 取得字段数目。
ada_numrows: 取得返回列数目。
ada_result: 取得返回资料。
ada_resultall: 返回 HTML 表格资料。
ada_rollback: 撤消当前交易。
AddSlashes: 字符串加入斜线。
apache_lookup_uri: 获得所有的 URI 相关信息。
apache_note: 获得及配置apache服务器的请求纪录。
array: 建立一个新的数组。
array_walk: 让使用者自订函数能处理数组中的每一个元素。
arsort: 将数组的值由大到小排序。
Asin: 取得反正弦值。
asort: 将数组的值由小到大排序。
aspell_check: 检查一个单字。
aspell_check-raw: 检查一个单字，即使拼错也不改变或修正。
aspell_new: 载入一个新的字典。
aspell_suggest: 检查一个单字，并提供拼写建议。
Atan: 取得反正切值。
Atan2: 计算二数的反正切值。
base64_decode: 将 BASE64 编码字符串解码。
base64_encode: 将字符串以 BASE64 编码。
basename: 返回不含路径的文件字符串。
base_convert: 转换数字的进位方式。
bcadd: 将二个高精确度数字相加。
bccomp: 比较二个高精确度数字。
bcdiv: 将二个高精确度数字相除。
bcmod: 取得高精确度数字的余数。
bcmul: 将二个高精确度数字相乘。
bcpow: 求一高精确度数字次方值。
bcscale: 配置程序中所有 BC 函数库的默认小数点位数。
bcsqrt: 求一高精确度数字的平方根。
bcsub: 将二个高精确度数字相减。
bin2hex: 二进位转成十六进位。
BinDec: 二进位转成十进位。
Ceil: 计算大于指定数的最小整数。
chdir: 改变目录。
checkdate: 验证日期的正确性。
checkdnsrr: 检查指定网址的 DNS 记录。
chgrp: 改变文件所属的群组。
chmod: 改变文件的属性。
Chop: 去除连续空白。
chown: 改变文件的拥有者。
Chr: 返回序数值的字符。
chunk_split: 将字符串分成小段。
clearstatcache: 清除文件状态快取。
closedir: 关闭目录 handle。
closelog: 关闭系统纪录。
connection_aborted: 若链接中断则返回 true。
connection_status: 取得连接状态。
connection_timeout: 若超过 PHP 程序执行时间则返回 true。
convert_cyr_string: 转换古斯拉夫字符串成其它字符串。
copy: 复制文件。
Cos: 余弦计算。
count: 计算变量或数组中的元素个数。
crypt: 将字符串用 DES 编码加密。
current: 返回数组中目前的元素。
date: 将服务器的时间格式化。
dbase_add_record: 加入资料到 dBase 资料表。
dbase_close: 关闭 dBase 资料表。
dbase_create: 建立 dBase 资料表。
dbase_delete_record: 删除 dBase 资料表的资料。
dbase_get_record: 取得 dBase 资料表的资料。
dbase_numfields: 取得 dBase 资料表的字段数。
dbase_numrecords: 取得 dBase 资料表的列数。
dbase_open: 打开 dBase 资料表。
dbase_pack: 清理 dBase 资料表。
dba_close: 关闭数据库。
dba_delete: 删除指定资料。
dba_exists: 检查键是否存在。
dba_fetch: 取回指定资料。
dba_firstkey: 取回首笔键值。
dba_insert: 加入资料。
dba_nextkey: 取回下笔键值。
dba_open: 打开数据库链接。
dba_optimize: 最佳化数据库。
dba_popen: 打开并保持数据库链接。
dba_replace: 改动或加入资料。
dba_sync: 数据库同步化。
dblist: 取得 DBM 的信息。
dbmclose: 关闭 DBM 数据库。
dbmdelete: 删除指定资料。
dbmexists: 检查键是否存在。
dbmfetch: 取回指定资料。
dbmfirstkey: 取回首笔键名。
dbminsert: 加入资料。
dbmnextkey: 取回下笔键值。
dbmopen: 打开 DBM 数据库链接。
dbmreplace: 改动或加入资料。
debugger_off: 关闭内建的 PHP 除错器。
debugger_on: 使用内建的 PHP 除错器。
DecBin: 十进位转二进位。
DecHex: 十进位转十六进位。
DecOct: 十进位转八进位。
delete: 无用的项目。
die: 输出信息并中断 PHP 程序。
dir: 目录类别类。
dirname: 取得路径中的目录名。
diskfreespace: 取得目录所在的剩余可用空间。
dl: 载入 PHP 扩充模块。
doubleval: 变量转成倍浮点数类型。
each: 返回数组中下一个元素的索引及值。
easter_date: 计算复活节日期。
easter_days: 计算复活节与三月廿一日之间日期数。
echo: 输出字符串。
empty: 判断变量是否已配置。
end: 将数组的内部指针指到最后的元素。
ereg: 字符串比对解析。
eregi: 字符串比对解析，与大小写无关。
eregi_replace: 字符串比对解析并取代，与大小写无关。
ereg_replace: 字符串比对解析并取代。
error_log: 送出一个错误信息。
error_reporting: 配置错误信息回报的等级。
escapeshellcmd: 除去字符串中的特殊符号。
eval: 将值代入字符串之中。
exec: 执行外部程序。
exit: 结束 PHP 程序。
Exp: 自然对数 e 的次方值。
explode: 切开字符串。
extract: 汇入数组到符号表。
fclose: 关闭已打开的文件。
FDF_close: 关闭 FDF 文件。
FDF_create: 建立新的 FDF 文件。
FDF_get_file: 取得 /F 键的值。
FDF_get_status: 取得 /STATUS 键的值。
FDF_get_value: 取得字段的值。
FDF_next_field_name: 下一字段的名称。
FDF_open: 打开 FDF 文件。
FDF_save: 将 FDF 文件存文件。
FDF_set_ap: 配置显示字段。
FDF_set_file: 配置 /F 键。
FDF_set_status: 配置 /STATUS 键。
FDF_set_value: 配置字段的值。
feof: 测试文件指针是否指到文件尾。
fgetc: 取得文件指针所指的字符。
fgetcsv: 取得文件指针所指行，并解析 CSV 字段。
fgets: 取得文件指针所指的行。
fgetss: 取得文件指针所指的行，并去掉 HTML 语言标记。
file: 将文件全部读入数组变量中。
fileatime: 取得文件最后的存取时间。
filectime: 取得文件最后的改变时间。
filegroup: 取得文件所属的群组。
fileinode: 取得文件的 inode 值。
filemtime: 取得文件最后的修改时间。
fileowner: 取得文件的拥有者。
fileperms: 取得文件的权限配置。
filepro: 读取 FilePro Map 文件。
filepro_fieldcount: 取得字段数目。
filepro_fieldname: 取得字段名称。
filepro_fieldtype: 取得字段类型。
filepro_fieldwidth: 取得字段宽度。
filepro_retrieve: 取得指定储存格资料。
filepro_rowcount: 取得列数目。
filesize: 获得文件的大小。
filetype: 获得文件的类型。
file_exists: 检查文件是否存在。
flock: 锁住文件。
Floor: 计算小于指定数的最大整数。
flush: 清出输出缓冲区。
fopen: 打开文件或者 URL。
fpassthru: 输出所有剩余资料。
fputs: 写到文件指针。
fread: 位组的方式读取文件。
FrenchToJD: 将法国共和历法转换成为凯撒日计数。
fseek: 移动文件指针。
fsockopen: 打开网络的 Socket 链接。
ftell: 取得文件读写指针位置。
ftp_cdup: 回上层目录。
ftp_chdir: 改变路径。
ftp_connect: 打开 FTP 链接。
ftp_delete: 将文件删除。
ftp_fget: 下载文件，并存在已开的文件中。
ftp_fput: 上传已打开文件。
ftp_get: 下载文件。
ftp_login: 登入 FTP 服务器。
ftp_mdtm: 获得指定文件的最后修改时间。
ftp_mkdir: 建新目录。
ftp_nlist: 列出指定目录中所有文件。
ftp_pasv: 切换主被动传输模式。
ftp_put: 上传文件。
ftp_pwd: 取得目前所在路径。
ftp_quit: 关闭 FTP 连接。
ftp_rawlist: 详细列出指定目录中所有文件。
ftp_rename: 将文件改名。
ftp_rmdir: 删除目录。
ftp_size: 获得指定文件的大小。
ftp_systype: 显示服务器系统。
function_exists: 检查函数是否已定义。
fwrite: 二进位位方式写入文件。
getallheaders: 获得所有 HTTP 变量值。
getdate: 获得时间及日期信息。
getenv: 取得系统的环境变量
gethostbyaddr: 返回机器名称。
gethostbyname: 返回 IP 网址。
gethostbynamel: 返回机器名称的所有 IP。
GetImageSize: 取得图片的长宽。
getlastmod: 返回该网页的最后修改时间。
getmxrr: 取得指定网址 DNS 记录之 MX 字段。
getmyinode: 返回该网页的 inode 值。
getmypid: 返回 PHP 的行程代号。
getmyuid: 返回 PHP 的使用者代码。
getrandmax: 随机数的最大值。
getrusage: 返回系统资源使用率。
gettimeofday: 取得目前时间。
gettype: 取得变量的类型。
get_cfg_var: 取得 PHP 的配置选项值。
get_current_user: 取得 PHP 行程的拥有者名称。
get_magic_quotes_gpc: 取得 PHP 环境变量 magic_quotes_gpc 的值。
get_magic_quotes_runtime: 取得 PHP 环境变量 magic_quotes_runtime 的值。
get_meta_tags: 抽出文件所有 meta 标记的资料。
gmdate: 取得目前与 GMT 差后的时间。
gmmktime: 取得 UNIX 时间戳记的格林威治时间。
GregorianToJD: 将格里高里历法转换成为凯撒日计数。
gzclose: 关闭压缩文件。
gzeof: 判断是否在压缩文件尾。
gzfile: 读压缩文件到数组中。
gzgetc: 读压缩文件中的字符。
gzgets: 读压缩文件中的字符串。
gzgetss: 读压缩文件中的字符串，并去掉 HTML 指令。
gzopen: 打开压缩文件。
gzpassthru: 解压缩指针后全部资料。
gzputs: 资料写入压缩文件。
gzread: 压缩文件读出指定长度字符串。
gzrewind: 重设压缩文件指针。
gzseek: 设压缩文件指针至指定处。
gztell: 取得压缩文件指针处。
gzwrite: 资料写入压缩文件。
header: 送出 HTTP 协议的标头到浏览器
HexDec: 十六进位转十进位。
htmlentities: 将所有的字符都转成 HTML 字符串。
htmlspecialchars: 将特殊字符转成 HTML 格式。
hw_Children: 取得子类代码。
hw_ChildrenObj: 取得子类的类记录。
hw_Close: 关闭 Hyperwave 连接。
hw_Connect: 连上 Hyperwave 服务器。
hw_Cp: 复制类。
hw_Deleteobject: 删除类。
hw_DocByAnchor: 取得指定锚的文件类代码。
hw_DocByAnchorObj: 取得指定锚的文件类。
hw_DocumentAttributes: 取得指定文件类属性。
hw_DocumentBodyTag: 取得指定文件类的文件主体标记。
hw_DocumentContent: 取得指定文件类的内容。
hw_DocumentSetContent: 重设指定文件类的内容。
hw_DocumentSize: 取得文件大小。
hw_EditText: 改动文字档宁。
hw_Error: 取得错误代码。
hw_ErrorMsg: 取得错误信息。
hw_Free_Document: 释放文件使用的内存。
hw_GetAnchors: 取得文件的链接锚。
hw_GetAnchorsObj: 取得文件的链接锚记录。
hw_GetAndLock: 取得并锁住类。
hw_GetChildColl: 取得子类们的 ID。
hw_GetChildCollObj: 取得子类们的资料。
hw_GetChildDocColl: 取得全部子文件聚集。
hw_GetChildDocCollObj: 取得全部子文件聚集记录。
hw_GetObject: 取得类。
hw_GetObjectByQuery: 搜寻类。
hw_GetObjectByQueryColl: 搜寻聚集类。
hw_GetObjectByQueryCollObj: 搜寻聚集类。
hw_GetObjectByQueryObj: 搜寻类。
hw_GetParents: 取得父类的 ID。
hw_GetParentsObj: 取得父类的资料。
hw_GetRemote: 取得远端文件。
hw_GetRemoteChildren: 取得远端的子文件。
hw_GetSrcByDestObj: 取得指定目的的文件内容。
hw_GetText: 取得纯文字档宁。
hw_GetUsername: 目前使用者名字。
hw_Identify: 使用者身份确认。
hw_InCollections: 检查类聚集。
hw_Info: 连接信息。
hw_InsColl: 插入聚集。
hw_InsDoc: 插入文件。
hw_InsertDocument: 上传文件。
hw_InsertObject: 插入类记录。
hw_Modifyobject: 修改类记录。
hw_Mv: 移动类。
hw_New_Document: 建立新文件。
hw_Objrec2Array: 类记录转为数组。
hw_OutputDocument: 输出文件。
hw_pConnect: 连上 Hyperwave 服务器。
hw_PipeDocument: 取得文件。
hw_Root: 取得根类代码。
hw_Unlock: 取消锁定。
hw_Who: 列出目前使用者。
ibase_bind: 链接 PHP 变量到 InterBase 参数。
ibase_close: 关闭 InterBase 服务器连接。
ibase_connect: 打开 InterBase 服务器连接。
ibase_execute: 执行 SQL 的指令部分。
ibase_fetch_row: 返回单列的各字段。
ibase_free_query: 释放查询指令占用内存。
ibase_free_result: 释放返回占用内存。
ibase_pconnect: 保持 InterBase 服务器连接。
ibase_prepare: 分析 SQL 语法。
ibase_query: 送出一个 query 字符串。
ibase_timefmt: 配置时间格式。
ifxus_close_slob: 删除 slob 类。
ifxus_create_slob: 建立 slob 类。
ifxus_open_slob: 打开 slob 类。
ifxus_read_slob: 读取指定数目的 slob 类。
ifxus_seek_slob: 配置目前文件或找寻位置。
ifxus_tell_slob: 返回目前文件或找寻位置。
ifxus_write_slob: 将字符串写入 slob 类中。
ifx_affected_rows: 得到 Informix 最后操作影响的列数目。
ifx_blobinfile_mode: 配置长位类模式。
ifx_byteasvarchar: 配置位组模式默认值。
ifx_close: 关闭 Informix 服务器连接。
ifx_connect: 打开 Informix 服务器连接。
ifx_copy_blob: 复制长位类。
ifx_create_blob: 建立长位类。
ifx_create_char: 建立字符类。
ifx_do: 执行已准备 query 字符串。
ifx_error: 取得 Informix 最后的错误。
ifx_errormsg: 取得 Informix 最后错误信息。
ifx_fetch_row: 返回单列的各字段。
ifx_fieldproperties: 列出 Informix 的 SQL 字段属性。
ifx_fieldtypes: 列出 Informix 的 SQL 字段。
ifx_free_blob: 删除长位类。
ifx_free_char: 删除字符类。
ifx_free_result: 释放返回占用内存。
ifx_free_slob: 删除 slob 类。
ifx_getsqlca: 取得 query 后的 sqlca 信息。
ifx_get_blob: 取得长位类。
ifx_get_char: 取得字符类。
ifx_htmltbl_result: 将 query 返回资料转成 HTML 表格。
ifx_nullformat: 配置空字符模式默认值。
ifx_num_fields: 取得返回字段的数目。
ifx_num_rows: 取得返回列的数目。
ifx_pconnect: 打开 Informix 服务器持续连接。
ifx_prepare: 准备 query 字符串。
ifx_query: 送出一个 query 字符串。
ifx_textasvarchar: 配置文字模式默认值。
ifx_update_blob: 更改长位类。
ifx_update_char: 更改字符类。
ignore_user_abort: 连接中断后程序是否执行。
ImageArc: 画弧线。
ImageChar: 写出横向字符。
ImageCharUp: 写出直式字符。
ImageColorAllocate: 匹配颜色。
ImageColorAt: 取得图中指定点颜色的索引值。
ImageColorClosest: 计算色表中与指定颜色最接近者。
ImageColorExact: 计算色表上指定颜色索引值。
ImageColorResolve: 计算色表上指定或最接近颜色的索引值。
ImageColorSet: 配置色表上指定索引的颜色。
ImageColorsForIndex: 取得色表上指定索引的颜色。
ImageColorsTotal: 计算图的颜色数。
ImageColorTransparent: 指定透明背景色。
ImageCopyResized: 复制新图并调整大小。
ImageCreate: 建立新图。
ImageCreateFromGIF: 取出 GIF 图型。
ImageCreateFromPNG: 取出 PNG 图型。
ImageDashedLine: 绘虚线。
ImageDestroy: 结束图形。
ImageFill: 图形着色。
ImageFilledPolygon: 多边形区域着色。
ImageFilledRectangle: 矩形区域着色。
ImageFillToBorder: 指定颜色区域内着色。
ImageFontHeight: 取得字型的高度。
ImageFontWidth: 取得字型的宽度。
ImageGIF: 建立 GIF 图型。
ImageInterlace: 使用交错式显示与否。
ImageLine: 绘实线。
ImageLoadFont: 载入点阵字型。
ImagePNG: 建立 PNG 图型。
ImagePolygon: 绘多边形。
ImagePSBBox: 计算 PostScript 文字所占区域。
ImagePSEncodeFont: PostScript 字型转成向量字。
ImagePSFreeFont: 卸下 PostScript 字型。
ImagePSLoadFont: 载入 PostScript 字型。
ImagePSText: 写 PostScript 文字到图中。
ImageRectangle: 绘矩形。
ImageSetPixel: 绘点。
ImageString: 绘横式字符串。
ImageStringUp: 绘直式字符串。
ImageSX: 取得图片的宽度。
ImageSY: 取得图片的高度。
ImageTTFBBox: 计算 TTF 文字所占区域。
ImageTTFText: 写 TTF 文字到图中。
imap_8bit: 将八位转成 qp 编码。
imap_alerts: 所有的警告信息。
imap_append: 附加字符串到指定的邮箱中。
imap_base64: 解 BASE64 编码。
imap_binary: 将八位转成 base64 编码。
imap_body: 读信的内文。
imap_check: 返回邮箱信息。
imap_clearflag_full: 清除信件标志。
imap_close: 关闭 IMAP 链接。
imap_createmailbox: 建立新的信箱。
imap_delete: 标记欲删除邮件。
imap_deletemailbox: 删除既有信箱。
imap_errors: 所有的错误信息。
imap_expunge: 删除已标记的邮件。
imap_fetchbody: 从信件内文取出指定部分。
imap_fetchheader: 取得原始标头。
imap_fetchstructure: 获取某信件的结构信息。
imap_getmailboxes: 取得全部信件详细信息。
imap_getsubscribed: 列出所有订阅邮箱。
imap_header: 获取某信件的标头信息。
imap_headers: 获取全部信件的标头信息。
imap_last_error: 最后的错误信息。
imap_listmailbox: 获取邮箱列示。
imap_listsubscribed: 获取订阅邮箱列示。
imap_mailboxmsginfo: 取得目前邮箱的信息。
imap_mail_copy: 复制指定信件到它处邮箱。
imap_mail_move: 移动指定信件到它处邮箱。
imap_msgno: 列出 UID 的连续信件。
imap_num_msg: 取得信件数。
imap_num_recent: 取得新进信件数。
imap_open: 打开 IMAP 链接。
imap_ping: 检查 IMAP 是否连接。
imap_qprint: 将 qp 编码转成八位。
imap_renamemailbox: 更改邮箱名字。
imap_reopen: 重开 IMAP 链接。
imap_rfc822_parse_adrlist: 解析电子邮件位址。
imap_rfc822_write_address: 电子邮件位址标准化。
imap_scanmailbox: 寻找信件有无特定字符串。
imap_search: 搜寻指定标准的信件。
imap_setflag_full: 配置信件标志。
imap_sort: 将信件标头排序。
imap_status: 目前的状态信息。
imap_subscribe: 订阅邮箱。
imap_uid: 取得信件 UID。
imap_undelete: 取消删除邮件标记。
imap_unsubscribe: 取消订阅邮箱。
implode: 将数组变成字符串。
intval: 变量转成整数类型。
iptcparse: 使用 IPTC 模块解析位资料。
isset: 判断变量是否已配置。
is_array: 判断变量类型是否为数组类型。
is_dir: 测试文件是否为目录。
is_double: 判断变量类型是否为倍浮点数类型。
is_executable: 测试文件是否为可执行文件。
is_file: 测试文件是否为正常文件。
is_float: 判断变量类型是否为浮点数类型。
is_int: 判断变量类型是否为整数类型。
is_integer: 判断变量类型是否为长整数类型。
is_link: 测试文件是否为链接文件。
is_long: 判断变量类型是否为长整数类型。
is_object: 判断变量类型是否为类类型。
is_readable: 测试文件是否可读取。
is_real: 判断变量类型是否为实数类型。
is_string: 判断变量类型是否为字符串类型。
is_writeable: 测试文件是否可写入。
JDDayOfWeek: 返回日期在周几。
JDMonthName: 返回月份名。
JDToFrench: 将凯撒日计数转换成为法国共和历法。
JDToGregorian: 将凯撒日计数 (Julian Day Count) 转换成为格里高里历法 (Gregorian date)。
JDToJewish: 将凯撒日计数转换成为犹太历法。
JDToJulian: 将凯撒日计数转换成为凯撒历法。
JewishToJD: 将犹太历法转换成为凯撒日计数。
join: 将数组变成字符串。
JulianToJD: 将凯撒历法转换成为凯撒日计数。
key: 取得数组中的索引资料。
ksort: 将数组的元素依索引排序。
ldap_add: 增加 LDAP 名录的条目。
ldap_bind: 系住 LDAP 目录。
ldap_close: 结束 LDAP 链接。
ldap_connect: 连上 LDAP 服务器。
ldap_count_entries: 搜寻结果的数目。
ldap_delete: 删除指定资源。
ldap_dn2ufn: 将 dn 转成易读的名字。
ldap_explode_dn: 切开 dn 的字段。
ldap_first_attribute: 取得第一笔资源的属性。
ldap_first_entry: 取得第一笔结果代号。
ldap_free_result: 释放返回资料内存。
ldap_get_attributes: 取得返回资料的属性。
ldap_get_dn: 取得 DN 值。
ldap_get_entries: 取得全部返回资料。
ldap_get_values: 取得全部返回值。
ldap_list: 列出简表。
ldap_modify: 改变 LDAP 名录的属性。
ldap_mod_add: 增加 LDAP 名录的属性。
ldap_mod_del: 删除 LDAP 名录的属性。
ldap_mod_replace: 新的 LDAP 名录取代旧属性。
ldap_next_attribute: 取得返回资料的下笔属性。
ldap_next_entry: 取得下一笔结果代号。
ldap_read: 取得目前的资料属性。
ldap_search: 列出树状简表。
ldap_unbind: 结束 LDAP 链接。
leak: 泄出内存。
link: 建立硬式链接。
linkinfo: 取得链接信息。
list: 列出数组中元素的值。
Log: 自然对数值。
Log10: 10 基底的对数值。
lstat: 取得链接文件相关信息。
ltrim: 去除连续空白。
mail: 寄出电子邮件。
max: 取得最大值。
mcrypt_cbc: 使用 CBC 将资料加/解密。
mcrypt_cfb: 使用 CFB 将资料加/解密。
mcrypt_create_iv: 从随机源将向量初始化。
mcrypt_ecb: 使用 ECB 将资料加/解密。
mcrypt_get_block_size: 取得编码方式的区块大小。
mcrypt_get_cipher_name: 取得编码方式的名称。
mcrypt_get_key_size: 取得编码钥匙大小。
mcrypt_ofb: 使用 OFB 将资料加/解密。
md5: 计算字符串的 MD5 哈稀。
mhash: 计算哈稀值。
mhash_count: 取得哈稀 ID 的最大值。
mhash_get_block_size: 取得哈稀方式的区块大小。
mhash_get_hash_name: 取得哈稀演算法名称。
microtime: 取得目前时间的 UNIX 时间戳记的百万分之一秒值。
min: 取得最小值。
mkdir: 建立目录。
mktime: 取得 UNIX 时间戳记。
msql: 送出 query 字符串。
msql_affected_rows: 得到 mSQL 最后操作影响的列数目。
msql_close: 关闭 mSQL 数据库连接。
msql_connect: 打开 mSQL 数据库连接。
msql_createdb: 建立一个新的 mSQL 数据库。
msql_create_db: 建立一个新的 mSQL 数据库。
msql_data_seek: 移动内部返回指针。
msql_dbname: 取得目前所在数据库名称。
msql_dropdb: 删除指定的 mSQL 数据库。
msql_drop_db: 删除指定的 mSQL 数据库。
msql_error: 取得最后错误信息。
msql_fetch_array: 返回数组资料。
msql_fetch_field: 取得字段信息。
msql_fetch_object: 返回类资料。
msql_fetch_row: 返回单列的各字段。
msql_fieldflags: 获得字段的标志。
msql_fieldlen: 获得字段的长度。
msql_fieldname: 返回指定字段的名称。
msql_fieldtable: 获得字段的资料表 (table) 名称。
msql_fieldtype: 获得字段的类型。
msql_field_seek: 配置指针到返回值的某字段。
msql_freeresult: 释放返回占用内存。
msql_free_result: 释放返回占用内存。
msql_listdbs: 列出可用数据库 (database)。
msql_listfields: 列出指定资料表的字段 (field)。
msql_listtables: 列出指定数据库的资料表 (table)。
msql_list_dbs: 列出可用数据库 (database)。
msql_list_fields: 列出指定资料表的字段 (field)。
msql_list_tables: 列出指定数据库的资料表 (table)。
msql_numfields: 取得返回字段的数目。
msql_numrows: 取得返回列的数目。
msql_num_fields: 取得返回字段的数目。
msql_num_rows: 取得返回列的数目。
msql_pconnect: 打开 mSQL 服务器持续连接。
msql_query: 送出一个 query 字符串。
msql_regcase: 将字符串逐字返回大小写字符。
msql_result: 取得查询 (query) 的结果。
msql_selectdb: 选择一个数据库。
msql_select_db: 选择一个数据库。
msql_tablename: 返回指定资料表的名称。
mssql_affected_rows: 取得最后 query 影响的列数。
mssql_close: 关闭与数据库的连接。
mssql_connect: 连上数据库。
mssql_data_seek: 移动列指针。
mssql_fetch_array: 返回数组资料。
mssql_fetch_field: 取得字段信息。
mssql_fetch_object: 返回类资料。
mssql_fetch_row: 返回单列的各字段。
mssql_field_seek: 配置指针到返回值的某字段。
mssql_free_result: 释放返回占用内存。
mssql_num_fields: 取得返回字段的数目。
mssql_num_rows: 取得返回列的数目。
mssql_pconnect: 打开 MS SQL 服务器持续连接。
mssql_query: 送出一个 query 字符串。
mssql_result: 取得查询 (query) 的结果。
mssql_select_db: 选择一个数据库。
mt_getrandmax: 随机数的最大值。
mt_rand: 取得随机数值。
mt_srand: 配置随机数种子。
mysql_affected_rows: 得到 MySQL 最后操作影响的列数目。
mysql_close: 关闭 MySQL 服务器连接。
mysql_connect: 打开 MySQL 服务器连接。
mysql_create_db: 建立一个 MySQL 新数据库。
mysql_data_seek: 移动内部返回指针。
mysql_db_query: 送查询字符串 (query) 到 MySQL 数据库。
mysql_drop_db: 移除数据库。
mysql_errno: 返回错误信息代码。
mysql_error: 返回错误信息。
mysql_fetch_array: 返回数组资料。
mysql_fetch_field: 取得字段信息。
mysql_fetch_lengths: 返回单列各栏资料最大长度。
mysql_fetch_object: 返回类资料。
mysql_fetch_row: 返回单列的各字段。
mysql_field_flags: 获得目前字段的标志。
mysql_field_len: 获得目前字段的长度。
mysql_field_name: 返回指定字段的名称。
mysql_field_seek: 配置指针到返回值的某字段。
mysql_field_table: 获得目前字段的资料表 (table) 名称。
mysql_field_type: 获得目前字段的类型。
mysql_free_result: 释放返回占用内存。
mysql_insert_id: 返回最后一次使用 INSERT 指令的 ID。
mysql_list_dbs: 列出 MySQL 服务器可用的数据库 (database)。
mysql_list_fields: 列出指定资料表的字段 (field)。
mysql_list_tables: 列出指定数据库的资料表 (table)。
mysql_num_fields: 取得返回字段的数目。
mysql_num_rows: 取得返回列的数目。
mysql_pconnect: 打开 MySQL 服务器持续连接。
mysql_query: 送出一个 query 字符串。
mysql_result: 取得查询 (query) 的结果。
mysql_select_db: 选择一个数据库。
mysql_tablename: 取得资料表名称。
next: 将数组的内部指针向后移动。
nl2br: 将换行字符转成 <br>。
number_format: 格式化数字字符串。
OCIBindByName: 让动态 SQL 可使用 PHP 变量。
OCIColumnIsNULL: 测试返回行是否为空的。
OCIColumnSize: 取得字段类型的大小。
OCICommit: 将 Oracle 的交易处理付诸实行。
OCIDefineByName: 让 SELECT 指令可使用 PHP 变量。
OCIExecute: 执行 Oracle 的指令部分。
OCIFetch: 取得返回资料的一列 (row)。
OCIFetchInto: 取回 Oracle 资料放入数组。
OCILogOff: 关闭与 Oracle 的链接。
OCILogon: 打开与 Oracle 的链接。
OCINewDescriptor: 初始新的 LOB/FILE 描述。
OCINumRows: 取得受影响字段的数目。
OCIParse: 分析 SQL 语法。
OCIResult: 从目前列 (row) 的资料取得一栏 (column)。
OCIRollback: 撤消当前交易。
OctDec: 八进位转十进位。
odbc_autocommit: 开关自动改动功能。
odbc_binmode: 配置二进位资料处理方式。
odbc_close: 关闭 ODBC 链接。
odbc_close_all: 关闭所有 ODBC 链接。
odbc_commit: 改动 ODBC 数据库。
odbc_connect: 链接至 ODBC 数据库。
odbc_cursor: 取得游标名。
odbc_do: 执行 SQL 指令。
odbc_exec: 执行 SQL 指令。
odbc_execute: 执行预置 SQL 指令。
odbc_fetch_into: 取得返回的指定列。
odbc_fetch_row: 取得返回一列。
odbc_field_len: 取得字段资料长度。
odbc_field_name: 取得字段名称。
odbc_field_type: 取得字段资料类型。
odbc_free_result: 释出返回资料的内存。
odbc_longreadlen: 配置返回栏的最大值。
odbc_num_fields: 取得字段数目。
odbc_num_rows: 取得返回列数目。
odbc_pconnect: 长期链接至 ODBC 数据库。
odbc_prepare: 预置 SQL 指令。
odbc_result: 取得返回资料。
odbc_result_all: 返回 HTML 表格资料。
odbc_rollback: 撤消当前交易。
odbc_setoption: 调整 ODBC 配置。
opendir: 打开目录 handle。
openlog: 打开系统纪录。
Ora_Bind: 链接 PHP 变量到 Oracle 参数。
Ora_Close: 关闭一个 Oracle 的 cursor。
Ora_ColumnName: 得到 Oracle 返回列 (Column) 的名称。
Ora_ColumnSize: 取得字段类型的大小。
Ora_ColumnType: 得到 Oracle 返回列 (Column) 的类型。
Ora_Commit: 将 Oracle 的交易处理付诸实行。
Ora_CommitOff: 关闭自动执行 Oracle 交易改动的功能。
Ora_CommitOn: 打开自动执行 Oracle 交易改动的功能。
Ora_Do: 快速的 SQL 查询。
Ora_Error: 获得 Oracle 错误信息。
Ora_ErrorCode: 获得 Oracle 错误代码。
Ora_Exec: 执行 Oracle 的指令部分。
Ora_Fetch: 取得返回资料的一列 (row)。
Ora_FetchInto: 取回 Oracle 资料放入数组。
Ora_GetColumn: 从返回列 (row) 的资料取得一栏 (column)。
Ora_Logoff: 结束与 Oracle 的链接。
Ora_Logon: 打开与 Oracle 的链接。
Ora_Numcols: 取得字段的数目。
Ora_Open: 打开 Oracle 的 cursor。
Ora_Parse: 分析 SQL 语法。
Ora_PLogon: 打开与 Oracle 的长期链接。
Ora_Rollback: 撤消当前交易。
Ord: 返回字符的序数值。
pack: 压缩资料到位字符串之中。
parse_str: 解析 query 字符串成变量。
parse_url: 解析 URL 字符串。
passthru: 执行外部程序并不加处理输出资料。
pclose: 关闭文件。
PDF_add_annotation: 加入注释。
PDF_add_outline: 目前页面加入书签。
PDF_arc: 绘弧。
PDF_begin_page: 启始 PDF 文件页面。
PDF_circle: 绘圆。
PDF_clip: 组合所有向量。
PDF_close: 关闭 PDF 文件。
PDF_closepath: 形成封闭的向量形状。
PDF_closepath_fill_stroke: 形成封闭的向量形状沿向量绘线并填满。
PDF_closepath_stroke: 形成封闭的向量形状并沿向量绘线。
PDF_close_image: 关闭图文件。
PDF_continue_text: 输出文字。
PDF_curveto: 绘贝氏曲线。
PDF_endpath: 关闭目前向量。
PDF_end_page: 关闭 PDF 文件页面。
PDF_execute_image: 放置 PDF 文件中图片到指定位置。
PDF_fill: 填满目前的向量。
PDF_fill_stroke: 填满目前的向量并沿向量绘线。
PDF_get_info: 返回文件信息。
PDF_lineto: 绘直线。
PDF_moveto: 配置处理的坐标点。
PDF_open: 建立新的 PDF 文件。
PDF_open_gif: 打开 GIF 图文件。
PDF_open_jpeg: 打开 JPEG 图文件。
PDF_open_memory_image: 打开内存图文件。
PDF_place_image: 放置图片到 PDF 文件指定位置。
PDF_put_image: 放置图片到 PDF 文件。
PDF_rect: 绘长方形。
PDF_restore: 还原环境变量。
PDF_rotate: 旋转类。
PDF_save: 储存环境变量。
PDF_scale: 缩放类。
PDF_setdash: 配置虚线样式。
PDF_setflat: 配置平滑值。
PDF_setgray: 指定绘图的颜色为灰阶并填入。
PDF_setgray_fill: 指定填入的颜色为灰阶。
PDF_setgray_stroke: 指定绘图的颜色为灰阶。
PDF_setlinecap: 配置 linecap 参数。
PDF_setlinejoin: 配置连接参数。
PDF_setlinewidth: 配置线宽。
PDF_setmiterlimit: 配置斜边界限。
PDF_setrgbcolor: 指定绘图的颜色为彩色并填入。
PDF_setrgbcolor_fill: 指定填入的颜色为彩色。
PDF_setrgbcolor_stroke: 指定绘图的颜色为彩色。
PDF_set_char_spacing: 配置字符间距。
PDF_set_duration: 配置二页的切换时间。
PDF_set_font: 配置使用的字型及大小。
PDF_set_horiz_scaling: 配置文字水平间距。
PDF_set_info_author: 配置文件作者。
PDF_set_info_creator: 配置建文件者字符串。
PDF_set_info_keywords: 配置文件的关键字。
PDF_set_info_subject: 配置文件主题。
PDF_set_info_title: 配置文件标题。
PDF_set_leading: 配置行距。
PDF_set_text_matrix: 配置文字矩阵。
PDF_set_text_pos: 配置文字位置。
PDF_set_text_rendering: 配置文字表现方式。
PDF_set_text_rise: 配置文字高度。
PDF_set_transition: 配置页的转换。
PDF_set_word_spacing: 配置字间距。
PDF_show: 输出字符串到 PDF 文件。
PDF_show_xy: 输出字符串到指定坐标。
PDF_stringwidth: 计算字符串的宽度。
PDF_stroke: 沿向量绘线。
PDF_translate: 移动原点。
pfsockopen: 打开网络的 Socket 持续链接。
pg_Close: 关闭 PostgreSQL 服务器连接。
pg_cmdTuples: 取得被 SQL 指令影响的资料笔数。
pg_Connect: 打开 PostgreSQL 服务器连接。
pg_DBname: 取得目前的数据库名称。
pg_ErrorMessage: 返回错误信息。
pg_Exec: 执行 query 指令。
pg_Fetch_Array: 返回数组资料。
pg_Fetch_Object: 返回类资料。
pg_Fetch_Row: 返回单列的各字段。
pg_FieldIsNull: 检查字段是否有资料。
pg_FieldName: 返回指定字段的名称。
pg_FieldNum: 取得指定字段的行数。
pg_FieldPrtLen: 计算可列示的长度。
pg_FieldSize: 计算指定字段的长度。
pg_FieldType: 获得目前字段的类型。
pg_FreeResult: 释放返回占用内存。
pg_GetLastOid: 取得最后的类代码。
pg_Host: 取得连接机器名称。
pg_loclose: 关闭大型类。
pg_locreate: 建立大型类。
pg_loopen: 打开大型类。
pg_loread: 读取大型类。
pg_loreadall: 读取大型类并输出。
pg_lounlink: 删除大型类。
pg_lowrite: 读取大型类。
pg_NumFields: 取得返回字段的数目。
pg_NumRows: 取得返回列的数目。
pg_Options: 取得连接机器选项。
pg_pConnect: 打开 PostgreSQL 服务器持续连接。
pg_Port: 取得连接机器埠号。
pg_Result: 取得查询 (query) 的结果。
pg_tty: 取得连接机器终端机。
phpinfo: 返回 PHP 所有相关信息。
phpversion: 返回 PHP 版本信息。
pi: 圆周率。
popen: 打开文件。
pos: 返回数组目前的元素。
pow: 次方。
preg_match: 字符串比对解析。
preg_match_all: 字符串整体比对解析。
preg_replace: 字符串比对解析并取代。
preg_split: 将字符串依指定的规则切开。
prev: 将数组的内部指针往前移动。
print: 输出字符串。
printf: 输出格式化字符串。
putenv: 配置系统环境变量。
quoted_printable_decode: 将 qp 编码字符串转成 8 位字符串。
QuoteMeta: 加入引用符号。
rand: 取得随机数值。
range: 建立一个整数范围的数组。
rawurldecode: 从 URL 专用格式字符串还原成普通字符串。
rawurlencode: 将字符串编码成 URL 专用格式。
readdir: 读取目录 handle。
readfile: 输出文件。
readgzfile: 读出压缩文件。
readlink: 返回符号链接 (symbolic link) 目标文件。
recode_file: 记录文件或文件请求到记录中。
recode_string: 记录字符串到记录中。
register_shutdown_function: 定义 PHP 程序执行完成后执行的函数。
rename: 更改文件名。
reset: 将数组的指针指到数组第一个元素。
rewind: 重置开文件的读写位置指针。
rewinddir: 重设目录 handle。
rmdir: 删除目录。
round: 四舍五入。
rsort: 将数组的值由大到小排序。
sem_acquire: 捕获信号。
sem_get: 取得信号代码。
sem_release: 释出信号。
serialize: 储存资料到系统中。
session_decode: Session 资料解码。
session_destroy: 结束 session。
session_encode: Session 资料编码。
session_id: 存取目前 session 代号。
session_is_registered: 检查变量是否注册。
session_module_name: 存取目前 session 模块。
session_name: 存取目前 session 名称。
session_register: 注册新的变量。
session_save_path: 存取目前 session 路径。
session_start: 初始 session。
session_unregister: 删除已注册变量。
setcookie: 送出 Cookie 信息到浏览器。
setlocale: 配置地域化信息。
settype: 配置变量类型。
set_file_buffer: 配置文件缓冲区大小。
set_magic_quotes_runtime: 配置 magic_quotes_runtime 值。
set_socket_blocking: 切换搁置与无搁置模式。
set_time_limit: 配置该页最久执行时间。
shm_attach: 打开建立共享内存空间。
shm_detach: 中止共享内存空间链接。
shm_get_var: 取得内存空间中指定的变量。
shm_put_var: 加入或更新内存空间中的变量。
shm_remove: 清除内存空间。
shm_remove_var: 删除内存空间中指定的变量。
shuffle: 将数组的顺序弄混。
similar_text: 计算字符串相似度。
Sin: 正弦计算。
sizeof: 获知数组的大小。
sleep: 暂停执行。
snmpget: 取得指定类识别码。
snmpwalk: 取得所有类。
snmpwalkoid: 取得网络本体树状信息。
snmp_get_quick_print: 取得 UCD 函数库中的 quick_print 值。
snmp_set_quick_print: 配置 UCD 函数库中的 quick_print 值。
solid_close: 关闭 solid 链接。
solid_connect: 链接至 solid 数据库。
solid_exec: 执行 SQL 指令。
solid_fetchrow: 取得返回一列。
solid_fieldname: 取得字段名称。
solid_fieldnum: 取得字段数目。
solid_freeresult: 释出返回资料的内存。
solid_numfields: 取得字段数目。
solid_numrows: 取得返回列数目。
solid_result: 取得返回资料。
sort: 将数组排序。
soundex: 计算字符串的读音值
split: 将字符串依指定的规则切开。
sprintf: 将字符串格式化。
sql_regcase: 将字符串逐字返回大小写字符。
Sqrt: 开平方根。
srand: 配置随机数种子。
stat: 取得文件相关信息。
strchr: 寻找第一个出现的字符。
strcmp: 字符串比较。
strcspn: 不同字符串的长度。
strftime: 将服务器的时间本地格式化。
StripSlashes: 去掉反斜线字符。
strip_tags: 去掉 HTML 及 PHP 的标记。
strlen: 取得字符串长度。
strpos: 寻找字符串中某字符最先出现处。
strrchr: 取得某字符最后出现处起的字符串。
strrev: 颠倒字符串。
strrpos: 寻找字符串中某字符最后出现处。
strspn: 找出某字符串落在另一字符串遮罩的数目。
strstr: 返回字符串中某字符串开始处至结束的字符串。
strtok: 切开字符串。
strtolower: 字符串全转为小写。
strtoupper: 字符串全转为大写。
strtr: 转换某些字符。
strval: 将变量转成字符串类型。
str_replace: 字符串取代。
substr: 取部份字符串。
sybase_affected_rows: 取得最后 query 影响的列数。
sybase_close: 关闭与数据库的连接。
sybase_connect: 连上数据库。
sybase_data_seek: 移动列指针。
sybase_fetch_array: 返回数组资料。
sybase_fetch_field: 取得字段信息。
sybase_fetch_object: 返回类资料。
sybase_fetch_row: 返回单列的各字段。
sybase_field_seek: 配置指针到返回值的某字段。
sybase_free_result: 释放返回占用内存。
sybase_num_fields: 取得返回字段的数目。
sybase_num_rows: 取得返回列的数目。
sybase_pconnect: 打开服务器持续连接。
sybase_query: 送出一个 query 字符串。
sybase_result: 取得查询 (query) 的结果。
sybase_select_db: 选择一个数据库。
symlink: 建立符号链接 (symbolic link)。
syslog: 纪录至系统纪录。
system: 执行外部程序并显示输出资料。
Tan: 正切计算。
tempnam: 建立只一的临时文件。
time: 取得目前时间的 UNIX 时间戳记。
touch: 配置最后修改时间。
trim: 截去字符串首尾的空格。
uasort: 将数组依使用者自定的函数排序。
ucfirst: 将字符串第一个字符改大写。
ucwords: 将字符串每个字第一个字母改大写。
uksort: 将数组的索引依使用者自定的函数排序。
umask: 改变目前的文件属性遮罩 umask。
uniqid: 产生只一的值。
unlink: 删除文件。
unpack: 解压缩位字符串资料。
unserialize: 取出系统资料。
unset: 删除变量。
urldecode: 还原 URL 编码字符串。
urlencode: 将字符串以 URL 编码。
usleep: 暂停执行。
usort: 将数组的值依使用者自定的函数排序。
utf8_decode: 将 UTF-8 码转成 ISO-8859-1 码。
utf8_encode: 将 ISO-8859-1 码转成 UTF-8 码。
virtual: 完成apache服务器的子请求 (sub-request)。
vm_addalias: 加入新别名。
vm_adduser: 加入新使用者。
vm_delalias: 删除别名。
vm_deluser: 删除使用者。
vm_passwd: 改变使用者密码。
wddx_add_vars: 将 WDDX 封包连续化。
wddx_deserialize: 将 WDDX 封包解连续化。
wddx_packet_end: 结束的 WDDX 封包。
wddx_packet_start: 开始新的 WDDX 封包。
wddx_serialize_value: 将单一值连续化。
wddx_serialize_vars: 将多值连续化。
xml_error_string: 取得 XML 错误字符串。
xml_get_current_byte_index: 取得目前解析为第几个位组。
xml_get_current_column_number: 获知目前解析的第几字段。
xml_get_current_line_number: 取得目前解析的行号。
xml_get_error_code: 取得 XML 错误码。
xml_parse: 解析 XML 文件。
xml_parser_create: 初始 XML 解析器。
xml_parser_free: 释放解析占用的内存。
xml_parser_get_option: 取得解析使用的选项。
xml_parser_set_option: 配置解析使用的选项。
xml_set_character_data_handler: 建立字符资料标头。
xml_set_default_handler: 建立默认标头。
xml_set_element_handler: 配置元素的标头。
xml_set_external_entity_ref_handler: 配置外部实体参引的标头。
xml_set_notation_decl_handler: 配置记法宣告的标头。
xml_set_object: 使 XML 解析器用类。
xml_set_processing_instruction_handler: 建立处理指令标头。
xml_set_unparsed_entity_decl_handler: 配置未解析实体宣告的标头。
yp_errno: 取得先前 YP 操作的错误码。
yp_err_string: 取得先前 YP 操作的错误字符串。
yp_first: 返回 map 上第一笔符合的资料。
yp_get_default_domain: 取得机器的 Domain。
yp_master: 取得 NIS 的 Master。
yp_match: 取得指定资料。
yp_next: 指定 map 的下笔资料。
yp_order: 返回 map 的序数。