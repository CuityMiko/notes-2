1》》》》》base64_encode
string base64_encode(string data)
将字符串以64位进行编码，可以让中文字或者图片也能在网络上顺利传输。

2》》》》》get_loaded_extensions()
这是查看php开启的扩展，输出的一个数组元素。

3》》》》》setlocale() 
函数设置地区信息（地域信息）。
设置地区为 US English，然后重新设置回系统默认：
<?php
echo setlocale(LC_ALL,"US");
echo "<br>";
echo setlocale(LC_ALL,NULL);
?>

parse_str()函数	
将字符串解析成变量	
parse_str("id=23&name=John%20Adams",$myArray);
print_r($myArray);
结果为：
Array ( [id] => 23 [name] => John Adams )

chr()函数
返回指定ASCII值对应的字符
echo chr(077);
结果为：?
ord()函数
返回字符串对应的ASCII值
echo ord('H');
结果为：72
strtr()函数
echo strtr('Hello World','la','lo');
结果是：
Hello world

++++++PHP计算URL的文件后缀名++++++
function getext($url){
    $data = parse_url($url);
    $path = $data['path'];
    $info = pathinfo($path);
    return $info['extension'];
}
echo getext('http://blog.phpha.com/archives/1670.html?id=1670');
//结果：'html'


+++++++++phpstr_replace()函数与preg_replace()函数+++++++++
str_replace(修改后的内容，希望替换的内容，原字符串或数组，替换的数目);
<?php
$arr = array("blue","red","green","yellow");
print_r(str_replace("red","pink",$arr,$i));
echo "替换数：$i";
?>
结果为：
Array ( [0] => blue [1] => pink [2] => green [3] => yellow ) 替换数：1
同样功能的函数有preg_replace()函数
preg_replace(修改后的内容，希望替换的内容，原字符串或数组）

转义字符串，json中常用。php》5。2有一个系统函数json_encode()自带转义效果
public function escapeJsonString($value) {
    $escapers = array("\\", "/", "\"", "\n", "\r", "\t", "\x08", "\x0c");
    $replacements = array("\\\\", "\\/", "\\\"", "\\n", "\\r", "\\t", "\\f", "\\b");
    $result = str_replace($escapers, $replacements, $value);
    return $result;
}

++++++PHP生成一个可阅读随机字符串+++++++
function readable_random_string($length = 6){
    $conso=array("b","c","d","f","g","h","j","k","l",
    "m","n","p","r","s","t","v","w","x","y","z");    $vocal=array("a","e","i","o","u");
    $password="";
    srand ((double)microtime()*1000000);
    $max = $length/2;
    for($i=1; $i<=$max; $i++)
    {
    $password.=$conso[rand(0,19)];
    $password.=$vocal[rand(0,4)];
    }
    return $password;
}
var_dump(readable_random_string(7));
其中一个结果为：
string 'wopunu' (length=6)

++++PHP编码电子邮件地址++++++
使用此代码，可以将任何电子邮件地址编码为 html 字符实体，以防止被垃圾邮件程序收集。
function encode_email($email='info@domain.com', $linkText='Contact Us', $attrs ='class="emailencoder"' )
{
    $email = str_replace('@', '@', $email);
    $email = str_replace('.', '.', $email);
    $email = str_split($email, 5);  
    $linkText = str_replace('@', '@', $linkText);
    $linkText = str_replace('.', '.', $linkText);
    $linkText = str_split($linkText, 5);  
    $part1 = '<a href="ma';
    $part2 = 'ilto:';
    $part3 = '" '. $attrs .' >';
    $part4 = '</a>';  
  
    $encoded = '<script type="text/javascript">';
    $encoded .= "document.write('$part1');";
    $encoded .= "document.write('$part2');";
    foreach($email as $e)
    {
            $encoded .= "document.write('$e');";
    }
    $encoded .= "document.write('$part3');";
    foreach($linkText as $l)
    {
            $encoded .= "document.write('$l');";
    }
    $encoded .= "document.write('$part4');";
    $encoded .= '</script>';  
    return $encoded;
}
var_dump(encode_email('thff@dfgf.com','dbgdbd','grrg'));
结果为：
string '<script type="text/javascript">document.write('<a href="ma');document.write
('ilto:');document.write('thff@');document.write('dfgf.');document.write('com');
document.write('" grrg >');document.write('dbgdb');document.write('d');document.write('</a>');</script>' (length=2)

++++++php删除一个目录+++++++++++
删除一个目录，包括它的内容。
/*****
*@dir - Directory to destroy
*@virtual[optional]- whether a virtual directory
*/
function destroyDir($dir, $virtual = false)
{
    $ds = DIRECTORY_SEPARATOR;
    $dir = $virtual ? realpath($dir) : $dir;
    $dir = substr($dir, -1) == $ds ? substr($dir, 0, -1) : $dir;
    if (is_dir($dir) && $handle = opendir($dir))
    {
        while ($file = readdir($handle))
        {
            if ($file == '.' || $file == '..')
            {
             continue;
            }
            elseif (is_dir($dir.$ds.$file))
            {
                destroyDir($dir.$ds.$file);
            }
            else
            {
                unlink($dir.$ds.$file);
            }
        }
        closedir($handle);
        rmdir($dir);
        return true;
    }
    else
    {
        return false;
    }
}

++++++php解析XML+++++++++
$xml_string="<?xml version='1.0'?>
<users>
<user id='398'>
<name>Foo</name>
<email>foo@bar.com</name>
</user>
<user id='867'>
<name>Foobar</name>
<email>foobar@foo.com</name>
</user>
</users>"; 
//load the xml string using simplexml
$xml = simplexml_load_string($xml_string); 
//loop through the each node of user
foreach ($xml->user as $user)
{
    //access attribute
    echo $user['id'], ' ';
    //subnodes are accessed by -> operator
    echo $user->name, ' ';
    echo $user->email, '<br />';
}


++++++PHP创建日志缩略名++++++
创建用户友好的日志缩略名
function create_slug($string){
    $slug=preg_replace('/[^A-Za-z0-9-]+/', '-', $string);
    return $slug;
}

++++++++ PHP获取客户端真实 IP 地址++++++++++
该函数将获取用户的真实 IP 地址，即便他使用代理服务器。
function getRealIpAddr()
{
    if (!emptyempty($_SERVER['HTTP_CLIENT_IP']))
    {
        $ip=$_SERVER['HTTP_CLIENT_IP'];
    }
    elseif (!emptyempty($_SERVER['HTTP_X_FORWARDED_FOR']))
    //to check ip is pass from proxy
    {
        $ip=$_SERVER['HTTP_X_FORWARDED_FOR'];
    }
    else
    {
        $ip=$_SERVER['REMOTE_ADDR'];
    }
    return $ip;
}

+++++++PHP强制性文件下载++++++++
为用户提供强制性的文件下载功能
function force_download($file)
{
    if ((isset($file))&&(file_exists($file))) {
        header("Content-length: ".filesize($file));
        header('Content-Type: application/octet-stream');
        header('Content-Disposition: attachment; filename="' . $file . '"');
        readfile("$file");
    }
    else {
        echo "No file selected";
    }
}


+++++PHP创建标签云+++++++
function getCloud( $data = array(), $minFontSize = 12, $maxFontSize = 30 )
{
    $minimumCount = min( array_values( $data ) );
    $maximumCount = max( array_values( $data ) );
    $spread = $maximumCount - $minimumCount;
    $cloudHTML = '';
    $cloudTags = array(); 
    $spread == 0 && $spread = 1; 
    foreach( $data as $tag => $count )
    {
        $size = $minFontSize + ( $count - $minimumCount )
        * ( $maxFontSize - $minFontSize ) / $spread;
       $cloudTags[] = '<a style="font-size: ' . floor( $size ) . 'px'
        . '" href="#" title="\'' . $tag .
        '\' returned a count of ' . $count . '">'
        . htmlspecialchars( stripslashes( $tag ) ) . '</a>';
    } 
    return join( "\n", $cloudTags ) . "\n";
}
/**************************
**** Sample usage ***/
$arr = Array('Actionscript' => 35, 'Adobe' => 22, 'Array' => 44, 'Background' => 43,
'Blur' => 18, 'Canvas' => 33, 'Class' => 15, 'Color Palette' => 11, 'Crop' => 42,
'Delimiter' => 13, 'Depth' => 34, 'Design' => 8, 'Encode' => 12, 'Encryption' => 30,
'Extract' => 28, 'Filters' => 42);
echo getCloud($arr, 12, 36);

++++++PHP寻找两个字符串的相似性similar_text()+++++++
PHP 提供了一个极少使用的 similar_text 函数，但此函数非常有用，用于比较两个字符串并返回相似程度的百分比
similar_text($string1, $string2, $percent);
实例：
similar_text('hhllo','hello',$percent);
echo $percent."%";
结果为：80%

+++++PHP为URL地址预设 http字符串++++++++
有时需要接受一些表单中的网址输入，但用户很少添加 http:// 字段，此代码将为网址添加该字段。
if (!preg_match("/^(http|ftp):/", $_POST['url'])) {
   $_POST['url'] = 'http://'.$_POST['url'];
   } 

++++++++PHP将网址字符串转换成超级链接+++++++++
该函数将 URL 和 E-mail 地址字符串转换为可点击的超级链接。
function makeClickableLinks($text) {
	    $text = eregi_replace('(((f|ht){1}tp://)[-a-zA-Z0-9@:%_+.~#?&//=]+)',
	    '<a href="\1">\1</a>', $text);
	    $text = eregi_replace('([[:space:]()[{}])(www.[-a-zA-Z0-9@:%_+.~#?&//=]+)',
	    '\1<a href="http://\2">\2</a>', $text);
	    $text = eregi_replace('([_.0-9a-z-]+@([0-9a-z][0-9a-z-]+.)+[a-z]{2,3})',
	    '<a href="mailto:\1">\1</a>', $text); 
	    return $text;
} 

++++++PHP调整图像尺寸++++++
创建图像缩略图需要许多时间，此代码将有助于了解缩略图的逻辑。
function resize_image($filename, $tmpname, $xmax, $ymax)
	{
	    $ext = explode(".", $filename);
	    $ext = $ext[count($ext)-1];  
	    if($ext == "jpg" || $ext == "jpeg")
	        $im = imagecreatefromjpeg($tmpname);
	    elseif($ext == "png")
	        $im = imagecreatefrompng($tmpname);
	    elseif($ext == "gif")
	        $im = imagecreatefromgif($tmpname); 
	    $x = imagesx($im);
	    $y = imagesy($im);   
	    if($x <= $xmax && $y <= $ymax)
	        return $im;  
	    if($x >= $y) {
	        $newx = $xmax;
	        $newy = $newx * $y / $x;
	    }
	    else {
	        $newy = $ymax;
	        $newx = $x / $y * $newy;
	    }  
	  
	    $im2 = imagecreatetruecolor($newx, $newy);
	    imagecopyresized($im2, $im, 0, 0, 0, 0, floor($newx), floor($newy), $x, $y);
	    return $im2;
	} 





+++++++用php访问http与https的转换+++++++
http直接跳转为https，重定向一下就可以了。
<?php
	header("Location:https://www.nowamagic.com");
?>
当访问 http 时，跳 https：
<?php
//http转化为https   
if ($_SERVER["HTTPS"] <> "on")
{
	$xredir="https://".$_SERVER["SERVER_NAME"].$_SERVER["REQUEST_URI"];
	header("Location: ".$xredir);
}
?>  
当访问 https 时，跳 http：
<?php
//https转化为http   
if ($_SERVER["HTTPS"] == "on")  
{  
	$xredir="http://".$_SERVER["SERVER_NAME"]. $_SERVER["REQUEST_URI"];  
	header("Location: ".$xredir);  
}   
?>
在网页开头包含上面代码即可。

+++++php截取GB2312中文字符串++++++++
function mysubstr($str, $start, $len) {
    $tmpstr = "";
    $strlen = $start + $len;
    for($i = 0; $i < $strlen; $i++) {
        if(ord(substr($str, $i, 1)) > 0xa0) {
            $tmpstr .= substr($str, $i, 2);
            $i++;
        } else
            $tmpstr .= substr($str, $i, 1);
    }
    return $tmpstr;
}

+++++++PHP“相关文章推荐”功能的简易实现+++++++++++
$demo_title = "简明现代魔法";
$demo_arr_title = array("简单易懂的现代魔法","简单明了的现代魔法","简明扼要的古代魔法","不简单的现代魔法","很难懂的现代魔法");
$new_array = getSimilar($demo_title,$demo_arr_title);
//print_r($new_array);
echo "与[$demo_title]最相关的前三个文章是：<br/>";
for($j=0; $j<=2; $j++)
{ 
	echo ($j+1).":".$new_array[$j]."<br/>";
}

//$title当前标题，$arrayTitle为需要查找的数组
function getSimilar($title,$arr_title)
{
	$arr_len = count($arr_title);
	for($i=0; $i<=($arr_len-1); $i++)
	{
		//取得两个字符串相似的字节数
		$arr_similar[$i] = similar_text($arr_title[$i],$title);
	}
	arsort($arr_similar);	//按照相似的字节数由高到低排序
	reset($arr_similar);	//将指针移到数组的第一单元
	$index = 0;
	foreach($arr_similar as $old_index=>$similar)
	{
		$new_title_array[$index] = $arr_title[$old_index];
		$index++;
	}
	return $new_title_array;
}
运行结果是：
与[简明现代魔法]最相关的前三个文章是：
1:简单明了的现代魔法
2:简单易懂的现代魔法
3:简明扼要的古代魔法

+++++++php分拆数组元素的函数效率比较与分析++++++++
有这么一个需求，一个数组$data = array(12, 43, 87, 45)，要求写一个自定义函数，
将其数组元素的数字单个拆开，最后形成的数组如下：$data = array(1, 2, 4, 3, 8, 7, 4, 5)。
答案一：
function splitStrToArray_mine($array)
{
	$new_array = array();
	foreach($array as $value)
	{
		$value = (string)$value;
		$len = strlen($value);
		for($i = 0; $i < $len; $i ++){
			array_push($new_array, $value{$i});
		}
	}
	return $new_array;
}
或者是这一种
答案二：
function splitStrToArray($array)
{
	return str_split(implode("", $array));
}

+++++++++PHP发送邮件+++++++++
PHP发送邮件的小程序很简单，不过有些需要注意的地方。先上代码：
<?php    
    $to = "gonnsai@163.com";  
	$user = "Gonn";
	$date = date("Y年m月d日");
	
	$headers  = 'MIME-Version: 1.0' . "rn";
	$headers .= 'Content-type: text/html; charset=utf-8' . "rn";
	$headers .= "To: $to rn"; 
	$headers .= "Cc: 252211974@qq.com rn"; 
	$headers .= 'From: gonnsai@163.com' . "rn";
    $subject = "珠海生活圈";  
	$subject = "=?UTF-8?B?".base64_encode($subject)."?=";
 
    $content = '亲爱的'."$user".'：'.'<br />';  
	$content .= '<br />';  
	$content .= "感谢您注册珠海生活圈，精彩的生活从珠海生活圈开始！".'<br />';  
    $content .= "在珠海生活圈，您可以：".'<br />';  
	$content .= "查询珠海的商家情况，方便您生活与娱乐。".'<br />';  
	$content .= "了解最近珠海举行的活动，让您的生活更加丰富。".'<br />';  
	$content .= "浏览新闻热点，扩展知识面。".'<br />';  
	$content .= '<br />';  
	$content .= "珠海生活圈 -- 为建成珠海最大的商家数据库而不断努力着。 ".'<a href="http://www.zhuhailife.net" target="_blank">www.zhuhailife.net</a>'.'<br />'; 
	$content .= '<br />';  
	$content .= "珠海生活圈团队".'<br />'; 
	$content .= "$date".'<br />';  
    $result = mail($to, $subject, $content, $headers);  
	
	if($result)
	{
		echo '邮件发送成功！';
	}
	
?>  


+++++php通过json传值给前端，javascript接收++++++++
json.php内容是：
<?php
$arr=array(
'name'=>'Bob','nick'=>'Yes',
'contact'=>array(
	'email'=>'json@admin.com',
	'tel'=>'12323314567',
     )
);
$json_string=json_encode($arr);
echo "getProfile($json_string)";
?>

html内容是：
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
</head>
<script type="text/javascript">  
	function getProfile(str){
	var arr=str;
	document.getElementById('name').innerHTML=arr.name;
	document.getElementById('nick').innerHTML=arr.nick;
	document.getElementById('email').innerHTML=arr.contact.email;
	document.getElementById('tel').innerHTML=arr.contact.tel;
	
}
</script>
<body>
<h2>
测试json
</h2>
<div id="name"></div>
<div id="nick"></div>
<div id="email"></div>
<div id="tel"></div>
</body>
<script type="text/javascript" src="json.php"></script>   <!--我擦，这个引用js还只能放在这个位置，也是醉了-->
</html>


+++++++前端javascript通过json传值给php++++++++
JavaScript 向 PHP 传值
json_encode.html

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>json:From javascript To php</title>
<script src="json2.js" type="text/javascript"></script>
<script type="text/javascript">
function JSON_test(o)
{
    var user = {
        name:document.getElementById('txt_name').value,
        email:document.getElementById('txt_email').value,
        password:document.getElementById('txt_password').value
    }
    var json_string = JSON.stringify(user);
    document.getElementById('txt_json').value=json_string;
    alert("点击确定后将提交表单");
    o.submit();
}
</script>
</head>
<body>
    <form id="form1" name="form1" method="post" action="json_encode.php" onsubmit="JSON_test(this);return flase;">
        <label for="txt_name">姓名</label>
        <p><input type="text" name="txt_name" id="txt_name" /></p>
        <label for="txt_email">邮箱</label>
        <p><input type="text" name="txt_email" id="txt_email" /></p>
        <p><label for="txt_password">密码</label></p>
        <p><input type="text" name="txt_password" id="txt_password" /></p>
        <p><input type="text" name="txt_json" id="txt_json" />
            <label for="button"></label>
            <input type="submit" name="button" id="button" value="JSON" />
        </p>
    </form>
</body>
</html>
这里javascript扁平化需要一个插件：http://www.json.org/json2.js，通过JSON.stringify(str)将对象扁平化然后传送给php。
注：另有一个http://www.json.org/json.js，对应的是toJSONString方法。
var last=obj.toJSONString(); //针对json.js
var last=JSON.stringify(obj); //针对json2.js

json_encode.php
<?php
    header('Content-Type: text/html; charset=utf-8');
    $json_string = $_POST["txt_json"];
    //echo $json_string;
    if(ini_get("magic_quotes_gpc")=="1")
    {
        $json_string=stripslashes($json_string);
    }
    $user = json_decode($json_string);
    echo var_dump($user);
    echo '<br /><br /><br /><br />';
    echo $user->name.'<br />';
    echo $user->email.'<br />';
    echo $user->password.'<br />';
?>
这里就需要用到json_decode()这个函数，然后调用其中数据用 $obj->属性即可。

++++++php检验是不是win32平台+++++++
$is_win = DIRECTORY_SEPARATOR == '\\';
echo 一下，如果是win32平台就会输出1；



++++++htmlspecialchars()函数++++++++
echo htmlspecialchars($str, ENT_COMPAT); // 只转换双引号
echo "<br>";
echo htmlspecialchars($str, ENT_QUOTES); // 转换双引号和单引号  ，更加安全


++++++PHP返回insert操作产生的id+++++++
<?php
$con = mysql_connect("localhost", "hello", "321");
if (!$con)
{
    die('Could not connect: ' . mysql_error());
}
$db_selected = mysql_select_db("test_db",$con);
$sql = "INSERT INTO person VALUES ('Carter','Thomas','Beijing')";
$result = mysql_query($sql,$con);
echo "ID of last inserted record is: " . mysql_insert_id();
mysql_close($con);
?>

++++++++简单的PHP伪缓存并定时抓取某页面内容++++++++++++
需求：要抓取某个页面的一部分内容，然后iframe到别的页面去。
iframe的时候，不需求每次都访问源页面，而是每天只读取源页面一次，
并生成文件，iframe的时候只访问该暂时文件，也就是伪缓存啦。这么做适合访问量不大的页面
，降低数据库访问压力。
<?php
function get_page_content()
{
	$url = "http://www.nowamagic.net/";
	$contents = file_get_contents($url);
	//如果出现中文乱码使用下面代码
	//$getcontent = iconv("gb2312″, "utf-8″,$contents);
	//echo $contents;
	//$pos = strstr($contents, '<div class="hot_news">');
	//print_r($pos);
	$array = explode('<div class="hot_news">', $contents);
	$htmlarray = explode('<div class="car_tab border4">', $array[0]); // HTML部分
	$cssarray = explode('<div class="hometop">', $htmlarray[0]);
	$css_rem_inner = explode('<!--[if !IE]>导航<![endif]-->', $cssarray[0]);
	$css_min = explode('<script type="text/javascript" src="http://www.nowamagic.net/ad_comm_t.js">', $css_rem_inner[0]);
	$str_css = $css_min[0];
	$head = '<base target="_blank"></base></head> ';
	$str_1 = '<div class="car_tab border4">';
	$str_html = $htmlarray[1]; 
	$content = $str_css.$head.$str_1.$str_html;
	return $content;
}
$cache_file = "tmp.html";
$cache_time = 60*60*24;
/**
ob_start();
echo $content;
file_put_contents($cacheFile,ob_get_contents());
ob_end_flush();
**/
echo date("Y-m-d H:i:s", time());
echo '<br />';
echo date("Y-m-d H:i:s", floor(@filemtime($cache_file)));
if(time() - $cache_time > floor(@filemtime($cache_file)) )
{
	$content = get_page_content();
	file_put_contents($cacheFile, $content);
	header('Location: http://www.nowamagic.net/tmp.html');
}
else
{
	header('Location: http://www.nowamagic.net/tmp.html');
}
?>

++++++++gmdate()函数++++++++++++
echo gmdate('Y-m-d H:i:s', time() + 3600 * 8);
这样不管在Linux+Apache下还是Windows下都得到了正确的结果，当然这样写还有一个好处，
当网站是面向全世界的时候，那么网站用户只要设置所在的时区，程序自动根据用户设置的时区
进行时间计算，数据库中信息发布时间只存当前的time()所生成的时间，那么在中国+8时区看到的
发布时间是：2007-03-14 12:15:27，那么在欧洲+2时区用户看到这个信息的发布时间是：
2007-03-14 06:15:27，这样信息的时间就全部对应正确了。

+++++++PHP用strstr()函数阻止垃圾评论+++++++
strstr()函数简单演示
<?php
2
echo strstr("Hello NowaMagic!", "NowaMagic");
3
?>
程序运行结果：
NowaMagic!
则阻止垃圾评论的代码为：
<?php
$content = $_POST['content'];
$garbage = strstr($content, "<a");
if($garbage == false)
{
    //评论正常插入数据库
}
else
{
    echo "<script>alert('你的评论不能带有链接'); history.go(-1);</script>";
}
?>

++++bin2hex()函数++++++++++
bin2hex 将二进位转成十六进位
语法：string bin2hex(string str);

+++++++strip_tags()函数+++++++++
strip_tags()函数剥去 HTML、XML 以及 PHP 的标签。
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果为：
Hello NowaMagic!



++++++商品秒杀计时的PHP实现+++++++
注：秒杀时间从早上点到晚上10点。
<?php
//php的时间是以秒算。js的时间以毫秒算
date_default_timezone_set('PRC');  
//date_default_timezone_set("Asia/Hong_Kong");//地区
//配置每天的活动时间段
$starttimestr = "08:00:00";
$endtimestr = "22:00:00";
$starttime = strtotime($starttimestr);
$endtime = strtotime($endtimestr);
$nowtime = time();
if ($nowtime<$starttime){
die("活动还没开始,活动时间是：{$starttimestr}至{$endtimestr}");
}
$lefttime = $endtime-$nowtime; //实际剩下的时间（秒）
?>
<script language="JavaScript">
<!-- //
var runtimes = 0;
function GetRTime(){
var nMS = <?=$lefttime?>*1000-runtimes*1000;
var nH=Math.floor(nMS/(1000*60*60))%24;
var nM=Math.floor(nMS/(1000*60)) % 60;
var nS=Math.floor(nMS/1000) % 60;
document.getElementById("RemainH").innerHTML=nH;
document.getElementById("RemainM").innerHTML=nM;
document.getElementById("RemainS").innerHTML=nS;
if(nMS>5*59*1000&&nMS<=5*60*1000)
{
alert("还有最后五分钟！");
}
runtimes++;
setTimeout("GetRTime()",1000);
}
window.onload=GetRTime;
// -->
</script>
<h4><strong id="RemainH">XX</strong>:<strong id="RemainM">XX</strong>:<strong id="RemainS">XX</h4>




转码字符串格式+++++++++++ mb_convert_encoding()函数++++++++
mb_convert_encoding($str,'UTF-8','GBK')；将UTF-8格式的转为GBK
另外一个转码函数iconv()函数：
发现iconv在转换字符”—”到gb2312时会出错，如果没有ignore参数，所有该字符后面的字符串都无法被保存。
不管怎么样，这个”—”都无法转换成功，无法输出。 另外mb_convert_encoding没有这个bug. 
一般情况下用 iconv，只有当遇到无法确定原编码是何种编码，或者iconv转化后无法正常显示时才用mb_convert_encoding 函数. 
$content = iconv("GBK", "UTF-8", $str); (以上俩个函数会产生同样效果)
在使用iconv()时候，请不要转成"GB2312"的格式，因为这是iconv的一个bug，可以直接把gb2312写成gbk就OK了。

++++++++ stream_context_create()++++++++
作用：创建并返回一个文本数据流并应用各种选项，可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。 
函数原型：resource stream_context_create ([ array $options [, array $params ]] ) 
function Post($url, $post = null){
     $context = array();
     if (is_array($post)) {
         ksort($post);
         $context['http'] = array (
             'timeout'=>60,
             'method' => 'POST',
             'content' => http_build_query($post, '', '&'),
         );
     }
return file_get_contents($url, false,stream_context_create($context));
}

$data = array(
     'name' => 'test',
     'email' => 'test@gmail.com',
     'submit' => 'submit',
);
$str=Post('http://www.ej38.com', $data);
echo mb_convert_encoding($str,'UTF-8','GBK');

+++++++http_build_query()函数+++++++
将数组返回成一个url格式字符串
$data = array('foo'=>'bar',
              'baz'=>'boom',
              'cow'=>'milk',
              'php'=>'hypertext processor'
             );
echo http_build_query($data);
结果为：
foo=bar&baz=boom&cow=milk&php=hypertext+processor

+++++strstr()函数++++++++
检测一个字符串是否存在另一个字符串中，如果存在则返回检测原样（不加true）或者返回剩下部分
echo strstr('Hello','o');      返回 o
echo strstr('Hello','o',true); 返回 Hell
echo strstr('Hello','22');     不返回任何内容

+++++array_unique()函数+++++++
array_unique()可以去除一个一维数组中相同的元素，但是它不适用于多维数组，下面的方法可以解决。
function array_unique_fb($array2D)
{
    foreach ($array2D as $v)
    {
        $v = join(",",$v);  //降维,也可以用implode,将一维数组转换为用逗号连接的字符串
        $temp[] = $v;
    }
    $temp = array_unique($temp);    //去掉重复的字符串,也就是重复的一维数组
    foreach ($temp as $k => $v)
    {
        $temp[$k] = explode(",",$v);   //再将拆开的数组重新组装
    }
    return $temp;
}

+++++php生成随机时间日期的两种方法++++++++
可以自定义时间段。
1---》
function rand_time($a,$b)
{
$a=strtotime($a);
$b=strtotime($b);
return date( "Y-m-d H:m:s", mt_rand($a,$b));
}
$date1="2014-07-26 09:03:01";
$date2="2014-10-26 18:21:32";
$num = 15;
$i=0;
while ($i < $num){
 $date = rand_time($date1,$date2);
 $datea[]= $date;
 $i++;
}
sort($datea);
foreach ($datea as $values)
{
echo $values."<br>";
}

2---》
/**
 *   生成某个范围内的随机时间
 * @param <type> $begintime  起始时间 格式为 Y-m-d H:i:s
 * @param <type> $endtime    结束时间 格式为 Y-m-d H:i:s  
 */
function randomDate($begintime, $endtime="") {
    $begin = strtotime($begintime);
    $end = $endtime == "" ? mktime() : strtotime($endtime);
    $timestamp = rand($begin, $end);
    return date("Y-m-d H:i:s", $timestamp);
}
for($i = 0; $i <= 20; $i++){
echo randomDate("2014-06-27 09:03:01","2014-06-27 18:21:32");echo "<br />";
}





+++++++PHP截取中英混合的字符串++++++++++
function get_word($string, $length, $dot = '..',$charset='gbk') {
    if(strlen($string) <= $length) {
        return $string;
    }
    $string = str_replace(array('　',' ', '&', '"', '<', '>'), array('','','&', '"', '<', '>'), $string);
    $strcut = '';
    if(strtolower($charset) == 'utf-8') {
        $n = $tn = $noc = 0;
        while($n < strlen($string)) {
            $t = ord($string[$n]);
            if($t == 9 || $t == 10 || (32 <= $t && $t <= 126)) {
                $tn = 1; $n++; $noc++;
            } elseif(194 <= $t && $t <= 223) {
                $tn = 2; $n += 2; $noc += 2;
            } elseif(224 <= $t && $t < 239) {
                $tn = 3; $n += 3; $noc += 2;
            } elseif(240 <= $t && $t <= 247) {
                $tn = 4; $n += 4; $noc += 2;
            } elseif(248 <= $t && $t <= 251) {
                $tn = 5; $n += 5; $noc += 2;
            } elseif($t == 252 || $t == 253) {
                $tn = 6; $n += 6; $noc += 2;
            } else {
                $n++;
            }
            if($noc >= $length) {
                break;
           }
        }
        if($noc > $length) {
            $n -= $tn;
        }
        $strcut = substr($string, 0, $n);
    } else {
        for($i = 0; $i < $length; $i++) {
            $strcut .= ord($string[$i]) > 127 ? $string[$i].$string[++$i] : $string[$i];
        }
    }
    return $strcut.$dot;
}
$str = "欢迎 visit 简明 nowamagic";
$str_result = get_word($str, 12);
echo $str_result;


++++++4个数字得出24的方法+++++++
传说中的24点的游戏：
<?php
set_time_limit(0);
$values = array(5, 5, 5, 1);
$result = 24;
$list = array();
echo "<pre>";
makeValue($values);
print_r($list);
function makeValue($values, $set=array())
{
    $words = array("+", "-", "*", "/");
    if(sizeof($values)==1)
    {
        $set[] = array_shift($values);
        return makeSpecial($set);
    }
    foreach($values as $key=>$value)
    {
        $tmpValues = $values;
        unset($tmpValues[$key]);
        foreach($words as $word)
        {
            makeValue($tmpValues, array_merge($set, array($value, $word)));
        }
    }
}
function makeSpecial($set)
{
    $size = sizeof($set);
    if($size<=3 || !in_array("/", $set) && !in_array("*", $set))
    {
        return makeResult($set);
    }
    for($len=3; $len<$size-1; $len+=2)
    {
        for($start=0; $start<$size-1; $start+=2)
      {         
            if(!($set[$start-1]=="*" || $set[$start-1]=="/" || $set[$start+$len]=="*" || $set[$start+$len]=="/"))
                continue;
            $subSet = array_slice($set, $start, $len);
            if(!in_array("+", $subSet) && !in_array("-", $subSet))
                continue;
            $tmpSet = $set;
            array_splice($tmpSet, $start, $len-1);
            $tmpSet[$start] = "(".implode("", $subSet).")";
            makeSpecial($tmpSet);
        }
    }
}
function makeResult($set)
{
    global $result, $list;
    $str = implode("", $set);
    @eval("$num=$str;");
    if($num==$result && !in_array($str, $list))
    $list[] = $str;
}
?>


+++++++str_repeat()函数+++++++
重复字符串：
$arr='12';
echo str_repeat($arr,4);
结果为：
12121212


++++str_word_count()函数+++++++++++++
str_word_count()函数，可以确定一个字符串中某个单词的出现次数。
$arr='gg rfg rghh ';
var_dump(str_word_count($arr,1,'g'));
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'rfg' (length=3)
  2 => string 'rghh' (length=4)

++++++++substr_count()函数++++++++++++
substr_count()函数：可以确定一个字符串在所提供的字符串中有多少个
$arr="fghyjffgyhjdsthshgvgfhds";
var_dump(substr_count($arr,'g'));
结果为：
int 4


+++++++array_flip()函数++++++++++
交换键名与键值
$arr=array('1'=>'a','2'=>'b','3'=>'c');
var_dump(array_flip($arr));
结果为：array (size=3)
  'a' => int 1
  'b' => int 2
  'c' => int 3

++++++array_key_exists()与in_array()函数+++++++
检查值、键：
array_key_exists($key,$array);//检查数组键
in_array($value,$array);//检查值于数组

++++++++array_slice()函数+++++++++
array_slice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
var_dump(array_slice($arr,1,1));
结果是：
array (size=1)
0 => string 'tgrt' (length=4)
array_splice()函数
$arr=array(1=>'ffd',2=>'tgrt',3=>'rghd',4=>'erhh',5=>'fffsv');
array_splice($arr,4);
var_dump($arr);
结果是：
array (size=4)
  0 => string 'ffd' (length=3)
  1 => string 'tgrt' (length=4)
  2 => string 'rghd' (length=4)
  3 => string 'erhh' (length=4)

+++++++++PHP将微博短地址还原为实际网址+++++++++
$url = "http://163.fm/1QLJ8U";
echo unshorten($url);
function unshorten($url)
{
    $url = trim($url);
    $headers = get_headers($url);
    $location = $url;
    $short = false;
    foreach($headers as $head)
    {
        if($head=="HTTP/1.1 302 Found")
            $short = true;
        if($short && startwith($head,"Location: "))
        {
            $location = substr($head,10);
        }
    }
    return $location;
}
function startwith($Haystack, $Needle)
{
    return strpos($Haystack, $Needle) === 0;
}
自己测试一下。


++++++++++一主三从服务器课堂笔记总结++++++++++
2014年03月05日 ⁄ PHP, 数据库, 编程开发 ⁄ 共 3074字	⁄ 字号 小 中 大 ⁄ 暂无评论
data_user_0
data_user_1
data_user_2
data_user_3
.....
data_user_9
data_user_10
d_product_bj
d_product_tj
d_produtc_ts
md5($id)
得到32位字符串
取得32位字符串最后2位
2位字符串转换为10进制数值
唯一一个id经过我们的计算可以得到唯一的数值
数值对我们分表的张数取模
数据库主从配置
开启远程连接
grant all privileges on *.* to 'migrate'@'%' identified by 'migrate';
防火墙
(1) 确定自己想给这两个 MySQL 服务器分配什么样的 ID 值并把它们记录到 MySL 服务器在启动 时会去读取的某个选项文件里。主从服务器的 ID 值应该是 1 到 232?1 之间的一个正整数并且必须彼此 不同。在启动主、从服务器的时候,你必须用 server_id 启动选项给出其 ID 值。在此基础上,一定 要启用主服务器上的二进制日志功能——如果以前没有启用过它。要想在主、从服务器上启用二进制 日志,最省心的办法是在相应的选项组里加上如下所示的代码:
[mysqld] server-id=master_server_id log-bin=binlog_name
[mysqld] server-id=slave_server_id
重新启动两个服务器,让改动生效。
(2) 在主服务器上,创建一个账户供从服务器连接主服务器并请求修改信息:
CREATE USER 'slave_user'@'slave_host' IDENTIFIED BY 'slave_pass'; GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'slave_host';
请记住 slave_user 和 slave_pass 值,因为稍后还需要使用它们来告诉从服务器如何连接主服 务器。如果这个账户的用途只用于复制,就用不着再向它授予任何其他的权限了。不过,为了对复制 机制进行测试,你通常要在从服务器上用 mysql 程序以“手动方式”去连接主服务器,所以你往往还 应该再给这个账户多授予几项权限以方便自己能够多做一些事情。(比如说,如果这个账户仅有 REPLICATION SLAVE 权限的话,你甚至无法在从服务器上使用 SHOW DATABASES 语句去查看主服务 器上的数据库名称。)
(3) 连接到主服务器并通过执行 SHOW MASTER STATUS 语句确定当前的复制坐标:
mysql> FLUSH TABLES; SHOW MASTER STATUS;
请记住 File 和 Position 值,因为稍后还需要使用它们来告诉从服务器从哪个位置开始去读取 主服务器的二进制日志里的事件。
重要注意事项 在主服务器上,在从确定其复制坐标到制作出将被传输到从服务器的初始复制的这 段时间里,一定要保证主服务器上的数据库里的数据没有发生任何修改。
(4) 在从服务器上为将被复制的数据库建立一份完备的副本。把主服务器上的数据库复制到从服 务器以完成主、从服务器之间最初的同步。一种办法是先在主服务器主机上制作一份备份,再把这个 备份加载到从服务器上去;另一种办法是通过网络把各数据库从主服务器全部复制到从服务器。对数据库备份技术和复制技术的讨论见本章的其他小节。 如果你还没有在主服务器上创建过任何数据库或数据表,可以省略这一步,因为它现在还没有任何需要复制的东西。
(5) 连接到从服务器并使用 CHANGE MASTER 语句来配置它,这包括把用来连接主服务器的参数和
初始复制坐标告诉从服务器:
CHANGE MASTER TO
MASTER_HOST = 'master_host', MASTER_USER = 'slave_user', MASTER_PASSWORD = 'slave_pass', MASTER_LOG_FILE = 'log_file_name', MASTER_LOG_POS = log_file_pos;
'master_host'是主服务器的主机名。'slave_user'和'slave_pass'值是刚才在主服务器创建 的那个账户的用户名和口令,从服务器将使用这个账户来连接主服务器并请求主服务器修改信息。 'log_file_name'和'log_file_pos'是刚才用 SHOW MASTER STATUS 语句查出来的值。
在 Unix 系统上,使用 localhost 作为主机名将使用一个套接字文件去连接主服务器,但复制机 制不支持经套接字文件建立的连接。因此,如果主服务器和从服务器将运行在同一台主机上,就必须 把这个主机名写成 127.0.0.1 而不是 localhost,这样才能确保从服务器将使用 TCP/IP 连接。
如果主服务器所监听的网络端口不是默认端口,可以在 CHANGE 语句里包括一个 MASTER_PORT 选 项以明确地给出一个端口号。
(6) 让从服务器开始复制。
START SLAVE;
从服务器将连接主服务器并开始复制。你可以在从服务器上使用 SHOW SALVE STATUS 语句来查 看它的工作状态。
从服务器把 CHANGE MASTER 语句所给出的参数保存在其数据目录中的一个名为 master.info 的 文件里以记录初始复制状态,并随着镜象工作的进展而刷新那个文件。等以后需要改变复制参数的时 候,只要连接到从服务器并通过 CHANGE MASTER 语句给出新的设置,从服务器就会根据新的设置自 动刷新 master.info 文件。
保存在 master.info 文件里的信息包括用来连接主服务器的用户名和口令。这些信息应该是保 密的,所以应该把这个文件设置为只允许从服务器上的 MySQL 管理员的登录账户才能访问。
可以把 mysql 数据库排除在复制机制外,这需要做两件事情。
(1) 在把数据库的初始数据从主服务器传输到从服务器的时候,不要把 mysql 数据库也包括在 内。另一个办法是在传输之前先备份从服务器的 mysql 数据库,等传输工作完成后再恢复它。
(2) 在从服务器的选项文件里加上以下代码,让它不要执行来自主服务器的对 mysql 数据库的任 何修改:
[mysqld]
replicate-ignore-db=mysql
如果想让从服务器忽略多个数据库,需要多次使用 replication_ignore_db 选项——每个数据
库一次。
还有一个办法是在主服务器端(注意,不是从服务器端)使用--binlog-ignore-db 选项排除数
据库。这个办法的优点是可以减少从主服务器传输到从服务器的信息量,缺点是主服务器上的二进制
日志文件将不包含那些被排除在外的数据库的任何信息,而这些信息对主服务器在发生崩溃后的数据
恢复工作往往至关重要。因此,在从服务器端把数据库排除在外的做法更值得选择。
重要命令
SHOW SLAVE STATUS语句。在从服务器上查看其复制机制是否在工作以及当前的复制坐标。
复制坐标可以用来判断主服务器上的哪几个二进制日志文件已经不再会被用到了。
PURGE MASTER语句。在主服务器上对二进制日志文件进行失效处理。在每一个从服务器上都
通过SHOW SLAVE STATUS语句确定了哪些日志文件不会再用之后,你可以在主服务器上用这
条语句把那些二进制日志文件删除掉。
STOP SLAVE和START SLAVE语句。用来挂起和重新开始从服务器上的复制活动。比如说,当
你制作备份时,可以用这些语句让从服务器暂时停止复制活动。
可以通过在 SLAVE STOP 或 SLAVE START 语句的末尾加上 IO_THREAD
或 SQL_THREAD 关键字的办法分别挂起或者重新开始这两个线程中的任何一个。

4》》》》》数组函数
array()	创建数组。	
array_change_key_case()	返回其键均为大写或小写的数组。 	
array_chunk()	把一个数组分割为新的数组块。	
array_combine()	通过合并两个数组来创建一个新数组。	
array_count_values()	用于统计数组中所有值出现的次数。	
array_diff()	返回两个数组的差集数组。	
array_diff_assoc()	比较键名和键值，并返回两个数组的差集数组。	
array_diff_key()	比较键名，并返回两个数组的差集数组。	
array_diff_uassoc()	通过用户提供的回调函数做索引检查来计算数组的差集。	
array_diff_ukey()	用回调函数对键名比较计算数组的差集。	
array_fill()	用给定的值填充数组。	
array_filter()	用回调函数过滤数组中的元素。	
array_flip()	交换数组中的键和值。	
array_intersect()	计算数组的交集。	
array_intersect_assoc()	比较键名和键值，并返回两个数组的交集数组。	
array_intersect_key()	使用键名比较计算数组的交集。	
array_intersect_uassoc()	带索引检查计算数组的交集，用回调函数比较索引。	
array_intersect_ukey()	用回调函数比较键名来计算数组的交集。	
array_key_exists()	检查给定的键名或索引是否存在于数组中。	
array_keys()	返回数组中所有的键名。	
array_map()	将回调函数作用到给定数组的单元上。	
array_merge()	把一个或多个数组合并为一个数组。	
array_merge_recursive()	递归地合并一个或多个数组。	
array_multisort()	对多个数组或多维数组进行排序。	
array_pad()	用值将数组填补到指定长度。	
array_pop()	将数组最后一个单元弹出（出栈）。	
array_product()	计算数组中所有值的乘积。	
array_push()	将一个或多个单元（元素）压入数组的末尾（入栈）。	
array_rand()	从数组中随机选出一个或多个元素，并返回。	
array_reduce()	用回调函数迭代地将数组简化为单一的值。	
array_reverse()	将原数组中的元素顺序翻转，创建新的数组并返回。	
array_search()	在数组中搜索给定的值，如果成功则返回相应的键名。
array_shift()	删除数组中的第一个元素，并返回被删除元素的值。	
array_slice()	在数组中根据条件取出一段值，并返回。	
array_splice()	把数组中的一部分去掉并用其它值取代。	
array_sum()	计算数组中所有值的和。	
array_udiff()	用回调函数比较数据来计算数组的差集。	
array_udiff_assoc()	带索引检查计算数组的差集，用回调函数比较数据。
array_udiff_uassoc()	带索引检查计算数组的差集，用回调函数比较数据和索引。	
array_uintersect()	计算数组的交集，用回调函数比较数据。	
array_uintersect_assoc()	带索引检查计算数组的交集，用回调函数比较数据。	
array_uintersect_uassoc()	带索引检查计算数组的交集，用回调函数比较数据和索引。	
array_unique()	删除数组中重复的值。	
array_unshift()	在数组开头插入一个或多个元素。	
array_values()	返回数组中所有的值。	
array_walk()	对数组中的每个成员应用用户函数。	
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。	
arsort()	对数组进行逆向排序并保持索引关系。	
asort()	对数组进行排序并保持索引关系。	
compact()	建立一个数组，包括变量名和它们的值。	
count()	计算数组中的元素数目或对象中的属性个数。	
current()	返回数组中的当前元素。	
each()	返回数组中当前的键／值对并将数组指针向前移动一步。	
end()	将数组的内部指针指向最后一个元素。	
extract()	从数组中将变量导入到当前的符号表。	
in_array()	检查数组中是否存在指定的值。	
key()	从关联数组中取得键名。	
krsort()	对数组按照键名逆向排序。	
ksort()	对数组按照键名排序。	
list()	把数组中的值赋给一些变量。	
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。	
natsort()	用“自然排序”算法对数组排序。	
next()	将数组中的内部指针向前移动一位。	
pos()	current() 的别名。	
prev()	将数组的内部指针倒回一位。	
range()	建立一个包含指定范围的元素的数组。	
reset()	        将数组的内部指针指向第一个元素。	
rsort()	        对数组逆向排序。	
shuffle()	把数组中的元素按随机顺序重新排列。	
sizeof()	count() 的别名。	
sort()	        对数组排序。	
uasort()	使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。	
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。	
usort()	使用用户自定义的比较函数对数组中的值进行排序。

PHP函数microtime()返回当前 Unix 时间戳和微秒数。

5》》》》strpos()
在使用该函数的时候。里面的位置一定要分清楚，strpos(原字符串，“需要查找的字符串片段”);
谨记谨记谨记

 
6》》》》strcmp()函数
比较两个字符串（区分大小写）：
<?php
echo strcmp("Hello world!","Hello world!");
?>


7》》》》array_unique(array)  函数
该函数用来移除数组中的重复的值，并返回结果数组。
当几个数组元素的值相等时，只保留第一个元素，其他的元素被删除。
返回的数组中键名不变。

1>
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

2>
preg_replace_callback()正则替换回调函数;
3>
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33
4>
is_numeric()   检测变量是否为数字或数字字符串;如果是返回true,不是返回false;
5>
array_unique() 函数移除数组中的重复的值，并返回结果数组.
$unique=array('f','d','f','s');
print_r(array_unique($unique));
结果为：
Array ( [0] => f [1] => d [3] => s ) 
6>
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()
7>
array_filter(array,function);筛选出需要的结果
function myfudction($v)
{
if($v=="H")
{
 
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfudction"));
8>
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 
9>
join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串
10>PHP 面向对象：parent::关键字
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();
11>
这里的$name可以直接用$this->name调用。
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();
12>__construct()构造函数与__destruct()析构函数，前者是在一个类被实例化之前先被自动调用，无返回值，后者则是在销毁一个类之前自动执行一些东西，即两个的执行时间不一样，其他的区别不大。
final 关键字用于定义类和方法，该关键字表示该类或方法为最终版本，即该类不能被继承，或该方法在子类中不能被重载（覆盖）。

13>
__call(1,2) 方法用于监视错误的方法调用。


echo $HTTP_COOKIE_VARS["TestCookie"]; 输出所有cookie值。

mktime()函数适合用来进行日期计算和校验，设定一个固定日期。
echo date('Y-m-d H:i:s',mktime(0,0,0,12,30,1997));  //输出1997-12-30 00:00:00
echo date('Y-m-d H:i:s',mktime(0,0,0,12,32,1997));  //输出1998-01-01 00:00:00


验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间：
<?php 
$str = 'a1234'; 
if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) { 
echo "验证成功";} else { 
echo "验证失敗";}?>


php获取页面中的所有链接地址：（以www.93jiang,com为例）
$str=file_get_contents('http://www.93jiang.com');
  preg_match_all('/<a .*?href="(.*?)".*?>/is',$str,$arrat);
  foreach($arrat[0] as $key=>$value){
  echo $key.'-------'.htmlspecialchars($value).'<br>';
  }
自己调试一下。

php取出网页中所有图片链接
   preg_match_all("/<img([^>]*)\s*src=('|\")([^'\"]+)('|\")/",$str,$aarr);
   var_dump($aarr[0]);

php取出网页中所有邮箱
preg_match_all("/([a-z0-9\-_\.]+@[a-z0-9]+\.[a-z0-9\-_\.]+)/",$str,$mail);
   var_dump($mail);

SQL中DateDiff函数
返回两个日期之间的间隔。
SELECT datediff( month, '1999/07/19', '1999/08/23' )；
结果是：1；
TCP / IP长连接&连接池的应用
Reboot | 2015-11-20 15:28
我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。
TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。
在有些文章里总会提到这名词、或者五元组，甚至七元组。虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：
四元组： 源IP地址、目的IP地址、源端口、目的端口
五元组： 源IP地址、目的IP地址、协议、源端口、目的端口
七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引
在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。
再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。
HTTP的长连接
HTTP长连接，HTTP持久连接（HTTPpersistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。
在HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：
Connection: Keep-Alive
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive
这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
在HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。
然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。
loading...
Keep-Alive的优势
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接
Keep-Alive的劣势
对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。
根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。这个指引旨在提高HTTP响应时间并避免阻塞。
但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。
动静分离
为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。
动静分离同时还会有一个额外的好处：
对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后，请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。
如下表：
loading...
关于Reboot：
专注于互联网运维开发分享、交流，让更多的运维工程师更加专注于自动化，为国内公有云开发、监控、运维贡献自己的力量，这里集聚着国内一线互联网工程师，乐于分享与交流 ^.^发现文章不错的话请关注我们
Reboot QQ交流群：
238757010
365534424
等着   与你一起  改变这世界
一、IT技术文章：
回复"1",查看——“ 如何深入了解linux”
回复"2",查看——“Python 自动化框架”
回复"3",查看——“ Linux 运维职业规划”
回复"4",查看——“提升B格的命令技巧”
回复"5",查看——“网络编程-从Apache到Nginx”
回复"6",查看——“两个使用的Python 装饰器
回复"7",查看——“Python 多线程、进程那些事”
回复"8",查看——“1000，000 packets/s的挑战”
回复"9",查看——“Op危机，你嗅到了没？”
回复"10",查看——“干货丨戏说非阻塞网络编程”
回复"11",查看——“用Python写一个简单的监控系统”
回复"12",查看——“提高你Python 编码效率的‘武林秘籍’”
二、最新课程：
回复"课程",查看——最新课程消息
回复"报名"，查看——报名咨询方式
回复"Reboot",查看——Reboot简介





strstr和strcchr的区别
strstr 显示第一次找到，要查找的字符串，以及后面的字符串。 
strrchr 显示最后一次找到，要查找的字符串，以及后面的字符串。
<?php 
$email = 'test@test.com@jb51.net'; 
$domain = strstr($email, '@'); 
echo "strstr 测试结果 $domain<br>"; 
$domain = strrchr($email, '@'); 
echo "strrchr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 @test.com@jb51.net 
strrchr 测试结果 @jb51.net

strstr与stristr的区别
<?php $email = 'zhangYingy@jb51.net'; 
$domain = stristr($email, 'y'); 
echo "strstr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 y@jb51.net
stristr 测试结果 Yingy@jb51.net

substr用法：
<?php $email = 'zhangYingy@jb51.net'; 
$domain = substr($email, 6); 
echo "substr 测试结果 $domain<br>"; 
?>
结果如下：
substr 测试结果 ingy@jb51.net

php默认变量
echo __FILE__;//这是文件完整的地址为：D:\wamp\wamp\apps\think\test.php
echo __LINE__;//显示这一句所在的行数
echo PHP_VERSION;//显示php版本
echo PHP_OS; //显示php运行系统名称
echo TRUE;  //1,同理FALSE结果为0
echo E_ERROR;
echo "<br>";
//可以用define函数自定义默认变量
define('COPYRIGHT','Copyright');
echo COPYRIGHT;

$testa=array('0'=>array('id'=>14),'1'=>array('id'=>23),'3'=>array('id'=>32));
array_slice($testa,1-1,'id');
var_dump($testa);exit;
用array_slice()可以更换数组的键名，不过如果键名相同，数组会自动添加新的键名，结果会是这样；
array (size=3)
  0 => 
    array (size=1)
      'id' => int 14
  1 => 
    array (size=1)
      'id' => int 23
  3 => 
    array (size=1)
      'id' => int 32


jquery中attr()使用
<script>                                  //用attr设置属性值
$("ul li:eq(1)").attr("title","不吃橘子");
alert($("ul li:eq(1)").attr("title"));
</script>
                                          //用attr删除属性值
<script>
$("ul li:eq(1)").removeAttr ("title");
</script>

urlencode()函数：
本函数将字符串以 URL 编码。例如空格就会变成加号。
Homepage 中 form 资料传送就是用 urlencode 编码后再送出。

bool array_walk ( array &array, callback funcname [, mixed userdata] ) 对数组中的每个成员应用用户函数
array array_map ( callback callback, array arr1 [, array ...] )将回调函数作用到给定数组的单元上
array array_fill ( int start_index, int num, mixed value ) 用给定的值填充数组
array_fill(5, 3, 'a')-->array(5=>'a',6=>'a',7=>'a')
array array_chunk ( array input, int size [, bool preserve_keys] )将一个数组分割成多个


array_multisort()这个函数：
有时候我们需要对二维数组的某个键的值进行排序，这里就是讨论这个问题。
我们可以使用array_multisort()这个函数。array_multisort() 函数对多个数组或多维数组进行排序。

list() 函数:
list() 函数用数组中的元素为一组变量赋值。
注意，与 array() 类似，list() 实际上是一种语言结构，不是函数。
<?php
	$my_array = array("Dog","Cat","Horse");
	list($a, , $c) = $my_array;
	echo "Here I only use the $a and $c variables.";
?>  
运行结果： Here I only use the Dog and Horse variables.

number_format() 函数:
number_format() 函数通过千位分组来格式化数字。
<?php
$num = 500000;

echo number_format($num);
// 500,000

echo number_format($num, 2);
// 500,000.00

echo number_format($num, 3, ".", ",");
// 500,000.000
?>

+++++php5++++++
PHP5常用函数之connection_status() 函数返回当前的连接状态。
　　connection_aborted() 函数检查是否断开客户机。
　　zip_read() 函数读取打开的 zip 档案中的下一个文件。
　　zip_open() 函数打开 ZIP 文件以供读取。
　　zip_entry_read() 函数从打开的 zip 档案项目中获取内容。
　　zip_entry_open() 函数打开一个 ZIP 档案项目以供读取。
　　PHP5常用函数之zip_entry_name() 函数返回 zip 档案项目的名称。
　　zip_entry_filesize() 函数返回 zip 档案项目的原始大小(在压缩之前)。
　　zip_entry_compressionmethod() 函数返回 zip 档案项目的压缩方法。
　　zip_entry_compressedsize() 函数返回 zip 档案项目的压缩文件尺寸。
　　zip_entry_close() 函数关闭由 zip_entry_open() 函数打开的 zip 档案文件。
　　zip_close() 函数关闭由 zip_open() 函数打开的 zip 档案文件。

file_exists($file)    判断文件是否存在
gettype();            获取数据类型

+++++++++file_put_contents()函数+++++++++
file_put_contents(文件名，要加的内容，) 函数把一个字符串写入文件中。
与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。
而file_put_contents(,,FILE_APPEND)则是追加效果，适合用来写日志文件。

//顺序查找算法（数组里查找某个元素）
function seq_sch($array,$n,$k)//在某个位置之前查找某元素(不包括指定位置)
{
$array[$n]=$k;
for($i=0;$i<$n;$i++)
{
if($array[$i]==$k)
break;
}
if($i<$n)
return $i;
else
return -1;
}
$array=array(‘a’,'b’,'c’);
echo seq_sch($array,2,’b');
?>


+++++++++二分查找-递归+++++++++
function bin_search($arr,$low,$high,$value) {
    if($low>$high)
        return false;
    else {
        $mid=floor(($low+$high)/2);
        if($value==$arr[$mid])
            return $mid;
        elseif($value<$arr[$mid])
            return bin_search($arr,$low,$mid-1,$value);
        else
            return bin_search($arr,$mid+1,$high,$value);
    }
}

+++++++++二分查找-非递归+++++++++
function bin_search($arr,$low,$high,$value) {
    while($low<=$high) {
        $mid=floor(($low+$high)/2);
        if($value==$arr[$mid])
            return $mid;
        elseif($value<$arr[$mid])
            $high=$mid-1;
        else
            $low=$mid+1;
    }
    return false;
}

+++++++++归并排序+++++++++
function Merge(&$arr, $left, $mid, $right) {
  $i = $left;
  $j = $mid + 1;
  $k = 0;
  $temp = array();
  while ($i <= $mid && $j <= $right)
  {
    if ($arr[$i] <= $arr[$j])
      $temp[$k++] = $arr[$i++];
    else
      $temp[$k++] = $arr[$j++];
  }
  while ($i <= $mid)
    $temp[$k++] = $arr[$i++];
  while ($j <= $right)
    $temp[$k++] = $arr[$j++];
  for ($i = $left, $j = 0; $i <= $right; $i++, $j++)
    $arr[$i] = $temp[$j];
}
 
function MergeSort(&$arr, $left, $right)
{
  if ($left < $right)
  {
    $mid = floor(($left + $right) / 2);
    MergeSort($arr, $left, $mid);
    MergeSort($arr, $mid + 1, $right);
    Merge($arr, $left, $mid, $right);
  }
}

+++++PHP获得入站的搜索引擎与关键字++++++++
有时候，当我们从搜索引擎进入某个网站，他会有一行小字，“欢迎来自Google/百度，通过检索
“XXX”关键字来到本站”之类的东西。那么这个功能是怎么实现的呢？其实不难，大概思路就是，
获得入站URL，再正则我们需要的数据就行了
<?php
$url=isset($_SERVER['HTTP_REFERER'])?$_SERVER['HTTP_REFERER']:'';//获取入站url。
$search_1 = "google.com"; //q=
$search_2 = "baidu.com"; //wd=
$google = preg_match("/\b{$search_1}\b/",$url);//记录匹配情况，用于入站判断。
$baidu = preg_match("/\b{$search_2}\b/",$url);
$s_s_keyword="";
if ($google)
{
    //来自google
    $s_s_keyword=get_keyword($url,'q=');//关键词前的字符为“q=”。
    $s_s_keyword=urldecode($s_s_keyword);
    //$s_s_keyword=iconv("GBK","UTF-8",$s_s_keyword);//引擎为gbk
}
else if($baidu)
{
    //来自百度
    $s_s_keyword=get_keyword($url,'wd=');//关键词前的字符为“wd=”。
    $s_s_keyword=urldecode($s_s_keyword);
    $s_s_keyword=iconv("GBK","UTF-8",$s_s_keyword);//引擎为gbk
}
echo '$s_s_keyword';
/*
获取来自搜索引擎入站时的关键词。
*/
// 函数作用：从url中提取关键词。参数说明：url及关键词前的字符。
function get_keyword($url,$kw_start)
{
    $start=stripos($url,$kw_start);
    $url=substr($url,$start+strlen($kw_start));
    $start=stripos($url,'&');
    if ($start>0)
    {
        $start=stripos($url,'&');
        $s_s_keyword=substr($url,0,$start);
    }
    else
    {
        $s_s_keyword=substr($url,0);
    }
    return $s_s_keyword;
}
?>


+++++PHP对大文件的处理思路++++++++
需求：现有一个1G左右的日志文件，大约有500多万行， 用php返回最后几行的内容。
使用一些诸如file、file_get_contents之类的函数，这些函数可能就显的力不从心。
这种方式是最为普遍的方式,它不需要将文件的内容全部读入内存,而是直接通过指针来操作,
所以效率是相当高效的.在使用fseek来对文件进行操作时,也有多种不同的方法,
效率可能也是略有差别的,下面是常用的两种方法.
1-->
首先通过fseek找到文件的最后一位EOF，然后找最后一行的起始位置，取这一行的数据，
再找次一行的起始位置，再取这一行的位置，依次类推，直到找到了$num行。
function tail($fp,$n,$base=5)
{
    assert($n>0);
    $pos = $n+1;
    $lines = array();
    while(count($lines)< =$n){
        try{
            fseek($fp,-$pos,SEEK_END);
        } catch (Exception $e){
            fseek(0);
            break;
        }
        $pos *= $base;
        while(!feof($fp)){
            array_unshift($lines,fgets($fp));
        }
    }
    return array_slice($lines,0,$n);
}
var_dump(tail(fopen("access.log","r+"),10));
2-->
还是采用fseek的方式从文件最后开始读,但这时不是一位一位的读,而是一块一块的读,
每读一块数据时,就将读取后的数据放在一个buf里,然后通过换行符(\n)的个数来判断
是否已经读完最后$num行数据.
$fp = fopen($file, "r");
$line = 10;
$pos = -2;
$t = " ";
$data = "";
while ($line > 0) {
    while ($t != "\n") {
        fseek($fp, $pos, SEEK_END);
        $t = fgetc($fp);
        $pos --;
    }
    $t = " ";
    $data .= fgets($fp);
    $line --;
}
fclose ($fp);
echo $data;
还有一种，使用file方法。
ini_set('memory_limit','-1');
$file = 'access.log';
$data = file($file);
$line = $data[count($data)-1];
echo $line;

+++++PHP两种方法生成强密码+++++++++
$totalChar = 8; // 密码中字符串的个数
// salt to select chars from
$salt = "abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNPQRSTUVWXYZ123456789"; 
srand((double)microtime()*1000000); // 启动随机产生器
$Spass=""; // 设置初始值
for ($i=0;$i<$totalChar;$i++) // 循环创建密码
	$Spass = $Spass . substr ($salt, rand() % strlen($salt), 1);
echo $Spass;	

++++$_SERVER['HTTP_REFERER']++++++
<?php echo $_SERVER['HTTP_REFERER'];?>可以得到链接/提交当前页的父页面URL
如果返回“找不到文件”的提示，则可用 header 函数，header("HTTP/1.0 404 Not Found").
写出一个正则表达式，过虑网页上的所有JS/VBS脚本（即把标记及其内容都去掉）.
/<[^>].*?>.*?<\/>/si


++++php数组中对键名与键值的操作+++++++
arra_keys()获得数组键名
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_keys($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => int 1
  1 => int 2
  2 => int 3
array_values()获得数组键值
$arr=array('1'=>'gg','2'=>'sd','3'=>'rg');
$ee=array_values($arr);
var_dump($ee);
结果为：
array (size=3)
  0 => string 'gg' (length=2)
  1 => string 'sd' (length=2)
  2 => string 'rg' (length=2)


+++++++++parse_url()函数:+++++++++
parse_url() 函数可以解析 URL，返回其组成部分。它的用法如下：
array = parse_url( string url );
<?php 
  $url="http://www.nowmagic.net/welcome/";
  $parts=parse_url($url);
  print_r($parts);
?>
结果是：Array ( [scheme] => http [host] => www.nowmagic.net [path] => /welcome/ )  ;

+++++++php实现论坛中无限分类++++++++++
<?php
/*
数据表结构如下:
CREATE TABLE `category` (
`categoryID` smallint(5) unsigned NOT NULL auto_increment,
`categoryParentID` smallint(5) unsigned NOT NULL default '0',
`categoryName` varchar(50) NOT NULL default '',
PRIMARY KEY (`categoryID`)
) ENGINE=MyISAM DEFAULT CHARSET=gbk;
INSERT INTO `category` ( `categoryParentID`, `categoryName`) VALUES
(0, '一级类别'),
(1, '二级类别'),
(1, '二级类别'),
(1, '二级类别'),
(2, '三级类别'),
(2, '333332'),
(2, '234234'),
(3, 'aqqqqqd'),
(4, '哈哈'),
(5, '66333666');
*/
//指定分类id变量$category_id,然后返回该分类的所有子类
//$default_category为默认的选中的分类
function Get_Category($category_id = 0,$level = 0, $default_category =0)
{
global $DB;
$sql = "SELECT * FROM category ORDER BY categoryID DESC";
$result = $DB->query( $sql );
while ($rows = $DB->fetch_array($result))
{
$category_array[$rows[categoryParentID]][$rows[categoryID]] = array('id'=> $rows[categoryID], 'parent' => $rows[categoryParentID], 'name' =>$rows
[categoryName]);
}
if (!isset($category_array[$category_id]))
{
return "";
}
foreach($category_array[$category_id] AS $key => $category)
{
if ($category['id'] == $default_category)
{
echo "<option selectedvalue=".$category['id']."";
}else
{
echo "<option value=".$category['id']."";
}
if ($level > 0)
{
echo ">" . str_repeat( " ", $level ) . "" . $category['name'] . "</option>/n";
}
else
{
echo ">" . $category['name'] ."</option>/n";
}
Get_Category($key, $level + 1, $default_category);
}
unset($category_array[$category_id]);
}
/*
函数返回的数组格式如下所示:
Array
(
[1] => Array ( [id] => 1 [name] => 一级类别[level] => 0 [ParentID] => 0 )
[4] => Array ( [id] => 4 [name] => 二级类别[level] => 1 [ParentID] => 1 )
[9] => Array ( [id] => 9 [name] => 哈哈[level] => 2 [ParentID] => 4 )
[3] => Array ( [id] => 3 [name] => 二级类别[level] => 1 [ParentID] => 1 )
[8] => Array ( [id] => 8 [name] => aqqqqqd [level] => 2[ParentID] => 3 )
[2] => Array ( [id] => 2 [name] => 二级类别[level] => 1 [ParentID] => 1 )
[7] => Array ( [id] => 7 [name] => 234234 [level] => 2[ParentID] => 2 )
[6] => Array ( [id] => 6 [name] => 333332 [level] => 2[ParentID] => 2 )
[5] => Array ( [id] => 5 [name] => 三级类别[level] => 2 [ParentID] => 2 )
[10] => Array ( [id] => 10 [name] => 66333666 [level] => 3[ParentID] => 5 )
)
*/
//指定分类id,然后返回数组
function Category_array($category_id = 0,$level=0)
{
global $DB;
$sql = "SELECT * FROM category ORDER BY categoryID DESC";
$result = $DB->query($sql);
while ($rows = $DB->fetch_array($result))
{
$category_array[$rows['categoryParentID']][$rows['categoryID']] = $rows;
}
foreach ($category_array AS $key=>$val)
{
if ($key == $category_id)
{
foreach ($val AS $k=> $v)
{
$options[$k] =
array(
'id' => $v['categoryID'], 'name' => $v['categoryName'], 'level'=> $level, 'ParentID'=>$v['categoryParentID']
);
$children = Category_array($k, $level+1);
if (count($children) > 0)
{
$options = $options + $children;
}
}
}
}
unset($category_array[$category_id]);
return $options;
}
?>

<?php
class cate
{
       function Get_Category($category_id= 0,$level = 0, $default_category = 0)
       {
            echo$category_id;
            $arr= array(
            '0' => array(
                           '1' => array('id' => 1, 'parent' => 0, 'name' => '1111'),
                           '2' => array('id' => 2, 'parent' => 0, 'name' => '2222'),
                          '4' => array('id' => 4, 'parent' => 0, 'name' =>'4444')    
                        ),
            '1' => array(
                            '3' => array('id' => 3, 'parent' => 1, 'name' => '333333'),
                          '5' => array('id' => 5, 'parent' => 1, 'name' => '555555')    
                          ),
                        
            '3' => array(
                          '6' => array('id' => 6, 'parent' => 3, 'name' => '66666'),
                          '7' => array('id' => 7, 'parent' => 3, 'name' => '77777')
                          ),
            '4' => array(
                          '8' => array('id' => 8, 'parent' => 4, 'name' => '8888'),
                          '9' => array('id' => 9, 'parent' => 4, 'name' => '9999')
                          )    
            );
            if(!isset($arr[$category_id]))
            {
              return "";
            }
    
           foreach($arr[$category_id] AS $key => $cate)
            {
               if ($cate['id'] == $default_category)
               {
                   $txt = "<option selected value=".$cate['id']."";
               }else{
                   $txt = "<option value=".$cate['id']."";
               }
           
               if ($level > 0)
               {
                  $txt1 = ">" . str_repeat( "-", $level ) . " ". $cate['name'] . "</option>/n";
               }else{
                   $txt1 = ">" . $cate['name'] . "</option>/n";
               }
               $val = $txt.$txt1;
               echo $val;
               self::Get_Category($key, $level + 1, $default_category);
            }
           
       }
       
       
       function getFlush($category_id =0,$level = 0, $default_category = 0)
       {
           
           ob_start();
          self::Get_Category($category_id ,$level, $default_category);
           $out =ob_get_contents();
          ob_end_clean();
           return$out;
       }    
}
$id =$_GET['id'];
echo "<select>";
$c = new cate();
//$c->Get_Category();
$ttt=  $c->getFlush($id,'0','3');
echo $ttt;
echo "</select>";
?>



strip_tags()函数:
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果是：Hello NowaMagic!

is_numeric函数：
is_numeric检测变量是否为数字或数字字符串

shuffle（）函数：将数组随机打乱
<?php 
  $data=array('111','222','333','444','555','666');
  shuffle($data);
  print_r($data);
  结果是：Array ( [0] => 222 [1] => 555 [2] => 333 [3] => 111 [4] => 444 [5] => 666 ) 
?>

http_bluid_query()函数：将数组变成url
<?php 
  $data = array(
   'site'=>'www.nowamagic.net', 
	'foo'=>'bar', 
	'baz'=>'boom', 	
	'name'=>'nowamagic'); 
  echo http_build_query($data); 
?>
结果为：site=www.nowamagic.net&foo=bar&baz=boom&name=nowamagic

stream_context_create()函数：
stream_context_create() 作用：创建并返回一个文本数据流并应用各种选项，
可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。

php查看本地目录glob()和scandir()
glob()函数
$img=array('gif','png','jpg');
$dir='img/';  //查找的文件名所在目录
$pic=array();
foreach($img as $k=>$v){
	$pattern=$dir.'*.'.$v;
	$all=glob($pattern);
	$pic=array_merge($pic,$all);
}
var_dump($pic);
foreach($pic as $p){
echo $p.'<br>';
}
上面的等同于：
$files=glob('img/*.jpg');
print_r($files);

结果均为：
array (size=2)
  0 => string 'img/test.jpg' (length=12)
  1 => string 'img/test2.jpg' (length=13)

scandir()函数：
$dir='img/';
$file=scandir($dir);
print_r($file);

结果为：
Array ( [0] => . [1] => .. [2] => test.jpg [3] => test2.jpg ) 


数组比较函数 array_diff()与array_diff_assoc()函数
array_diff_assoc() 函数返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键和值。
和 array_diff()函数不同，本函数要求键名和键值都进行比较。返回的数组中键名保持不变。
array_diff() 能比较key和value，而实际上它只比较了value，而不关心key，如果关心key的话，可以使用函数array_diff_assoc().

php数组求交集的array_intersect()函数与array_intersecct_assoc()函数：
array_intersect        计算数组的交集，只关心value，不关心key；
array_intersect_assoc  带索引检查计算数组的交集。

序列化与反序列化
序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这
两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 
PHP中的序列化和反序列化分别通过函数serialize()和unserialize()即可实现。
serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将serialize的返回结果作为参数，进行反序列化，得到原对象。

json_encode()与json_decode()
这是PHP的原生函数，然而在今天JSON越来越流行，所以在PHP5.2以后，
PHP开始支持JSON，你可以使用 json_encode() 和 json_decode() 函数


文件压缩的原理：
电脑是采用二进制的，所以就全是1和0两个数字。那么难免的有的时候会重复出现，比如：10101010101010101010101010101010，那么就是16个10于是压缩的时候就记做16个10。
然后我们把16换算为二进制的，就是1000。那么电脑就会写成100010。当然，这其中一定还会有一些记号。只是我不太清楚而已。然后在解压的时候就可以把100010还原为10101010101010101010101010101010。
那么一算，就把本来的32位的数字变为了6位。所以就达到了压缩的目的！
php字符串压缩与解压缩：

php扫描本地目录与文件：
header('content-type:text/html; charset=utf-8');
   $dirname='Public'; //要遍历的目录名字
   $dir_handle=opendir($dirname);
    echo '<table border="1" align="center" width="960px" cellspacing="0" cellpadding="0">';
   echo '<caption><h2>目录'.$dirname.'下面的内容</h2></caption>';
   echo '<tr align="left" bgcolor="#cccccc">';
   echo '<th>文件名</th><th>文件大小</th><th>文件类型</th><th>修改时间</th><th>完整路径</th><th>test1</th><th>test2</th></tr>';
   while($file=readdir($dir_handle))
   {
     if($file!="."&&$file!="..")
     {
        $dirFile=$dirname."/".$file;	
        echo '<td>'.$file.'</td>';
        echo '<td>'.filesize($dirFile).'</td>';
        echo '<td>'.filetype($dirFile).'</td>';
        echo '<td>'.date("Y/n/t",filemtime($dirFile)).'</td>';
		echo '<td>'.$dirFile.'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filectime($dirFile)).'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filemtime($dirFile)).'</td>';
        echo '</tr>';
     }
   }
   echo '</table>';
   closedir($dir_handle);

filectime — 取得文件的 inode 修改时间
filemtime — 取得文件修改时间
fileatime — 取得文件上次访问时间
fileperms -- 取得文件的访问权限
is_executable — 判断给定文件名是否可执行


PHP/Mysql中几个版本的进化史，比如mysql4.0到4.1，PHP 4.x到5.1的重大改进等等：
MySQL：  
一、从 4.0 到 4.1 的主要变化  
  
如果在4.1.0到4.1.3版本的MySQL中创建了包含 TIMESTAMP 字段的 InnoDB表。则在升级到4.1.4及更高时需要重建表，因为存储格式发生变化了。  
  
字符串根据标准SQL来比较：比较之前不删除末尾的空格，以前用末尾空格扩展了比较短的字符串。现在的结果是  
  
'a' > 'a\t'，以前则不这样。可以用 mysqlcheck 来检查一下数据表。  
  
TIMESTAMP 返回 'YYYY-MM-DD HH:MM:SS' 格式的字符串。在MySQL 4.0中，可以增加选项 --new 来获得ySQL 4.1中这方面的特性。  
  
在MySQL4.1.1前，语句解析器不是那么严格，它在处理字符串转时间转换时会忽略第一个数字前的其他字符。在4.1.1之后，就比较严格了，返回结果是 DATE, DATETIME, 或 TIME 类型的函数的结果会被转换成时间型  
  
二、再看从 4.1 到 5.0 的主要变化  
  
◆InnoDB 和 MyISAM 表中空格结尾的 TEXT 字段索引顺序改变了。因此需要运行"CHECK TABLE" 语句修复数据表，如果出现错误，就运行 "OPTIMIZE TABLE" 或 "REPAIR TABLE" 语句修复，甚至重新转储(用mysqldump)。  
  
◆MySQL 5.0.15开始，如何处理 BINARY 字段中填充的值已经改变了。填充的值现在是0x00 而非空格了，并且在取值的时候不会去除末尾的空格。  
  
◆从MySQL 5.0.3开始，DECIMAL 的实现方式已经改变了，5.0对 DECIMAL的格式限制严格多了。在MySQL 5.0.3到5.0.5之间版本的 MyISAM 和 InnoDB 表中创建的 DECIMAL字段升级到5.0.6之后会发生崩溃。从5.0.3开始，DECIMAL 用更有效的格式来存储。5.0.3开始，在计算 DECIMAL 值和舍入精确值的时候采用精确数学。  
  
◆在以前，等待超时的锁会导致 InnoDB回滚当前全部事务，从5.0.13开始，就只回滚最近的SQL语句了。  
  
◆在4.1.13/5.0.8以前，DATETIME 的加0后就转换成 YYYYMMDDHHMMSS 格式，现在变为YYYYMMDDHHMMSS.000000 格式了  
  
◆4.1中，FLOAT 或 DOUBLE 之间的比较碰巧没问题，但在5.0中可能就不行了  
  
◆从5.0.3开始，VARCHAR 和 VARBINARY 字段中末尾的空格不再删除  
  
◆增加了一个新的启动选项 innodb_table_locks，它导致 LOCK TABLE 时也可以请求InnoDB 表锁。这个选项默认打开，不过可能在 AUTOCOMMIT=1 和 LOCK TABLES应用中会导致死锁。看来，我只需主要关注 时间(TIMESTAMP, DATETIME< DATE, TIME) 和数值型(FLOAD, DOUBLE, DECIMAL) 这两种类型的变化;另外，我升级过程中暂时还不需要涉及到字符集问题，因此相对轻松一些。  
  
升级步骤如下：  
  
执行  
  
FLUSH TABLES WITH READ LOCK;  
  
直接拷贝 MyISAM 表文件  
  
用 mysqldump 导出 Innodb 类型的表  
  
整个过程都很顺利，新系统启动之后，发现如下2个问题：  
  
新增了关键字 INOUT，因此需要检查表结构中还有其他什么字段使用关键字了  
  
DATE_FORMAT 函数要求严谨多了，  
  
DATE_FORMAT('2006/11/24 09:14:00', '%Y-%m-%d %T')   
和DATE_FORMAT('2006/11/2409:14:00', '%Y-%m-%d %T')  
  
的结果完全不一样，在 4.0 中，能兼容这两种格式，而在 5.0 中，只能正确的使用前者了，后者则会有问题。这也应该是上面提到的时间类型发生的变化所致。  

PHP5以下几个改进值得关注：  
1、极大地提高了面向对象能力；  
2、支持try/catch异常处理；  
3、改进了字符串地处理；  
4、改经了xml和web服务支持；  
5、对SQlite内置支持。  

一些php魔幻方法;
php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。  
PHP中的魔术方法有 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone, __autoload  
1、__get、__set  
这两个方法是为在类和他们的父类中没有声明的属性而设计的  
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名  
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值  
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）。  
2、__isset、__unset  
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法  
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法  
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）  
3、__call  
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法  
这里的未定义的方法包括没有权限访问的方法；如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方​法，如果本类中不存在__call()方法就去找父类中的__call()方法  
  
4、__autoload  
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。  
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：  
view plaincopy to clipboardprint?  
<?php    
class Loader    
{    
static function autoload_class($class_name)    
{    
//寻找正确的$class_name类，并引入，没有则抛出异常    
}    
}    
    
/** 
*   设置对象的自动载入 
*   spl_autoload_register — Register given function as __autoload() implementation 
*/    
spl_autoload_register(array('Loader', 'autoload_class'));    
    
$a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类    
    
?>    
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。  
5、__construct、__destruct  
__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称  
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。  
在一个函数的命名空间内，这会发生在函数return的时候。  
对于全局变量,这发生于脚本结束的时候。  
如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.  
6、__clone  
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。  
7、__toString  
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。  
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in  
此方法必须返回一个字符串。  
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。  
8、__sleep、__wakeup  
__sleep 串行化的时候用  
__wakeup 反串行化的时候调用  
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。  
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。  
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。  
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。  
9、__set_state  
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。  
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。  
10、__invoke  
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。  
PHP5.3.0以上版本有效  
11、__callStatic  
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，  
PHP5.3.0以上版本有效  
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此  

使用POSIX兼容规则的函数有：  
ereg_replace()  
ereg()  
eregi()  
eregi_replace()  
split()  
spliti()  
sql_regcase()  
mb_ereg_match()  
mb_ereg_replace()  
mb_ereg_search_getpos()  
mb_ereg_search_getregs()  
mb_ereg_search_init()  
mb_ereg_search_pos()  
mb_ereg_search_regs()  
mb_ereg_search_setpos()  
mb_ereg_search()  
mb_ereg()  
mb_eregi_replace()  
mb_eregi()  
mb_regex_encoding()  
mb_regex_set_options()  
mb_split()  
  
使用PERL兼容规则的函数有：  
preg_grep()  
preg_replace_callback()  
preg_match_all()  
preg_match()  
preg_quote()  
preg_split()  
preg_replace()  

++++++++++PHP实现等差数列求和(不使用乘法,循环,递归) ++++++++++

<html>
     <body>
         <?php
            function sum_n($a1, $d, $an) {    //$a1为首项,$d为公差,$an为最大项
                $sum = 0;
                $i = $a1;
                a:
                $sum += $i;
                $i += $d;
                if($i <= $an) goto a;
                return $sum;
            }
            
            echo sum_n(1, 1, 10);
         ?>
     </body>
 </html>

写代码来解决多进程/线程同时读写一个文件的问题：
大家都知道，PHP是没有多线程概念的，尽管如此我们仍然可以用“不完美”的方法来模拟多线程。简单的说，就是队列处理。通过对文件进行加锁和解锁，来实现。当一个文件被一个用户操作时，该文件是被锁定的，其他用户只能等待，确实不够完美，但是也可以满足一些要求不高的应用。  
function T_put($filename,$string){  
$fp = fopen($filename,’a'); //追加方式打开  
if (flock($fp, LOCK_EX)){ //加写锁  
fputs($fp,$string); //写文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
}  
function T_get($filename,$length){  
$fp = fopen($filename,’r'); //追加方式打开  
if (flock($fp, LOCK_SH)){ //加读锁  
$result = fgets($fp,$length); //读取文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
return $result;  
}  

MyISAM 与Innodb
简单的表达。  
MyISAM 是非事务的存储引擎。  
innodb 是支持事务的存储引擎。  
  
innodb    的引擎比较适合于插入和更新操作比较多的应用  
而MyISAM  则适合用于频繁查询的应用  
  
MyISAM    --表锁。  
innodb    --设计合理的话是行锁。  
MyISAM    不会出现死锁。  
  
最大的区别就是MYISAM适合小数据，小并发；INNODB 适合大数据，大并发。最大的区别就是在锁的级别上。  
  
MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 MyISAM类型的表强调的是性能，
其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等
高级数据库功能。综述，就可以根据数据表不同的用处是用不同的存储类型。而且MyISAM是文件存储
的，可以进行直接在不同操作系统间拷贝使用。  
   
InnoDB：  
InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
InnoDB 提供了行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)。
这些特性均提高了多用户并发操作的性能表现。在InnoDB表中不需要扩大锁定(lock escalation)，
因为 InnoDB 的列锁定(row level locks)适宜非常小的空间。InnoDB 是 MySQL 上第一个提供外键约束(FOREIGN KEY constraints)的表引擎。
InnoDB 的设计目标是处理大容量数据库系统，它的 CPU 利用率是其它基于磁盘的关系数据库引擎所不能比的。
在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
 InnoDB 把数据和索引存放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 MyISAM 中，表被存放在单独的文件中。
InnoDB 表的大小只受限于操作系统的文件大小，一般为 2 GB。
InnoDB所有的表都保存在同一个数据文件 ibdata1 中（也可能是多个文件，或者是独立的表空间文件），相对来说比较不好备份，可以拷贝文件或用navicat for mysql。  
   
MyISAM  
每张MyISAM 表被存放在三个文件 ：frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex) 引伸。  
因为MyISAM相对简单所以在效率上要优于InnoDB，小型应用使用MyISAM是不错的选择。  
MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦  

2.web 架构，安全,项目经验

++++++++++介绍xdebug,apc,eAccelerator,Xcache,Zend opt的使用经验++++++++++++
Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况
。
eAccelerator是一个自由开放源码php加速器，优化和动态内容缓存，提高了php脚本的缓存性能，
使得PHP脚本在编译的状态下，对服务器的开销几乎完全消除。它还有对脚本起优化作用，以加快其执行效率。
使您的PHP程序代码执效率能提高1-10倍；
XCache 是一个开源的 opcode 缓存器/优化器, 这意味着他能够提高您服务器上的 PHP 性能. 他通过把编译 
PHP 后的数据缓冲到共享内存从而避免重复的编译过程, 能够直接使用缓冲区已编译的代码从而提高速度. 
通常能够提高您的页面生成速率 2 到5 倍, 降低服务器负载.
Zend Optimizer(以下简称ZO)用优化代码的方法来提高php应用程序的执行速度。实现的原理是对那些在被最终
执行之前由运行编译器(Run-TimeCompiler)产生的代码进行优化。
一、PHP加速器介绍

        PHP加速器是一个为了提高PHP执行效率，从而缓存起PHP的操作码，这样PHP后面执行就不用解析转换了，可以直接调用PHP操作码，这样速度上就提高了不少。

        Apache中使用mod_php的请求、响应执行流程：

　　1、Apache接收请求。
2、Apache传递请求给mod_php。
3、mod_php定位磁盘文件，并加载到内存中。
4、mod_php编译源代码成为opcode树。
5、mod_php执行opcode树。

       PHP加速器相应的就是第四步，它的目的就是防止PHP每次请求都重复编译PHP代码，因为在高访问量的网站上，大量的编译往往没有执行速度快呢？所以这里面有个瓶颈就是PHP的重复编译既影响了速度又加载了服务器负载，为了解决此问题，PHP加速器就这样诞生了。

二、PHP加速器安装与配置

        1、安装配置APC

             APC全称是Alternative PHP Cache,官方翻译叫”可选PHP缓存”,它是PHP PECL中的一个扩展，好像是facebook在使用它，下面开始安装（ubuntu环境）： 
$wget http://pecl.php.net/get/APC-3.0.19.tgz
$tar xvzf APC-3.0.19.tgz
$cd APC-3.0.19/APC-3.0.19
$/usr/local/php/bin/phpize
$./configure –enable-apc –enable-apc-mmap –with-php-config=/usr/local/php/bin/php-config
$make
$sudo make install

下面我们再配置APC,因为我的PECL扩展路径改变了，所以我得移动下编译好的文件：
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/apc.so /usr/local/php/lib/php/extensions/PECL

然后我们再编辑php.ini文件进行配置，请把下面的代码加入到php.ini中即可：
extension_dir = "/usr/local/php/lib/php/extensions/PECL"
extension = apc.so
; APC
apc.enabled = 1
apc.shm_segments = 1
apc.shm_size = 64
apc.optimization = 1
apc.num_files_hint = 0
apc.ttl = 0
apc.gc_ttl = 3600
apc.cache_by_default = on

     这样重启apache就会在phpinfo()信息中显示。

       2、安装配置eAccelerator

          eAccelerator的前身其实是truck-mmcache，因为开发truk-mmcache的人被Zend给招安了，所以开发eAccelerator的人继承了truk-mmcache的一些特性，设计出eAccelerator加速器。安装如下：
$wget http://jaist.dl.sourceforge.net/sourceforge/eaccelerator/eaccelerator-0.9.5.tar.bz2
$tar -jxf eaccelerator-0.9.5.tar.bz2
$cd eaccelerator-0.9.5
$/usr/local/php/bin/phpize
$./configure –enable-eaccelerator=shared –with-php-config=/usr/local/php/bin/php-config
$make
$sudo make install
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/eaccelerator.so /usr/local/php/lib/php/extensions/PECL

将下面代码加入php.ini文件中
extension = eaccelerator.so
; eAccelerator
eaccelerator.shm_size = "16"
eaccelerator.cache_dir = "/tmp/eaccelerator"
eaccelerator.enable = "1"
eaccelerator.optimizer = "1"
eaccelerator.check_mtime = "1"
eaccelerator.debug = "0"
eaccelerator.filter = ""
eaccelerator.shm_max = "0"
eaccelerator.shm_ttl = "0"
eaccelerator.prune_period = "0"
eaccelerator.shm_only = "0"
eaccelerator.compress = "1"
eaccelerator.compress_level = "9"

创建缓存目录,重启apache

$sudo mkdir /tmp/eaccelerator
$sudo chmod 777 /tmp/eaccelerator
$sudo /usr/local/apache/apachectl restart

在phpinfo()检查是否安装成功.

3、安装配置XCache

XCache作为国人自己开发的东西，做小菜鸟的我也感到骄傲，而且XCache无论在速度还是性能上都做的不错。下面就赶紧让我们品尝它吧！

$wget http://xcache.lighttpd.net/pub/Releases/1.2.2/xcache-1.2.2.tar.gz
$tar xvzf xcache-1.2.2.tar.gz
$cd xcache-1.2.2
$/usr/local/php/bin/phpize
$./configure –enable-xcache –enable-xcache-coverager –with-php-config=/usr/local/php/php-config
$make
$sudo make install
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/xcache.so /usr/local/php/lib/php/extensions/PECL

在php.ini添加配置信息：

extension = xcache.so
; xcache
xcache.admin.user = "admin"
xcache.admin.pass = "(执行) echo ’(你的密码)’|md5sum(得出的密文)"
;
xcache.size = 24M
xcache.shm_scheme = "mmap"
xcache.count = 2
xcache.slots = 8k
xcache.ttl = 0
xcache.gc_interval = 0

xcache.var_size = 8M
xcache.var_count = 1
xcache.var_slots = 8k
xcache.var_ttl = 0
xcache.var_maxttl = 0
xcache.var_gc_interval = 300
xcache.test = Off
xcache.readonly_protection = On
xcache.mmap_path = "/tmp/xcache"
xcache.coredump_directory = ""
xcache.cacher = On
xcache.stat = On
xcache.optimizer = Off
;
xcache.coverager = On
xcache.coveragedump_directory = ""

创建缓存目录，重启apache

$sudo mkdir /tmp/xcache
$sudo chmod 777 /tmp/xcache
$sudo /usr/local/apache/bin/apachectl restart
去查看phpinfo()信息吧！
   1、通过测试得出eAccelerator在请求时间和内存占用综合方面是最好的。

   2、通过测试得出使用加速器比无加速器在请求时间快了3倍左右。

   3、通过各个官方观察，XCache是更新最快的，这也说明最有发展的。

 以上是总结结果，你也许会问我到底用那个加速器好呢？我只能告诉你，首先，用一定比不用好，
其次每个加速器还有一些可以调优的参数，所以要根据你的系统环境而定，然后，我个人觉得你可以详细研
究下eAccelerator和XCache，这两款潜力还是很大的.


++++++++++++使用mod_rewrite,在服务器上没有/archivers/567.html这个物理文件时，重定向到index.php?id=567 ,请先打开mod_rewrite++++++++++++

++++++++++++MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？++++++++++++

++++++++++++写出一种排序算法（原理），并说出优化它的方法。++++++++++++
php冒泡排序：

原理：
依次比较相邻的两个数，将小数放在前面，大数放在后面。即首先比较第1个和第2个数，
将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
直至比较最后两个数，将小数放前，大数放后。重复以上过程，仍从第一对数开始比较
（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，
大数放后，一直比较到最大数前的一对相邻数，将小数放前，大数放后，第二趟结束，
在倒数第二个数中得到一个新的最大数。如此下去，直至最终完成排序。
在许多程序设计中，我们需要将一个数列进行排序，以方便统计，常见的排序方法有冒泡排序，
二叉树排序，选择排序等等。而冒泡排序一直由于其简洁的思想方法和比较高的效率而倍受青睐。
由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。
function bubble_sort($array)  
{  
    $count = count($array);  
    if($count <= 0)  
    {  
        return false;  
    }  
    for($i=0; $i<$count; $i++)  
    {  
        for($k=$count-1; $k>$i; $k--)  
        {  
            if($array[$k] < $array[$k-1])  
            {  
                $tmp = $array[$k];  
                $array[$k] = $array[$k-1];  
                $array[$k-1] = $tmp;  
            }  
        }  
    }  
    return $array;  
}  
冒泡原理：两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。

php快排算法：
function quick_sort($arr){
	$length=count($arr);
	if($length<=1){
		return $arr;
	}
	$base_num=$arr[0];
        //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内，初始化两个数组
	$left_array=array();   //这是小于标准的
	$right_array=array();  //这是大于标准的
	for($i=1;$i<$length;$i++){
		if($base_num>$arr[$i]){
				$left_array[]=$arr[$i];//放入左边数组
			}
			else{
       			     $right_array[]=$arr[$i];  //放入右边数组
				}
	}
  //再分别对左边和右边的数组进行相同的排序处理方式
  //递归调用这个函数,并记录结果
  $left_array=quick_sort($left_array);
  $right_array=quick_sort($right_array);
  //合并左边标尺右边
  return array_merge($left_array,array($base_num),$right_array);
}


插入排序算法：
function insert_sort($arr){
 for($i=1,$len=count($arr);$i<$len;$i++){
      $tmp=$arr[$i];
      for($j=$i-1;$j>=0;$j--){
           if($tmp<$arr[$j])  {
                $arr[$j+1]=$arr[$j];
                 $arr[$j]=$tmp;
           }
         else{
              break;
              }
      }
  }
return $arr;
}


二叉树排序算法：
    <?php
 2     //二叉树的广度优先遍历
 3     //使用一个队列实现
 4  
 5      class Node {
 6          public $data = null;
 7          public $left = null;
 8          public $right = null;
 9      }
10  
11      //@param $btree 二叉树根节点
12      function breadth_first_traverse($btree) {
13          $traverse_data = array();
14          $queue = array();
15          array_unshift($queue, $btree); #根节点入队
16          
17          while (!empty($queue)) { #持续输出节点，直到队列为空
18              $cnode = array_pop($queue); #队尾元素出队
19              $traverse_data[] = $cnode->data;
20  
21              #左节点先入队，然后右节点入队
22              if ($cnode->left != null) array_unshift($queue, $cnode->left);
23              if ($cnode->right != null) array_unshift($queue, $cnode->right);
24          }
25  
26          return $traverse_data;
27      }
28 
29      #深度优先遍历,使用一个栈实现
30      function depth_first_traverse($btree) {
31         $traverse_data = array();
32         $stack = array();
33         array_push($stack, $btree);
34 
35         while (!empty($stack)) {
36             $cnode = array_pop($stack);
37             $traverse_data[] = $cnode->data;
38 
39             if ($cnode->right != null) array_push($stack, $cnode->right);
40             if ($cnode->left != null) array_push($stack, $cnode->left);
41         }
42 
43         return $traverse_data;
44      }
45  
46      $root = new Node();
47      $node1 = new Node();
48      $node2 = new Node();
49      $node3 = new Node();
50      $node4 = new Node();
51      $node5 = new Node();
52      $node6 = new Node();
53  
54      $root->data = 1;
55      $node1->data = 2;
56      $node2->data = 3;
57      $node3->data = 4;
58      $node4->data = 5;
59      $node5->data = 6;
60      $node6->data = 7;
61  
62      $root->left = $node1;
63      $root->right = $node2;
64      $node1->left = $node3;
65      $node1->right = $node4;
66      $node2->left = $node5;
67      $node2->right = $node6;
68  
69      $traverse = breadth_first_traverse($root);
70      print_r($traverse);
71      echo "<br>";
72      $traverse = depth_first_traverse($root);
73      print_r($traverse);
74  ?>
 

++++++++++mysql_connect 与 memcache_connect 应该哪个在在前，哪个在后++++++++++
答案应该是先 memcache_connect 再 mysql_connect,因为memcache存在不稳定因素，容易发生阻塞，
一旦memcache发生阻塞，如果是先mysql_connect,就会造成生成大量mysql空链接而无法释放
一个类似的问题是 echo $html 和 mysql_connect应该哪个在前
按照网上看到的以为叫caoz的朋友的说法，应该是mysql_connect在前，echo $html会等待网络传输，
并发量高的时候会造成数据库链接的阻塞
++++++++++Apache可以被配置为正向(forward)和反向(reverse)代理。++++++++++ 
正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个
请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要
进行一些特别的设置才能使用正向代理。 
    正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用
缓冲特性(由mod_cache提供)减少网络使用率。 使用ProxyRequests指令即可激活正向代理。因为正向代理
允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端
提供服务.
   反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。
客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)
转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。
    反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多
台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，还可以启用高级URL策略和管理技术，
从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 可以使用ProxyPass指令激活反向
代理。配置反向代理并不需要打开ProxyRequests指令
+++++++++++对于大流量的网站,您采用什么样的方法来解决各页面访问量统计问题+++++++++++
确认服务器硬件是否足够支持当前的流量,数据库读写分离,优化数据表, 
程序功能规则,禁止外部的盗链,控制大文件的下载,使用不同主机分流主要流量
+++++++++++请介绍Session的原理,大型网站中Session方面应注意什么?+++++++++++
运行机制:客户端将session id传递到服务器，服务器根据session id找到对应的文件，读取的时候对文件内容
进行反序列化就得到session的值，保存的时候先序列化再写入。
注意:1,session在大访问量网站上确实影响系统性能，影响性能的原因之一由文件系统设计造成，
在同一个目录下超过10000个文件时，文件的定位将非常耗时,可以通过修改php.ini中session.save_path设置
两级子目录 ,session将存储在两级子目录中，每个目录有16个子目录[0~f]，不过好像PHP session不支持创
建目录，你需要事先把那么些目录创建好 。
2,还有一个问题就是小文件的效率问题,可以通过存储方式中的memcache来解决I/O效率低下的问题
3,session同步问题,session同步有很多种，如果你是存储在memcached或者MySQL中，那就很容易了，
指定到同样的位置即可,还有一种方法就是在负载均衡那一层保持会话，把访问者绑定在某个服务器上，
他的所有访问都在那个服务器上就不需要session同步了
+++++++++++测试php性能和mysql数据库性能的工具,和找出瓶颈的方法。+++++++++++
xhprof  PHP性能测试工具。   MySQL 的企业监控器（Enterprise Monitor）也是值得考虑的工具之一
+++++++++++正则提出一个网页中的所有链接.+++++++++++
/(http:\/\/\[^" ']+)/gm ;
/href *= *['"]*(\S+)["']* */gm ;
preg_match_all('/a href=[\"\']|/src=[\"\']([^\"\' ]+)/i',$var,$match);
+++++++++++介绍一下常见的SSO(单点登陆)方案(比如dedecms整合discuz的passport)的原理。+++++++++++
单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在
其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，
例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系
统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯
掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，
因此要点也就以下几个：
存储信任
验证信任
如何高效存储大量临时性的信任数据
如何防止信息传递过程被篡改
如何让SSO系统信任登录系统和免登系统
对于第一个问题，一般可以采用类似与memcached的分布式缓存的方案，既能提供可扩展数据量的机制，也能
提供高效访问。对于第二个问题，一般采取数字签名的方法，要么通过数字证书签名，要么通过像md5的方式，
这就需要SSO系统返回免登URL的时候对需验证的参数进行md5加密，并带上token一起返回，最后需免登的系统
进行验证信任关系的时候，需把这个token传给SSO系统，SSO系统通过对token的验证就可以辨别信息是否被
改过。对于最后一个问题，可以通过白名单来处理，说简单点只有在白名单上的系统才能请求生产信任关系，
同理只有在白名单上的系统才能被免登录。
+++++++++++您写过的PHP框架的特点，主要解决什么问题，与其他框架的不同点。+++++++++++
+++++++++++大型的论坛/新闻文章系统/SNS网站在性能优化上有什么区别?+++++++++++
新闻媒体注意细览页的性能优化，比如图片、结构，保持清爽；
SNS注意交互、页面JS、ajxa、动态内容大小；
严格控制大小、减少定向、压缩图片、降低CSS加载速度，利用好缓存，这是通的
+++++++++++相册类应用:要求在浏览器中能同时选中并上传多个文件，图片要求能剪裁，压缩包在服务器端解压。能上传单个达50M的文件。上传过程中有进度条显示。+++++++++++
+++++++++++每个图片能生成四种大小缩略图，视频文件要转成flv供flash播放。叙述要涉及的各类开源软件和简单用途。+++++++++++
+++++++++++一 群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，
在把它踢出去…，如此不停的 进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。
要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。用程序模拟该过程。+++++++++++
1 <html>
 2     <body>        
 3         <?php
 4             function monkeyKing($n, $m) {    //$n为猴子总数,$m为剔除猴子步长
 5                 $s = 0;    //$s为大王坐标,只有一只猴子时,大王坐标为0
 6                 for($i = 2; $i <= $n; $i++) {    //依次向后递推,求到共有$n只猴子,剔除步长为$m时的大王坐标
 7                     $s = ($s + $m) % $i;    //大王坐标递推公式
 8                 }
 9                 return $s;
10             }
11             
12             echo monkeyKing(6, 2);
13         ?>
14     </body>
15 </html>
+++++++++++MySQL数据库，怎么优化？+++++++++++
(1)配置优化（服务器配置）   (2)建表优化（表、字段设置） (3)查询优化（sql语句） 答： 1、选取最适用
的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM 2、
使用连接（JOIN）来代替子查询: 3、使用联合(UNION)来代替手动创建的临时表 4、事务处理: 5、锁定表,
优化事务处理: 6、使用外键,优化锁定表 7、建立索引: 8、优化查询语句
+++++++++++写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。（目录操作）+++++++++++
$d = dir(dirname(__file__));

echo "Handle: " . $d->handle . "\n";

echo "Path: " . $d->path . "\n";

while ( false !== ($entry = $d->read ()) ) {

echo $entry . "";

}

$d->close ();
+++++++++++怎么防止sql注入？+++++++++++
答：①、过滤用户提交的内容，比如update、insert、select、delete、*等数据库操作的关键字。
    ②、使用函数addslashes()转义提交的内容。
③、Php配置文件中开启magic_quotes_gpc=on;将自动转换用户查询的sql语句，对防sql注入有重大作用。
④、在php配置文件中将register_globals设置为off，关闭全局变量注册。
⑤、在php配置文件中开启安全模式safe_mode=on;
⑥、Sql语句的书写尽量不要省略小引号和单引号。
⑦、提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的名称。
⑧、控制错误信息，关闭错误信息的输出，将错误信息写到日志文件中，不要在网站暴漏错误信息。
+++++++++++数据库索引有几类，分别是什么？什么时候该用索引？+++++++++++
答：①主键索引，它用于根据主键自身的唯一性来唯一标识每条记录。因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如自增加整数值。这样，无论以后是否删除以前存在的记录，每条记录都有唯一的主键索引。
②与主键索引一样，唯一索引可以防止重建重复的值。但是，不同之处在于，每个表只能有一个主键索引，但可以有多个唯一索引。
     ③常规索引。经常希望对非主键甚至并非唯一的字段上的搜索进行优化。（1）如果表中的某个列将成为大量选择查询的焦点，就应当使用单列常规索引。并且一般指定列的前N个字符对于确保唯一性已经足够，如：INDEX(lastname(5))。（2）如果指定列会经常在获取查询中一起使用，则推荐使用多列索引。Mysql的多列索引方法基于一种称为最左前缀的策略。
     ④全文索引。提供了一种高效的方法来搜索存储在CHAR、VARCHAR或者TEXT类型中的文本。Mysql默认会忽略少于4个字符的关键字。Boolean全文搜索对搜索查询提供了更细粒度的控制，允许显示的标识结果中应当或不应当出现哪些单词。
索引最佳实践
只对where和order by子句中需要的列添加索引。多余的索引会导致不必要的硬盘空间消耗，在修改表信息的时候会降低性能。有索引的表在性能会降低，这是由于每次修改记录都必须更新索引。
如果创建诸如INDEX(firstname,lastname)的索引，不要再创建INDEX(firstname),因为mysql能搜索索引前缀。不过，要记住只有前缀有索引，这个多列索引不能应用于对lastname的搜索。
对于准备索引的列要使用属性NOT NULL，这样就永远不会存在存储NULL值。
对不使用索引的查询，使用选项—log-long-format来记录日志。然后可以检查日志文件，对查询进行相应的调整。
EXPLAIN语句有助于确定mysql如何执行查询，展示表是如何连接的，以及按怎样的顺序连接。
+++++++++++引用传值和非引用传值的区别，什么时候该用引用传值，什么时候该用非引用传值+++++++++++
答：按值传递：函数内对值的任何改变在函数外都被忽略。
引用传值：函数内对值的任何改变在函数外也将反映出这些修改。
按值传递时php必须复制值，操作大型对象和字符串这将是代价很大的操作。按引用传值不需要复制值，对性能的提高有好处。
当需要在函数内改变原变量的值时用引用传值，如果不想改变原变量的值时用传值。
+++++++++++PHP遍历文件夹及子文件夹所有文件 +++++++++++
1 <html>
 2     <body>
 3         <?php
 4             function traverse($path = '.') {
 5                 $current_dir = opendir($path);    //opendir()返回一个目录句柄,失败返回false
 6                 while(($file = readdir($current_dir)) !== false) {    //readdir()返回打开目录句柄中的一个条目
 7                     $sub_dir = $path . DIRECTORY_SEPARATOR . $file;    //构建子目录路径
 8                     if($file == '.' || $file == '..') {
 9                         continue;
10                     } else if(is_dir($sub_dir)) {    //如果是目录,进行递归
11                         echo 'Directory ' . $file . ':<br>';
12                         traverse($sub_dir);
13                     } else {    //如果是文件,直接输出
14                         echo 'File in Directory ' . $path . ': ' . $file . '<br>';
15                     }
16                 }
17             }
18             
19             traverse('xxtt');
20         ?>
21     </body>
22 </html>
 +++++++++++PHP中单引号双引号的区别 +++++++++++
1.双引号可以解析变量表达式,单引号不能
2.双引号会对换行符等转义字符进行解析,而单引号不能
1  <?php
2     $name = "Jack";
3     echo '$nameJones, you are a good \t\tguy <br>';
4     echo "{$name}Jones, you are a good \t\tguy";
5  ?>
页面输出
$nameJones, you are a good \t\tguy 
JackJones, you are a good guy

 +++++++++++开机顺序 +++++++++++
1) BIOS: BIOS是写在主板上的程序，他负责查找硬盘的MBR。
2) MBR: 主引导分区，内包含Boot Loader
3) Boot Loader: 按用户选择读取操作系统内核程序
4) Kernel: 内核程序运行，开机
Tips ： 安装Windows和Linux双系统，应该先安装Windows再安装Linux，因为先安装Linux，在Windows安装时会覆盖MBR，重写Boot Loader程序，这样会导致Loader无法查找到Linux。而Linux在安装时可以手动选择安装Loader程序的启动扇区，或者设置Loader程序的启动菜单，而不会破坏Windows的loader。当然如果先装了Linux，MBR被覆盖后也可以用其他方式来修复MBR



3. unix/linux 基本使用

linux下查看当前系统负载信息的一些方法。
vim的基本快捷键。
ssh 安全增强方法;密码方式和rsa key 方式的配置。
rpm/apt/yum/ports 装包，查询，删除的基本命令。
Makefile的基本格式，gcc 编译，连接的命令,-O0 和-O3区别。
gdb,strace,valgrind的基本使用.

4. 前端,HTML,JS

css盒模型。
javascript中的prototype。
javascript中this对象的作用域。
IE和firefox事件冒泡的不同。
什么是怪异模式,标准模式，近标准模式。
DTD的定义
IE/firefox常用hack.
firefox,IE下的前端js/css调试工具。




 public function search(){
            $map['tel'] = array('LIKE' , '%'.$_GET['tel'].'%');//模糊          
              if(empty($map['ctime'])){
                    if (isset($_GET['ctimes'])) {
                          $map['ctime'][] = array('EGT',strtotime($_GET['ctimes']));
                          $pamap['ctimes'] = $_GET['ctimes'];
                    }
                    if (isset($_GET['ctimee'])) {
                          $map['ctime'][] = array('ELT',strtotime($_GET['ctimee']));
                          $pamap['ctimee'] = $_GET['ctimee'];
                     }
              }
            $list = paging('tel_message', $map, true, '30', 'id desc',$pamap);              
            foreach ($list['list'] as $k => $val) {
            $arr[] = $val;
            }
            $Model=D('Telmessage');
            $array=$Model->getData();
            foreach($arr as $num=>$value){
                    $arr[$num]['ctime']=date('Y-m-d H:i:s',$arr[$num]['ctime']);
                 }       
            $this->assign('count',$array['count']); 
            $this->assign('_page', $list['show']);           
            $this->assign('arrcount', $arrcount);
            $this->assign('data',$arr);
            $this->display('index');
     }
  


  
