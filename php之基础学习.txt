1》》》》》base64_encode
string base64_encode(string data)
将字符串以64位进行编码，可以让中文字或者图片也能在网络上顺利传输。

2》》》》》get_loaded_extensions()
这是查看php开启的扩展，输出的一个数组元素。

3》》》》》setlocale() 
函数设置地区信息（地域信息）。
设置地区为 US English，然后重新设置回系统默认：
<?php
echo setlocale(LC_ALL,"US");
echo "<br>";
echo setlocale(LC_ALL,NULL);
?>

4》》》》》数组函数
array()	创建数组。	
array_change_key_case()	返回其键均为大写或小写的数组。 	
array_chunk()	把一个数组分割为新的数组块。	
array_combine()	通过合并两个数组来创建一个新数组。	
array_count_values()	用于统计数组中所有值出现的次数。	
array_diff()	返回两个数组的差集数组。	
array_diff_assoc()	比较键名和键值，并返回两个数组的差集数组。	
array_diff_key()	比较键名，并返回两个数组的差集数组。	
array_diff_uassoc()	通过用户提供的回调函数做索引检查来计算数组的差集。	
array_diff_ukey()	用回调函数对键名比较计算数组的差集。	
array_fill()	用给定的值填充数组。	
array_filter()	用回调函数过滤数组中的元素。	
array_flip()	交换数组中的键和值。	
array_intersect()	计算数组的交集。	
array_intersect_assoc()	比较键名和键值，并返回两个数组的交集数组。	
array_intersect_key()	使用键名比较计算数组的交集。	
array_intersect_uassoc()	带索引检查计算数组的交集，用回调函数比较索引。	
array_intersect_ukey()	用回调函数比较键名来计算数组的交集。	
array_key_exists()	检查给定的键名或索引是否存在于数组中。	
array_keys()	返回数组中所有的键名。	
array_map()	将回调函数作用到给定数组的单元上。	
array_merge()	把一个或多个数组合并为一个数组。	
array_merge_recursive()	递归地合并一个或多个数组。	
array_multisort()	对多个数组或多维数组进行排序。	
array_pad()	用值将数组填补到指定长度。	
array_pop()	将数组最后一个单元弹出（出栈）。	
array_product()	计算数组中所有值的乘积。	
array_push()	将一个或多个单元（元素）压入数组的末尾（入栈）。	
array_rand()	从数组中随机选出一个或多个元素，并返回。	
array_reduce()	用回调函数迭代地将数组简化为单一的值。	
array_reverse()	将原数组中的元素顺序翻转，创建新的数组并返回。	
array_search()	在数组中搜索给定的值，如果成功则返回相应的键名。
array_shift()	删除数组中的第一个元素，并返回被删除元素的值。	
array_slice()	在数组中根据条件取出一段值，并返回。	
array_splice()	把数组中的一部分去掉并用其它值取代。	
array_sum()	计算数组中所有值的和。	
array_udiff()	用回调函数比较数据来计算数组的差集。	
array_udiff_assoc()	带索引检查计算数组的差集，用回调函数比较数据。
array_udiff_uassoc()	带索引检查计算数组的差集，用回调函数比较数据和索引。	
array_uintersect()	计算数组的交集，用回调函数比较数据。	
array_uintersect_assoc()	带索引检查计算数组的交集，用回调函数比较数据。	
array_uintersect_uassoc()	带索引检查计算数组的交集，用回调函数比较数据和索引。	
array_unique()	删除数组中重复的值。	
array_unshift()	在数组开头插入一个或多个元素。	
array_values()	返回数组中所有的值。	
array_walk()	对数组中的每个成员应用用户函数。	
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。	
arsort()	对数组进行逆向排序并保持索引关系。	
asort()	对数组进行排序并保持索引关系。	
compact()	建立一个数组，包括变量名和它们的值。	
count()	计算数组中的元素数目或对象中的属性个数。	
current()	返回数组中的当前元素。	
each()	返回数组中当前的键／值对并将数组指针向前移动一步。	
end()	将数组的内部指针指向最后一个元素。	
extract()	从数组中将变量导入到当前的符号表。	
in_array()	检查数组中是否存在指定的值。	
key()	从关联数组中取得键名。	
krsort()	对数组按照键名逆向排序。	
ksort()	对数组按照键名排序。	
list()	把数组中的值赋给一些变量。	
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。	
natsort()	用“自然排序”算法对数组排序。	
next()	将数组中的内部指针向前移动一位。	
pos()	current() 的别名。	
prev()	将数组的内部指针倒回一位。	
range()	建立一个包含指定范围的元素的数组。	
reset()	        将数组的内部指针指向第一个元素。	
rsort()	        对数组逆向排序。	
shuffle()	把数组中的元素按随机顺序重新排列。	
sizeof()	count() 的别名。	
sort()	        对数组排序。	
uasort()	使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。	
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。	
usort()	使用用户自定义的比较函数对数组中的值进行排序。

PHP函数microtime()返回当前 Unix 时间戳和微秒数。

5》》》》strpos()
在使用该函数的时候。里面的位置一定要分清楚，strpos(原字符串，“需要查找的字符串片段”);
谨记谨记谨记

 
6》》》》strcmp()函数
比较两个字符串（区分大小写）：
<?php
echo strcmp("Hello world!","Hello world!");
?>


7》》》》array_unique(array)  函数
该函数用来移除数组中的重复的值，并返回结果数组。
当几个数组元素的值相等时，只保留第一个元素，其他的元素被删除。
返回的数组中键名不变。

1>
call_user_func('方法名称','赋的值'):一种特别的调用函数的方法，例如；
function nowmagic($a)
{
 echo $a;
}
call_user_func('nowmagic','1111111111');

2>
preg_replace_callback()正则替换回调函数;
3>
array_unshift() 函数在数组开头插入一个或多个元素。例如：
$a=array('11','22','33');
array_unshift($a,'66');
结果为：66,11,22,33
4>
is_numeric()   检测变量是否为数字或数字字符串;如果是返回true,不是返回false;
5>
array_unique() 函数移除数组中的重复的值，并返回结果数组.
$unique=array('f','d','f','s');
print_r(array_unique($unique));
结果为：
Array ( [0] => f [1] => d [3] => s ) 
6>
stripos()与strpos(),前者对大小写不敏感，后者则敏感，类似的还有str_ireplace()与str_replace()
7>
array_filter(array,function);筛选出需要的结果
function myfudction($v)
{
if($v=="H")
{
 
  return true;
}
return false;
}
$as=array("H","d","s");
print_r(array_filter($as,"myfudction"));
8>
array_intersect() 函数返回两个或多个数组的交集数组。
$add1=array(1,3,4,5);
$add2=array(3,4,6,7);
print_r(array_intersect($add1,$add2));
结果是：
Array ( [1] => 3 [2] => 4 ) 
9>
join() 函数返回由数组元素组合成的字符串。
join() 函数是 implode() 函数的别名。也就是说它也是把数组元素练成一段字符串
10>PHP 面向对象：parent::关键字
parent::用来引用父类中的方法。
class employee
{
protected $sal=3000;
public function getSal()
{
 return $this->sal;
}
}
class manager extends employee
{
   public function getSal()
   {
   parent::getSal();
$this->sal=$this->sal+2000;
return $this->sal;
    }
}
$emp=new employee();
echo $emp->getSal()."<br>";
$mana=new manager();
echo $mana->getSal();
11>
这里的$name可以直接用$this->name调用。
class Person
{
var $name;
var $age;
function say()
	{
	echo "my name is :".$this->name."<br>";
	echo "my age is :".$this->age."<br>";
    }
}
class Student extends Person
{
	var $school;
	function study()
	{
	echo "my name is:".$this->name."<br>";
	echo "i am".$this->school."study";
	}
}
$stu=new Student();
$stu->name="Bob";
$stu->age="Tom";
$stu->school="People";
$stu->study();
12>__construct()构造函数与__destruct()析构函数，前者是在一个类被实例化之前先被自动调用，无返回值，后者则是在销毁一个类之前自动执行一些东西，即两个的执行时间不一样，其他的区别不大。
final 关键字用于定义类和方法，该关键字表示该类或方法为最终版本，即该类不能被继承，或该方法在子类中不能被重载（覆盖）。

13>
__call(1,2) 方法用于监视错误的方法调用。


echo $HTTP_COOKIE_VARS["TestCookie"]; 输出所有cookie值。

mktime()函数适合用来进行日期计算和校验，设定一个固定日期。
echo date('Y-m-d H:i:s',mktime(0,0,0,12,30,1997));  //输出1997-12-30 00:00:00
echo date('Y-m-d H:i:s',mktime(0,0,0,12,32,1997));  //输出1998-01-01 00:00:00


验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间：
<?php 
$str = 'a1234'; 
if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) { 
echo "验证成功";} else { 
echo "验证失敗";}?>

SQL中DateDiff函数
返回两个日期之间的间隔。
SELECT datediff( month, '1999/07/19', '1999/08/23' )；
结果是：1；
TCP / IP长连接&连接池的应用
Reboot | 2015-11-20 15:28
我们知道TCP是基于连接的协议，其实这个“连接”只是一个逻辑上的概念。在IP层看来， TCP和UDP仅仅是内容上稍有差别而已。
TCP的“连接”仅仅是连接的两端对于四元组和sequence号的一种约定而已。
在有些文章里总会提到这名词、或者五元组，甚至七元组。虽然我很反对摆弄名词秀专业，但我们也要防止被“秀”。 其实很容易理解：
四元组： 源IP地址、目的IP地址、源端口、目的端口
五元组： 源IP地址、目的IP地址、协议、源端口、目的端口
七元组： 源IP地址、目的IP地址、协议、源端口、目的端口，服务类型，接口索引
在性能比较敏感的程序中，为了节省TCP网络调用建立连接三次握手的时间， 很多程序都会选择采用复用之前已经建立过的连接的方法来优化。
再加上往往是“请求、响应、请求、响应”的模式，单个连接限制了QPS（Query Per Second）的提升。 所以会采取开启多个连接组成一个“池子”的方式来优化性能，我们称之为连接池。
HTTP的长连接
HTTP长连接，HTTP持久连接（HTTPpersistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答， 而不是为每一个新的请求/应答打开新的连接的方法。
在HTTP 1.0 中, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：
Connection: Keep-Alive
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive
这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。
在HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。
然而，Apache 2.0 httpd 的默认连接过期时间是仅仅15秒，对于 Apache 2.2 只有5秒。 短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。
loading...
Keep-Alive的优势
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接
Keep-Alive的劣势
对于现在的广泛普及的宽带连接来说，Keep-Alive也许并不像以前一样有用。 web服务器会保持连接若干秒(Apache中默认15秒)，这与提高的性能相比也许会影响性能。对于单个文件被不断请求的服务(例如图片存放网站)，Keep-Alive可能会极大的影响性能， 因为它在文件被请求之后还保持了不必要的连接很长时间。
根据RFC2616，用户客户端与任何服务器和代理服务器之间不应该维持超过2个链接。代理服务器应该最多使用2×N个持久连接到其他服务器或代理服务器，其中N是同时活跃的用户数。这个指引旨在提高HTTP响应时间并避免阻塞。
但由于，TCP连接减少了，对于静态资源（图片、JavaScript、CSS）较多的网站， 性能反而可能会下降。
动静分离
为了规避上面说的对图片等静态资源的影响，大多数商业网站会启用独立的静态资源域名。从而保证主站的动态资源请求和静态资源的请求不会互相挤占连接。
动静分离同时还会有一个额外的好处：
对于静态资源的请求，HTTP请求头里的Cookie等信息是没有用处的， 反而占用了宝贵的上行网络资源。用独立的域名存放静态资源后，请求静态资源域名就不会默认带上主站域的Cookie，从而解决了这个问题。
如下表：
loading...
关于Reboot：
专注于互联网运维开发分享、交流，让更多的运维工程师更加专注于自动化，为国内公有云开发、监控、运维贡献自己的力量，这里集聚着国内一线互联网工程师，乐于分享与交流 ^.^发现文章不错的话请关注我们
Reboot QQ交流群：
238757010
365534424
等着   与你一起  改变这世界
一、IT技术文章：
回复"1",查看——“ 如何深入了解linux”
回复"2",查看——“Python 自动化框架”
回复"3",查看——“ Linux 运维职业规划”
回复"4",查看——“提升B格的命令技巧”
回复"5",查看——“网络编程-从Apache到Nginx”
回复"6",查看——“两个使用的Python 装饰器
回复"7",查看——“Python 多线程、进程那些事”
回复"8",查看——“1000，000 packets/s的挑战”
回复"9",查看——“Op危机，你嗅到了没？”
回复"10",查看——“干货丨戏说非阻塞网络编程”
回复"11",查看——“用Python写一个简单的监控系统”
回复"12",查看——“提高你Python 编码效率的‘武林秘籍’”
二、最新课程：
回复"课程",查看——最新课程消息
回复"报名"，查看——报名咨询方式
回复"Reboot",查看——Reboot简介





strstr和strcchr的区别
strstr 显示第一次找到，要查找的字符串，以及后面的字符串。 
strrchr 显示最后一次找到，要查找的字符串，以及后面的字符串。
<?php 
$email = 'test@test.com@jb51.net'; 
$domain = strstr($email, '@'); 
echo "strstr 测试结果 $domain<br>"; 
$domain = strrchr($email, '@'); 
echo "strrchr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 @test.com@jb51.net 
strrchr 测试结果 @jb51.net

strstr与stristr的区别
<?php $email = 'zhangYingy@jb51.net'; 
$domain = stristr($email, 'y'); 
echo "strstr 测试结果 $domain<br>"; 
?>
结果如下：
strstr 测试结果 y@jb51.net
stristr 测试结果 Yingy@jb51.net

substr用法：
<?php $email = 'zhangYingy@jb51.net'; 
$domain = substr($email, 6); 
echo "substr 测试结果 $domain<br>"; 
?>
结果如下：
substr 测试结果 ingy@jb51.net

php默认变量
echo __FILE__;//这是文件完整的地址为：D:\wamp\wamp\apps\think\test.php
echo __LINE__;//显示这一句所在的行数
echo PHP_VERSION;//显示php版本
echo PHP_OS; //显示php运行系统名称
echo TRUE;  //1,同理FALSE结果为0
echo E_ERROR;
echo "<br>";
//可以用define函数自定义默认变量
define('COPYRIGHT','Copyright');
echo COPYRIGHT;

$testa=array('0'=>array('id'=>14),'1'=>array('id'=>23),'3'=>array('id'=>32));
array_slice($testa,1-1,'id');
var_dump($testa);exit;
用array_slice()可以更换数组的键名，不过如果键名相同，数组会自动添加新的键名，结果会是这样；
array (size=3)
  0 => 
    array (size=1)
      'id' => int 14
  1 => 
    array (size=1)
      'id' => int 23
  3 => 
    array (size=1)
      'id' => int 32


jquery中attr()使用
<script>                                  //用attr设置属性值
$("ul li:eq(1)").attr("title","不吃橘子");
alert($("ul li:eq(1)").attr("title"));
</script>
                                          //用attr删除属性值
<script>
$("ul li:eq(1)").removeAttr ("title");
</script>

urlencode()函数：
本函数将字符串以 URL 编码。例如空格就会变成加号。
Homepage 中 form 资料传送就是用 urlencode 编码后再送出。

array_multisort()这个函数：
有时候我们需要对二维数组的某个键的值进行排序，这里就是讨论这个问题。
我们可以使用array_multisort()这个函数。array_multisort() 函数对多个数组或多维数组进行排序。

list() 函数:
list() 函数用数组中的元素为一组变量赋值。
注意，与 array() 类似，list() 实际上是一种语言结构，不是函数。
<?php
	$my_array = array("Dog","Cat","Horse");
	list($a, , $c) = $my_array;
	echo "Here I only use the $a and $c variables.";
?>  
运行结果： Here I only use the Dog and Horse variables.

number_format() 函数:
number_format() 函数通过千位分组来格式化数字。
<?php
$num = 500000;

echo number_format($num);
// 500,000

echo number_format($num, 2);
// 500,000.00

echo number_format($num, 3, ".", ",");
// 500,000.000
?>

parse_url()函数:
parse_url() 函数可以解析 URL，返回其组成部分。它的用法如下：
array = parse_url( string url );
<?php 
  $url="http://www.nowmagic.net/welcome/";
  $parts=parse_url($url);
  print_r($parts);
?>
结果是：Array ( [scheme] => http [host] => www.nowmagic.net [path] => /welcome/ )  ;

strip_tags()函数:
strip_tags() 函数剥去 HTML、XML 以及 PHP 的标签
<?php
echo strip_tags("Hello <b>NowaMagic!</b>");
?>
结果是：Hello NowaMagic!

is_numeric函数：
is_numeric检测变量是否为数字或数字字符串

shuffle（）函数：将数组随机打乱
<?php 
  $data=array('111','222','333','444','555','666');
  shuffle($data);
  print_r($data);
  结果是：Array ( [0] => 222 [1] => 555 [2] => 333 [3] => 111 [4] => 444 [5] => 666 ) 
?>

http_bluid_query()函数：将数组变成url
<?php 
  $data = array(
   'site'=>'www.nowamagic.net', 
	'foo'=>'bar', 
	'baz'=>'boom', 	
	'name'=>'nowamagic'); 
  echo http_build_query($data); 
?>
结果为：site=www.nowamagic.net&foo=bar&baz=boom&name=nowamagic

stream_context_create()函数：
stream_context_create() 作用：创建并返回一个文本数据流并应用各种选项，
可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程。

php查看本地目录glob()和scandir()
glob()函数
$img=array('gif','png','jpg');
$dir='img/';  //查找的文件名所在目录
$pic=array();
foreach($img as $k=>$v){
	$pattern=$dir.'*.'.$v;
	$all=glob($pattern);
	$pic=array_merge($pic,$all);
}
var_dump($pic);
foreach($pic as $p){
echo $p.'<br>';
}
上面的等同于：
$files=glob('img/*.jpg');
print_r($files);

结果均为：
array (size=2)
  0 => string 'img/test.jpg' (length=12)
  1 => string 'img/test2.jpg' (length=13)

scandir()函数：
$dir='img/';
$file=scandir($dir);
print_r($file);

结果为：
Array ( [0] => . [1] => .. [2] => test.jpg [3] => test2.jpg ) 


序列化与反序列化
序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这
两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。 
PHP中的序列化和反序列化分别通过函数serialize()和unserialize()即可实现。
serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将serialize的返回结果作为参数，进行反序列化，得到原对象。

json_encode()与json_decode()
这是PHP的原生函数，然而在今天JSON越来越流行，所以在PHP5.2以后，
PHP开始支持JSON，你可以使用 json_encode() 和 json_decode() 函数


文件压缩的原理：
电脑是采用二进制的，所以就全是1和0两个数字。那么难免的有的时候会重复出现，比如：10101010101010101010101010101010，那么就是16个10于是压缩的时候就记做16个10。
然后我们把16换算为二进制的，就是1000。那么电脑就会写成100010。当然，这其中一定还会有一些记号。只是我不太清楚而已。然后在解压的时候就可以把100010还原为10101010101010101010101010101010。
那么一算，就把本来的32位的数字变为了6位。所以就达到了压缩的目的！
php字符串压缩与解压缩：

php扫描本地目录与文件：
header('content-type:text/html; charset=utf-8');
   $dirname='Public'; //要遍历的目录名字
   $dir_handle=opendir($dirname);
    echo '<table border="1" align="center" width="960px" cellspacing="0" cellpadding="0">';
   echo '<caption><h2>目录'.$dirname.'下面的内容</h2></caption>';
   echo '<tr align="left" bgcolor="#cccccc">';
   echo '<th>文件名</th><th>文件大小</th><th>文件类型</th><th>修改时间</th><th>完整路径</th><th>test1</th><th>test2</th></tr>';
   while($file=readdir($dir_handle))
   {
     if($file!="."&&$file!="..")
     {
        $dirFile=$dirname."/".$file;	
        echo '<td>'.$file.'</td>';
        echo '<td>'.filesize($dirFile).'</td>';
        echo '<td>'.filetype($dirFile).'</td>';
        echo '<td>'.date("Y/n/t",filemtime($dirFile)).'</td>';
		echo '<td>'.$dirFile.'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filectime($dirFile)).'</td>';
		echo '<td>'.date('Y-m-d H:i:s',filemtime($dirFile)).'</td>';
        echo '</tr>';
     }
   }
   echo '</table>';
   closedir($dir_handle);

filectime — 取得文件的 inode 修改时间
filemtime — 取得文件修改时间
fileatime — 取得文件上次访问时间
fileperms -- 取得文件的访问权限
is_executable — 判断给定文件名是否可执行


PHP/Mysql中几个版本的进化史，比如mysql4.0到4.1，PHP 4.x到5.1的重大改进等等：
MySQL：  
一、从 4.0 到 4.1 的主要变化  
  
如果在4.1.0到4.1.3版本的MySQL中创建了包含 TIMESTAMP 字段的 InnoDB表。则在升级到4.1.4及更高时需要重建表，因为存储格式发生变化了。  
  
字符串根据标准SQL来比较：比较之前不删除末尾的空格，以前用末尾空格扩展了比较短的字符串。现在的结果是  
  
'a' > 'a\t'，以前则不这样。可以用 mysqlcheck 来检查一下数据表。  
  
TIMESTAMP 返回 'YYYY-MM-DD HH:MM:SS' 格式的字符串。在MySQL 4.0中，可以增加选项 --new 来获得ySQL 4.1中这方面的特性。  
  
在MySQL4.1.1前，语句解析器不是那么严格，它在处理字符串转时间转换时会忽略第一个数字前的其他字符。在4.1.1之后，就比较严格了，返回结果是 DATE, DATETIME, 或 TIME 类型的函数的结果会被转换成时间型  
  
二、再看从 4.1 到 5.0 的主要变化  
  
◆InnoDB 和 MyISAM 表中空格结尾的 TEXT 字段索引顺序改变了。因此需要运行"CHECK TABLE" 语句修复数据表，如果出现错误，就运行 "OPTIMIZE TABLE" 或 "REPAIR TABLE" 语句修复，甚至重新转储(用mysqldump)。  
  
◆MySQL 5.0.15开始，如何处理 BINARY 字段中填充的值已经改变了。填充的值现在是0x00 而非空格了，并且在取值的时候不会去除末尾的空格。  
  
◆从MySQL 5.0.3开始，DECIMAL 的实现方式已经改变了，5.0对 DECIMAL的格式限制严格多了。在MySQL 5.0.3到5.0.5之间版本的 MyISAM 和 InnoDB 表中创建的 DECIMAL字段升级到5.0.6之后会发生崩溃。从5.0.3开始，DECIMAL 用更有效的格式来存储。5.0.3开始，在计算 DECIMAL 值和舍入精确值的时候采用精确数学。  
  
◆在以前，等待超时的锁会导致 InnoDB回滚当前全部事务，从5.0.13开始，就只回滚最近的SQL语句了。  
  
◆在4.1.13/5.0.8以前，DATETIME 的加0后就转换成 YYYYMMDDHHMMSS 格式，现在变为YYYYMMDDHHMMSS.000000 格式了  
  
◆4.1中，FLOAT 或 DOUBLE 之间的比较碰巧没问题，但在5.0中可能就不行了  
  
◆从5.0.3开始，VARCHAR 和 VARBINARY 字段中末尾的空格不再删除  
  
◆增加了一个新的启动选项 innodb_table_locks，它导致 LOCK TABLE 时也可以请求InnoDB 表锁。这个选项默认打开，不过可能在 AUTOCOMMIT=1 和 LOCK TABLES应用中会导致死锁。看来，我只需主要关注 时间(TIMESTAMP, DATETIME< DATE, TIME) 和数值型(FLOAD, DOUBLE, DECIMAL) 这两种类型的变化;另外，我升级过程中暂时还不需要涉及到字符集问题，因此相对轻松一些。  
  
升级步骤如下：  
  
执行  
  
FLUSH TABLES WITH READ LOCK;  
  
直接拷贝 MyISAM 表文件  
  
用 mysqldump 导出 Innodb 类型的表  
  
整个过程都很顺利，新系统启动之后，发现如下2个问题：  
  
新增了关键字 INOUT，因此需要检查表结构中还有其他什么字段使用关键字了  
  
DATE_FORMAT 函数要求严谨多了，  
  
DATE_FORMAT('2006/11/24 09:14:00', '%Y-%m-%d %T')   
和DATE_FORMAT('2006/11/2409:14:00', '%Y-%m-%d %T')  
  
的结果完全不一样，在 4.0 中，能兼容这两种格式，而在 5.0 中，只能正确的使用前者了，后者则会有问题。这也应该是上面提到的时间类型发生的变化所致。  

PHP5以下几个改进值得关注：  
1、极大地提高了面向对象能力；  
2、支持try/catch异常处理；  
3、改进了字符串地处理；  
4、改经了xml和web服务支持；  
5、对SQlite内置支持。  

一些php魔幻方法;
php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。  
PHP中的魔术方法有 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone, __autoload  
1、__get、__set  
这两个方法是为在类和他们的父类中没有声明的属性而设计的  
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名  
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值  
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）。  
2、__isset、__unset  
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法  
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法  
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）  
3、__call  
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法  
这里的未定义的方法包括没有权限访问的方法；如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方​法，如果本类中不存在__call()方法就去找父类中的__call()方法  
  
4、__autoload  
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。  
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：  
view plaincopy to clipboardprint?  
<?php    
class Loader    
{    
static function autoload_class($class_name)    
{    
//寻找正确的$class_name类，并引入，没有则抛出异常    
}    
}    
    
/** 
*   设置对象的自动载入 
*   spl_autoload_register — Register given function as __autoload() implementation 
*/    
spl_autoload_register(array('Loader', 'autoload_class'));    
    
$a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类    
    
?>    
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。  
5、__construct、__destruct  
__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称  
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。  
在一个函数的命名空间内，这会发生在函数return的时候。  
对于全局变量,这发生于脚本结束的时候。  
如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.  
6、__clone  
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。  
7、__toString  
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。  
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in  
此方法必须返回一个字符串。  
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。  
8、__sleep、__wakeup  
__sleep 串行化的时候用  
__wakeup 反串行化的时候调用  
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。  
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。  
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。  
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。  
9、__set_state  
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。  
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。  
10、__invoke  
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。  
PHP5.3.0以上版本有效  
11、__callStatic  
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，  
PHP5.3.0以上版本有效  
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此  

使用POSIX兼容规则的函数有：  
ereg_replace()  
ereg()  
eregi()  
eregi_replace()  
split()  
spliti()  
sql_regcase()  
mb_ereg_match()  
mb_ereg_replace()  
mb_ereg_search_getpos()  
mb_ereg_search_getregs()  
mb_ereg_search_init()  
mb_ereg_search_pos()  
mb_ereg_search_regs()  
mb_ereg_search_setpos()  
mb_ereg_search()  
mb_ereg()  
mb_eregi_replace()  
mb_eregi()  
mb_regex_encoding()  
mb_regex_set_options()  
mb_split()  
  
使用PERL兼容规则的函数有：  
preg_grep()  
preg_replace_callback()  
preg_match_all()  
preg_match()  
preg_quote()  
preg_split()  
preg_replace()  

++++++++++PHP实现等差数列求和(不使用乘法,循环,递归) ++++++++++

<html>
     <body>
         <?php
            function sum_n($a1, $d, $an) {    //$a1为首项,$d为公差,$an为最大项
                $sum = 0;
                $i = $a1;
                a:
                $sum += $i;
                $i += $d;
                if($i <= $an) goto a;
                return $sum;
            }
            
            echo sum_n(1, 1, 10);
         ?>
     </body>
 </html>

写代码来解决多进程/线程同时读写一个文件的问题：
大家都知道，PHP是没有多线程概念的，尽管如此我们仍然可以用“不完美”的方法来模拟多线程。简单的说，就是队列处理。通过对文件进行加锁和解锁，来实现。当一个文件被一个用户操作时，该文件是被锁定的，其他用户只能等待，确实不够完美，但是也可以满足一些要求不高的应用。  
function T_put($filename,$string){  
$fp = fopen($filename,’a'); //追加方式打开  
if (flock($fp, LOCK_EX)){ //加写锁  
fputs($fp,$string); //写文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
}  
function T_get($filename,$length){  
$fp = fopen($filename,’r'); //追加方式打开  
if (flock($fp, LOCK_SH)){ //加读锁  
$result = fgets($fp,$length); //读取文件  
flock($fp, LOCK_UN); //解锁  
}  
fclose($fp);  
return $result;  
}  

MyISAM 与Innodb
简单的表达。  
MyISAM 是非事务的存储引擎。  
innodb 是支持事务的存储引擎。  
  
innodb    的引擎比较适合于插入和更新操作比较多的应用  
而MyISAM  则适合用于频繁查询的应用  
  
MyISAM    --表锁。  
innodb    --设计合理的话是行锁。  
MyISAM    不会出现死锁。  
  
最大的区别就是MYISAM适合小数据，小并发；INNODB 适合大数据，大并发。最大的区别就是在锁的级别上。  
  
MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 MyISAM类型的表强调的是性能，
其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等
高级数据库功能。综述，就可以根据数据表不同的用处是用不同的存储类型。而且MyISAM是文件存储
的，可以进行直接在不同操作系统间拷贝使用。  
   
InnoDB：  
InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
InnoDB 提供了行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)。
这些特性均提高了多用户并发操作的性能表现。在InnoDB表中不需要扩大锁定(lock escalation)，
因为 InnoDB 的列锁定(row level locks)适宜非常小的空间。InnoDB 是 MySQL 上第一个提供外键约束(FOREIGN KEY constraints)的表引擎。
InnoDB 的设计目标是处理大容量数据库系统，它的 CPU 利用率是其它基于磁盘的关系数据库引擎所不能比的。
在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
 InnoDB 把数据和索引存放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 MyISAM 中，表被存放在单独的文件中。
InnoDB 表的大小只受限于操作系统的文件大小，一般为 2 GB。
InnoDB所有的表都保存在同一个数据文件 ibdata1 中（也可能是多个文件，或者是独立的表空间文件），相对来说比较不好备份，可以拷贝文件或用navicat for mysql。  
   
MyISAM  
每张MyISAM 表被存放在三个文件 ：frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex) 引伸。  
因为MyISAM相对简单所以在效率上要优于InnoDB，小型应用使用MyISAM是不错的选择。  
MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦  

2.web 架构，安全,项目经验

++++++++++介绍xdebug,apc,eAccelerator,Xcache,Zend opt的使用经验++++++++++++
Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况
。
eAccelerator是一个自由开放源码php加速器，优化和动态内容缓存，提高了php脚本的缓存性能，
使得PHP脚本在编译的状态下，对服务器的开销几乎完全消除。它还有对脚本起优化作用，以加快其执行效率。
使您的PHP程序代码执效率能提高1-10倍；
XCache 是一个开源的 opcode 缓存器/优化器, 这意味着他能够提高您服务器上的 PHP 性能. 他通过把编译 
PHP 后的数据缓冲到共享内存从而避免重复的编译过程, 能够直接使用缓冲区已编译的代码从而提高速度. 
通常能够提高您的页面生成速率 2 到5 倍, 降低服务器负载.
Zend Optimizer(以下简称ZO)用优化代码的方法来提高php应用程序的执行速度。实现的原理是对那些在被最终
执行之前由运行编译器(Run-TimeCompiler)产生的代码进行优化。
一、PHP加速器介绍

        PHP加速器是一个为了提高PHP执行效率，从而缓存起PHP的操作码，这样PHP后面执行就不用解析转换了，可以直接调用PHP操作码，这样速度上就提高了不少。

        Apache中使用mod_php的请求、响应执行流程：

　　1、Apache接收请求。
2、Apache传递请求给mod_php。
3、mod_php定位磁盘文件，并加载到内存中。
4、mod_php编译源代码成为opcode树。
5、mod_php执行opcode树。

       PHP加速器相应的就是第四步，它的目的就是防止PHP每次请求都重复编译PHP代码，因为在高访问量的网站上，大量的编译往往没有执行速度快呢？所以这里面有个瓶颈就是PHP的重复编译既影响了速度又加载了服务器负载，为了解决此问题，PHP加速器就这样诞生了。

二、PHP加速器安装与配置

        1、安装配置APC

             APC全称是Alternative PHP Cache,官方翻译叫”可选PHP缓存”,它是PHP PECL中的一个扩展，好像是facebook在使用它，下面开始安装（ubuntu环境）： 
$wget http://pecl.php.net/get/APC-3.0.19.tgz
$tar xvzf APC-3.0.19.tgz
$cd APC-3.0.19/APC-3.0.19
$/usr/local/php/bin/phpize
$./configure –enable-apc –enable-apc-mmap –with-php-config=/usr/local/php/bin/php-config
$make
$sudo make install

下面我们再配置APC,因为我的PECL扩展路径改变了，所以我得移动下编译好的文件：
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/apc.so /usr/local/php/lib/php/extensions/PECL

然后我们再编辑php.ini文件进行配置，请把下面的代码加入到php.ini中即可：
extension_dir = "/usr/local/php/lib/php/extensions/PECL"
extension = apc.so
; APC
apc.enabled = 1
apc.shm_segments = 1
apc.shm_size = 64
apc.optimization = 1
apc.num_files_hint = 0
apc.ttl = 0
apc.gc_ttl = 3600
apc.cache_by_default = on

     这样重启apache就会在phpinfo()信息中显示。

       2、安装配置eAccelerator

          eAccelerator的前身其实是truck-mmcache，因为开发truk-mmcache的人被Zend给招安了，所以开发eAccelerator的人继承了truk-mmcache的一些特性，设计出eAccelerator加速器。安装如下：
$wget http://jaist.dl.sourceforge.net/sourceforge/eaccelerator/eaccelerator-0.9.5.tar.bz2
$tar -jxf eaccelerator-0.9.5.tar.bz2
$cd eaccelerator-0.9.5
$/usr/local/php/bin/phpize
$./configure –enable-eaccelerator=shared –with-php-config=/usr/local/php/bin/php-config
$make
$sudo make install
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/eaccelerator.so /usr/local/php/lib/php/extensions/PECL

将下面代码加入php.ini文件中
extension = eaccelerator.so
; eAccelerator
eaccelerator.shm_size = "16"
eaccelerator.cache_dir = "/tmp/eaccelerator"
eaccelerator.enable = "1"
eaccelerator.optimizer = "1"
eaccelerator.check_mtime = "1"
eaccelerator.debug = "0"
eaccelerator.filter = ""
eaccelerator.shm_max = "0"
eaccelerator.shm_ttl = "0"
eaccelerator.prune_period = "0"
eaccelerator.shm_only = "0"
eaccelerator.compress = "1"
eaccelerator.compress_level = "9"

创建缓存目录,重启apache

$sudo mkdir /tmp/eaccelerator
$sudo chmod 777 /tmp/eaccelerator
$sudo /usr/local/apache/apachectl restart

在phpinfo()检查是否安装成功.

3、安装配置XCache

XCache作为国人自己开发的东西，做小菜鸟的我也感到骄傲，而且XCache无论在速度还是性能上都做的不错。下面就赶紧让我们品尝它吧！

$wget http://xcache.lighttpd.net/pub/Releases/1.2.2/xcache-1.2.2.tar.gz
$tar xvzf xcache-1.2.2.tar.gz
$cd xcache-1.2.2
$/usr/local/php/bin/phpize
$./configure –enable-xcache –enable-xcache-coverager –with-php-config=/usr/local/php/php-config
$make
$sudo make install
$sudo mv /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/xcache.so /usr/local/php/lib/php/extensions/PECL

在php.ini添加配置信息：

extension = xcache.so
; xcache
xcache.admin.user = "admin"
xcache.admin.pass = "(执行) echo ’(你的密码)’|md5sum(得出的密文)"
;
xcache.size = 24M
xcache.shm_scheme = "mmap"
xcache.count = 2
xcache.slots = 8k
xcache.ttl = 0
xcache.gc_interval = 0

xcache.var_size = 8M
xcache.var_count = 1
xcache.var_slots = 8k
xcache.var_ttl = 0
xcache.var_maxttl = 0
xcache.var_gc_interval = 300
xcache.test = Off
xcache.readonly_protection = On
xcache.mmap_path = "/tmp/xcache"
xcache.coredump_directory = ""
xcache.cacher = On
xcache.stat = On
xcache.optimizer = Off
;
xcache.coverager = On
xcache.coveragedump_directory = ""

创建缓存目录，重启apache

$sudo mkdir /tmp/xcache
$sudo chmod 777 /tmp/xcache
$sudo /usr/local/apache/bin/apachectl restart
去查看phpinfo()信息吧！
   1、通过测试得出eAccelerator在请求时间和内存占用综合方面是最好的。

   2、通过测试得出使用加速器比无加速器在请求时间快了3倍左右。

   3、通过各个官方观察，XCache是更新最快的，这也说明最有发展的。

 以上是总结结果，你也许会问我到底用那个加速器好呢？我只能告诉你，首先，用一定比不用好，
其次每个加速器还有一些可以调优的参数，所以要根据你的系统环境而定，然后，我个人觉得你可以详细研
究下eAccelerator和XCache，这两款潜力还是很大的.


++++++++++++使用mod_rewrite,在服务器上没有/archivers/567.html这个物理文件时，重定向到index.php?id=567 ,请先打开mod_rewrite++++++++++++

++++++++++++MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？++++++++++++

++++++++++++写出一种排序算法（原理），并说出优化它的方法。++++++++++++
php冒泡排序：

原理：
依次比较相邻的两个数，将小数放在前面，大数放在后面。即首先比较第1个和第2个数，
将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
直至比较最后两个数，将小数放前，大数放后。重复以上过程，仍从第一对数开始比较
（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，
大数放后，一直比较到最大数前的一对相邻数，将小数放前，大数放后，第二趟结束，
在倒数第二个数中得到一个新的最大数。如此下去，直至最终完成排序。
在许多程序设计中，我们需要将一个数列进行排序，以方便统计，常见的排序方法有冒泡排序，
二叉树排序，选择排序等等。而冒泡排序一直由于其简洁的思想方法和比较高的效率而倍受青睐。
由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。
function bubble_sort($array)  
{  
    $count = count($array);  
    if($count <= 0)  
    {  
        return false;  
    }  
    for($i=0; $i<$count; $i++)  
    {  
        for($k=$count-1; $k>$i; $k--)  
        {  
            if($array[$k] < $array[$k-1])  
            {  
                $tmp = $array[$k];  
                $array[$k] = $array[$k-1];  
                $array[$k-1] = $tmp;  
            }  
        }  
    }  
    return $array;  
}  
冒泡原理：两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。

php快排算法：
function quick_sort($arr){
	$length=count($arr);
	if($length<=1){
		return $arr;
	}
	$base_num=$arr[0];
        //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内，初始化两个数组
	$left_array=array();   //这是小于标准的
	$right_array=array();  //这是大于标准的
	for($i=1;$i<$length;$i++){
		if($base_num>$arr[$i]){
				$left_array[]=$arr[$i];//放入左边数组
			}
			else{
       			     $right_array[]=$arr[$i];  //放入右边数组
				}
	}
  //再分别对左边和右边的数组进行相同的排序处理方式
  //递归调用这个函数,并记录结果
  $left_array=quick_sort($left_array);
  $right_array=quick_sort($right_array);
  //合并左边标尺右边
  return array_merge($left_array,array($base_num),$right_array);
}


插入排序算法：
function insert_sort($arr){
 for($i=1,$len=count($arr);$i<$len;$i++){
      $tmp=$arr[$i];
      for($j=$i-1;$j>=0;$j--){
           if($tmp<$arr[$j])  {
                $arr[$j+1]=$arr[$j];
                 $arr[$j]=$tmp;
           }
         else{
              break;
              }
      }
  }
return $arr;
}


二叉树排序算法：
    <?php
 2     //二叉树的广度优先遍历
 3     //使用一个队列实现
 4  
 5      class Node {
 6          public $data = null;
 7          public $left = null;
 8          public $right = null;
 9      }
10  
11      //@param $btree 二叉树根节点
12      function breadth_first_traverse($btree) {
13          $traverse_data = array();
14          $queue = array();
15          array_unshift($queue, $btree); #根节点入队
16          
17          while (!empty($queue)) { #持续输出节点，直到队列为空
18              $cnode = array_pop($queue); #队尾元素出队
19              $traverse_data[] = $cnode->data;
20  
21              #左节点先入队，然后右节点入队
22              if ($cnode->left != null) array_unshift($queue, $cnode->left);
23              if ($cnode->right != null) array_unshift($queue, $cnode->right);
24          }
25  
26          return $traverse_data;
27      }
28 
29      #深度优先遍历,使用一个栈实现
30      function depth_first_traverse($btree) {
31         $traverse_data = array();
32         $stack = array();
33         array_push($stack, $btree);
34 
35         while (!empty($stack)) {
36             $cnode = array_pop($stack);
37             $traverse_data[] = $cnode->data;
38 
39             if ($cnode->right != null) array_push($stack, $cnode->right);
40             if ($cnode->left != null) array_push($stack, $cnode->left);
41         }
42 
43         return $traverse_data;
44      }
45  
46      $root = new Node();
47      $node1 = new Node();
48      $node2 = new Node();
49      $node3 = new Node();
50      $node4 = new Node();
51      $node5 = new Node();
52      $node6 = new Node();
53  
54      $root->data = 1;
55      $node1->data = 2;
56      $node2->data = 3;
57      $node3->data = 4;
58      $node4->data = 5;
59      $node5->data = 6;
60      $node6->data = 7;
61  
62      $root->left = $node1;
63      $root->right = $node2;
64      $node1->left = $node3;
65      $node1->right = $node4;
66      $node2->left = $node5;
67      $node2->right = $node6;
68  
69      $traverse = breadth_first_traverse($root);
70      print_r($traverse);
71      echo "<br>";
72      $traverse = depth_first_traverse($root);
73      print_r($traverse);
74  ?>
 

++++++++++mysql_connect 与 memcache_connect 应该哪个在在前，哪个在后++++++++++
答案应该是先 memcache_connect 再 mysql_connect,因为memcache存在不稳定因素，容易发生阻塞，
一旦memcache发生阻塞，如果是先mysql_connect,就会造成生成大量mysql空链接而无法释放
一个类似的问题是 echo $html 和 mysql_connect应该哪个在前
按照网上看到的以为叫caoz的朋友的说法，应该是mysql_connect在前，echo $html会等待网络传输，
并发量高的时候会造成数据库链接的阻塞
++++++++++Apache可以被配置为正向(forward)和反向(reverse)代理。++++++++++ 
正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个
请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要
进行一些特别的设置才能使用正向代理。 
    正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用
缓冲特性(由mod_cache提供)减少网络使用率。 使用ProxyRequests指令即可激活正向代理。因为正向代理
允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端
提供服务.
   反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。
客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)
转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。
    反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多
台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，还可以启用高级URL策略和管理技术，
从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 可以使用ProxyPass指令激活反向
代理。配置反向代理并不需要打开ProxyRequests指令
+++++++++++对于大流量的网站,您采用什么样的方法来解决各页面访问量统计问题+++++++++++
确认服务器硬件是否足够支持当前的流量,数据库读写分离,优化数据表, 
程序功能规则,禁止外部的盗链,控制大文件的下载,使用不同主机分流主要流量
+++++++++++请介绍Session的原理,大型网站中Session方面应注意什么?+++++++++++
运行机制:客户端将session id传递到服务器，服务器根据session id找到对应的文件，读取的时候对文件内容
进行反序列化就得到session的值，保存的时候先序列化再写入。
注意:1,session在大访问量网站上确实影响系统性能，影响性能的原因之一由文件系统设计造成，
在同一个目录下超过10000个文件时，文件的定位将非常耗时,可以通过修改php.ini中session.save_path设置
两级子目录 ,session将存储在两级子目录中，每个目录有16个子目录[0~f]，不过好像PHP session不支持创
建目录，你需要事先把那么些目录创建好 。
2,还有一个问题就是小文件的效率问题,可以通过存储方式中的memcache来解决I/O效率低下的问题
3,session同步问题,session同步有很多种，如果你是存储在memcached或者MySQL中，那就很容易了，
指定到同样的位置即可,还有一种方法就是在负载均衡那一层保持会话，把访问者绑定在某个服务器上，
他的所有访问都在那个服务器上就不需要session同步了
+++++++++++测试php性能和mysql数据库性能的工具,和找出瓶颈的方法。+++++++++++
xhprof  PHP性能测试工具。   MySQL 的企业监控器（Enterprise Monitor）也是值得考虑的工具之一
+++++++++++正则提出一个网页中的所有链接.+++++++++++
/(http:\/\/\[^" ']+)/gm ;
/href *= *['"]*(\S+)["']* */gm ;
preg_match_all('/a href=[\"\']|/src=[\"\']([^\"\' ]+)/i',$var,$match);
+++++++++++介绍一下常见的SSO(单点登陆)方案(比如dedecms整合discuz的passport)的原理。+++++++++++
单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在
其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，
例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系
统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯
掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，
因此要点也就以下几个：
存储信任
验证信任
如何高效存储大量临时性的信任数据
如何防止信息传递过程被篡改
如何让SSO系统信任登录系统和免登系统
对于第一个问题，一般可以采用类似与memcached的分布式缓存的方案，既能提供可扩展数据量的机制，也能
提供高效访问。对于第二个问题，一般采取数字签名的方法，要么通过数字证书签名，要么通过像md5的方式，
这就需要SSO系统返回免登URL的时候对需验证的参数进行md5加密，并带上token一起返回，最后需免登的系统
进行验证信任关系的时候，需把这个token传给SSO系统，SSO系统通过对token的验证就可以辨别信息是否被
改过。对于最后一个问题，可以通过白名单来处理，说简单点只有在白名单上的系统才能请求生产信任关系，
同理只有在白名单上的系统才能被免登录。
+++++++++++您写过的PHP框架的特点，主要解决什么问题，与其他框架的不同点。+++++++++++
+++++++++++大型的论坛/新闻文章系统/SNS网站在性能优化上有什么区别?+++++++++++
新闻媒体注意细览页的性能优化，比如图片、结构，保持清爽；
SNS注意交互、页面JS、ajxa、动态内容大小；
严格控制大小、减少定向、压缩图片、降低CSS加载速度，利用好缓存，这是通的
+++++++++++相册类应用:要求在浏览器中能同时选中并上传多个文件，图片要求能剪裁，压缩包在服务器端解压。能上传单个达50M的文件。上传过程中有进度条显示。+++++++++++
+++++++++++每个图片能生成四种大小缩略图，视频文件要转成flv供flash播放。叙述要涉及的各类开源软件和简单用途。+++++++++++
+++++++++++一 群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，
在把它踢出去…，如此不停的 进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。
要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。用程序模拟该过程。+++++++++++
1 <html>
 2     <body>        
 3         <?php
 4             function monkeyKing($n, $m) {    //$n为猴子总数,$m为剔除猴子步长
 5                 $s = 0;    //$s为大王坐标,只有一只猴子时,大王坐标为0
 6                 for($i = 2; $i <= $n; $i++) {    //依次向后递推,求到共有$n只猴子,剔除步长为$m时的大王坐标
 7                     $s = ($s + $m) % $i;    //大王坐标递推公式
 8                 }
 9                 return $s;
10             }
11             
12             echo monkeyKing(6, 2);
13         ?>
14     </body>
15 </html>
+++++++++++MySQL数据库，怎么优化？+++++++++++
(1)配置优化（服务器配置）   (2)建表优化（表、字段设置） (3)查询优化（sql语句） 答： 1、选取最适用
的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM 2、
使用连接（JOIN）来代替子查询: 3、使用联合(UNION)来代替手动创建的临时表 4、事务处理: 5、锁定表,
优化事务处理: 6、使用外键,优化锁定表 7、建立索引: 8、优化查询语句
+++++++++++写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。（目录操作）+++++++++++
$d = dir(dirname(__file__));

echo "Handle: " . $d->handle . "\n";

echo "Path: " . $d->path . "\n";

while ( false !== ($entry = $d->read ()) ) {

echo $entry . "";

}

$d->close ();
+++++++++++怎么防止sql注入？+++++++++++
答：①、过滤用户提交的内容，比如update、insert、select、delete、*等数据库操作的关键字。
    ②、使用函数addslashes()转义提交的内容。
③、Php配置文件中开启magic_quotes_gpc=on;将自动转换用户查询的sql语句，对防sql注入有重大作用。
④、在php配置文件中将register_globals设置为off，关闭全局变量注册。
⑤、在php配置文件中开启安全模式safe_mode=on;
⑥、Sql语句的书写尽量不要省略小引号和单引号。
⑦、提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的名称。
⑧、控制错误信息，关闭错误信息的输出，将错误信息写到日志文件中，不要在网站暴漏错误信息。
+++++++++++数据库索引有几类，分别是什么？什么时候该用索引？+++++++++++
答：①主键索引，它用于根据主键自身的唯一性来唯一标识每条记录。因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如自增加整数值。这样，无论以后是否删除以前存在的记录，每条记录都有唯一的主键索引。
②与主键索引一样，唯一索引可以防止重建重复的值。但是，不同之处在于，每个表只能有一个主键索引，但可以有多个唯一索引。
     ③常规索引。经常希望对非主键甚至并非唯一的字段上的搜索进行优化。（1）如果表中的某个列将成为大量选择查询的焦点，就应当使用单列常规索引。并且一般指定列的前N个字符对于确保唯一性已经足够，如：INDEX(lastname(5))。（2）如果指定列会经常在获取查询中一起使用，则推荐使用多列索引。Mysql的多列索引方法基于一种称为最左前缀的策略。
     ④全文索引。提供了一种高效的方法来搜索存储在CHAR、VARCHAR或者TEXT类型中的文本。Mysql默认会忽略少于4个字符的关键字。Boolean全文搜索对搜索查询提供了更细粒度的控制，允许显示的标识结果中应当或不应当出现哪些单词。
索引最佳实践
只对where和order by子句中需要的列添加索引。多余的索引会导致不必要的硬盘空间消耗，在修改表信息的时候会降低性能。有索引的表在性能会降低，这是由于每次修改记录都必须更新索引。
如果创建诸如INDEX(firstname,lastname)的索引，不要再创建INDEX(firstname),因为mysql能搜索索引前缀。不过，要记住只有前缀有索引，这个多列索引不能应用于对lastname的搜索。
对于准备索引的列要使用属性NOT NULL，这样就永远不会存在存储NULL值。
对不使用索引的查询，使用选项—log-long-format来记录日志。然后可以检查日志文件，对查询进行相应的调整。
EXPLAIN语句有助于确定mysql如何执行查询，展示表是如何连接的，以及按怎样的顺序连接。
+++++++++++引用传值和非引用传值的区别，什么时候该用引用传值，什么时候该用非引用传值+++++++++++
答：按值传递：函数内对值的任何改变在函数外都被忽略。
引用传值：函数内对值的任何改变在函数外也将反映出这些修改。
按值传递时php必须复制值，操作大型对象和字符串这将是代价很大的操作。按引用传值不需要复制值，对性能的提高有好处。
当需要在函数内改变原变量的值时用引用传值，如果不想改变原变量的值时用传值。
+++++++++++PHP遍历文件夹及子文件夹所有文件 +++++++++++
1 <html>
 2     <body>
 3         <?php
 4             function traverse($path = '.') {
 5                 $current_dir = opendir($path);    //opendir()返回一个目录句柄,失败返回false
 6                 while(($file = readdir($current_dir)) !== false) {    //readdir()返回打开目录句柄中的一个条目
 7                     $sub_dir = $path . DIRECTORY_SEPARATOR . $file;    //构建子目录路径
 8                     if($file == '.' || $file == '..') {
 9                         continue;
10                     } else if(is_dir($sub_dir)) {    //如果是目录,进行递归
11                         echo 'Directory ' . $file . ':<br>';
12                         traverse($sub_dir);
13                     } else {    //如果是文件,直接输出
14                         echo 'File in Directory ' . $path . ': ' . $file . '<br>';
15                     }
16                 }
17             }
18             
19             traverse('xxtt');
20         ?>
21     </body>
22 </html>
 +++++++++++PHP中单引号双引号的区别 +++++++++++
1.双引号可以解析变量表达式,单引号不能
2.双引号会对换行符等转义字符进行解析,而单引号不能
1  <?php
2     $name = "Jack";
3     echo '$nameJones, you are a good \t\tguy <br>';
4     echo "{$name}Jones, you are a good \t\tguy";
5  ?>
页面输出
$nameJones, you are a good \t\tguy 
JackJones, you are a good guy

 +++++++++++开机顺序 +++++++++++
1) BIOS: BIOS是写在主板上的程序，他负责查找硬盘的MBR。
2) MBR: 主引导分区，内包含Boot Loader
3) Boot Loader: 按用户选择读取操作系统内核程序
4) Kernel: 内核程序运行，开机
Tips ： 安装Windows和Linux双系统，应该先安装Windows再安装Linux，因为先安装Linux，在Windows安装时会覆盖MBR，重写Boot Loader程序，这样会导致Loader无法查找到Linux。而Linux在安装时可以手动选择安装Loader程序的启动扇区，或者设置Loader程序的启动菜单，而不会破坏Windows的loader。当然如果先装了Linux，MBR被覆盖后也可以用其他方式来修复MBR



3. unix/linux 基本使用

linux下查看当前系统负载信息的一些方法。
vim的基本快捷键。
ssh 安全增强方法;密码方式和rsa key 方式的配置。
rpm/apt/yum/ports 装包，查询，删除的基本命令。
Makefile的基本格式，gcc 编译，连接的命令,-O0 和-O3区别。
gdb,strace,valgrind的基本使用.

4. 前端,HTML,JS

css盒模型。
javascript中的prototype。
javascript中this对象的作用域。
IE和firefox事件冒泡的不同。
什么是怪异模式,标准模式，近标准模式。
DTD的定义
IE/firefox常用hack.
firefox,IE下的前端js/css调试工具。




 public function search(){
            $map['tel'] = array('LIKE' , '%'.$_GET['tel'].'%');//模糊          
              if(empty($map['ctime'])){
                    if (isset($_GET['ctimes'])) {
                          $map['ctime'][] = array('EGT',strtotime($_GET['ctimes']));
                          $pamap['ctimes'] = $_GET['ctimes'];
                    }
                    if (isset($_GET['ctimee'])) {
                          $map['ctime'][] = array('ELT',strtotime($_GET['ctimee']));
                          $pamap['ctimee'] = $_GET['ctimee'];
                     }
              }
            $list = paging('tel_message', $map, true, '30', 'id desc',$pamap);              
            foreach ($list['list'] as $k => $val) {
            $arr[] = $val;
            }
            $Model=D('Telmessage');
            $array=$Model->getData();
            foreach($arr as $num=>$value){
                    $arr[$num]['ctime']=date('Y-m-d H:i:s',$arr[$num]['ctime']);
                 }       
            $this->assign('count',$array['count']); 
            $this->assign('_page', $list['show']);           
            $this->assign('arrcount', $arrcount);
            $this->assign('data',$arr);
            $this->display('index');
     }
  


  
